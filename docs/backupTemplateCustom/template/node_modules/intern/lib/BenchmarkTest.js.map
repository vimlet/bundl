{"version":3,"file":"BenchmarkTest.js","sourceRoot":"","sources":["../../../src/lib/BenchmarkTest.ts"],"names":[],"mappings":"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","sourcesContent":["import { Task, CancellablePromise } from '@theintern/common';\n\n// Explicitly require benchmark dependencies and attach Benchmark to them to\n// improve WebPack compatibility\nimport * as _ from 'lodash';\nimport * as platform from 'platform';\nimport * as Benchmark from 'benchmark';\n\nimport Test, {\n  isTest,\n  SKIP,\n  TestFunction,\n  TestOptions,\n  TestProperties\n} from './Test';\nimport { InternError } from './types';\nimport Deferred from './Deferred';\n\n// TODO: remove the <any> cast when benchmark typings are updated to include\n// runInContext\n(<any>Benchmark).runInContext({ _, platform });\n\n/**\n * BenchmarkTest wraps a Benchmark.js Benchmark, mapping its API to that used by\n * [[lib/Test]].\n */\nexport default class BenchmarkTest extends Test {\n  /** The test function managed by this test */\n  test!: BenchmarkTestFunction;\n\n  /** The Benchmark.js test that actually performs benchmarking */\n  benchmark: InternBenchmark;\n\n  constructor(descriptor: BenchmarkTestOptions) {\n    // Call the superclass constructor with the set of descriptor keys not\n    // specific to BenchmarkTest\n    let args: TestOptions = <TestOptions>{};\n    Object.keys(descriptor).forEach(descriptorKey => {\n      const key = <keyof BenchmarkTestOptions>descriptorKey;\n      switch (key) {\n        case 'options':\n          break;\n        default:\n          args[<keyof TestOptions>key] = descriptor[key];\n      }\n    });\n\n    args.test = args.test || /* istanbul ignore next */ function() {};\n\n    super(args);\n\n    const options: BenchmarkOptions = Object.assign(\n      {},\n      this.test.options || {},\n      {\n        async: true,\n        setup: createLifecycle(true),\n        teardown: createLifecycle(false)\n      }\n    );\n\n    if (options.defer) {\n      this.test = (function(testFunction: BenchmarkTestFunction) {\n        return <BenchmarkDeferredTestFunction>(\n          function(this: BenchmarkTest, deferred?: Deferred<any>) {\n            // deferred is optional for compat with\n            // BenchmarkTestFunction, but it will always be defined here\n            const dfd = createDeferred(\n              this.benchmark,\n              deferred!,\n              options.numCallsUntilResolution\n            );\n            testFunction.call(this, dfd);\n          }\n        );\n      })(this.test);\n    }\n\n    this.benchmark = new Benchmark(\n      descriptor.name,\n      options.defer\n        ? 'this.benchmark.internTest.test(deferred);'\n        : 'this.internTest.test();',\n      options\n    );\n\n    Object.defineProperty(this.benchmark, 'name', {\n      get: () => {\n        return this.name;\n      },\n      set: name => {\n        this.name = name;\n      }\n    });\n\n    this.benchmark.internTest = this;\n  }\n\n  /**\n   * The number of milliseconds the test function took to complete.\n   */\n  get timeElapsed() {\n    if (this.benchmark && this.benchmark.times) {\n      return this.benchmark.times.elapsed;\n    }\n    return 0;\n  }\n\n  set timeElapsed(_value: number) {\n    // ignore\n  }\n\n  async(_timeout?: number, _numCallsUntilResolution?: number): Deferred<any> {\n    throw new Error(\n      'Benchmark tests must be marked as asynchronous and use the deferred ' +\n        'passed to them rather than call `this.async()`.'\n    );\n  }\n\n  run(): CancellablePromise<void> {\n    this._hasPassed = false;\n    this._usesRemote = false;\n\n    const benchmark = this.benchmark;\n\n    return new Task(\n      (resolve, reject) => {\n        benchmark.on('abort', () => {\n          reject(benchmark.error);\n        });\n\n        benchmark.on('error', () => {\n          if (benchmark.error === SKIP) {\n            resolve();\n          } else {\n            reject(benchmark.error);\n          }\n        });\n\n        benchmark.on('complete', () => {\n          resolve();\n        });\n\n        this.executor.emit('testStart', this).then(() => {\n          benchmark.run();\n        });\n      },\n      () => {\n        benchmark.abort();\n      }\n    )\n      .finally(() => {\n        // Stop listening for benchmark events once the test is finished\n        benchmark.off();\n      })\n      .then(\n        () => {\n          this._hasPassed = true;\n        },\n        error => {\n          this.error = error;\n          throw error;\n        }\n      )\n      .finally(() => this.executor.emit('testEnd', this));\n  }\n\n  toJSON() {\n    const json = super.toJSON();\n    const benchmark = this.benchmark;\n\n    json.benchmark = {\n      hz: benchmark.hz,\n      times: benchmark.times,\n      stats: benchmark.stats\n    };\n\n    return json;\n  }\n\n  static async(\n    testFunction: BenchmarkDeferredTestFunction,\n    numCallsUntilResolution?: number\n  ) {\n    testFunction.options = Object.assign({}, testFunction.options || {}, {\n      defer: true,\n      numCallsUntilResolution: numCallsUntilResolution\n    });\n\n    return <BenchmarkTestFunction>testFunction;\n  }\n}\n\nexport interface BenchmarkTestFunction extends TestFunction {\n  (this: BenchmarkTest): void | Promise<any>;\n  options?: BenchmarkOptions;\n}\n\nexport interface BenchmarkDeferredTestFunction extends BenchmarkTestFunction {\n  (this: BenchmarkTest, deferred: Deferred<void>): void | Promise<any>;\n  options?: BenchmarkOptions;\n}\n\nexport interface BenchmarkTestProperties extends TestProperties {\n  test: BenchmarkTestFunction;\n  skip: string;\n  numCallsUntilResolution: number;\n}\n\nexport type BenchmarkTestOptions = Partial<BenchmarkTestProperties> & {\n  name: string;\n  test: BenchmarkTestFunction;\n  options?: BenchmarkOptions;\n};\n\nexport interface BenchmarkOptions extends Benchmark.Options {\n  skip?: string;\n  numCallsUntilResolution?: number;\n}\n\nexport interface InternBenchmark extends Benchmark {\n  internTest?: BenchmarkTest;\n}\n\nexport function isBenchmarkTest(value: any): value is BenchmarkTest {\n  return value && value.benchmark != null && isTest(value);\n}\n\nconst createLifecycle = (before: boolean) => {\n  const queueName = before ? 'Before' : 'After';\n  const queueMethod = before ? 'push' : 'unshift';\n  const methodName = before ? 'before' : 'after';\n  return [\n    '(function (benchmark) {',\n    `\tvar queue = benchmark.intern${queueName}EachLoopQueue;`,\n    '\tvar suite;',\n    '\tif (!queue) {',\n    '\t\tsuite = benchmark.internTest;',\n    `\t\tbenchmark.intern${queueName}EachLoopQueue = queue = [];`,\n    '\t\twhile ((suite = suite.parent)) {',\n    `\t\t\tif (suite.${methodName}EachLoop) {`,\n    `\t\t\t\tqueue.${queueMethod}(suite);`,\n    '\t\t\t}',\n    '\t\t}',\n    '\t}',\n    '\tvar i = queue.length;',\n    '\twhile((suite = queue[--i])) {',\n    `\t\tsuite.${methodName}EachLoop();`,\n    '\t}',\n    '})(this.benchmark || this);\\n'\n  ].join('\\n');\n};\n\nfunction createDeferred(\n  benchmark: Benchmark,\n  deferred: Deferred<any>,\n  numCallsUntilResolution?: number\n) {\n  let remainingCalls = numCallsUntilResolution || 1;\n\n  return {\n    resolve() {\n      --remainingCalls;\n      if (remainingCalls === 0) {\n        deferred.resolve();\n      } else if (remainingCalls < 0) {\n        throw new Error('resolve called too many times');\n      }\n    },\n\n    reject(error: InternError) {\n      benchmark.error = error;\n      benchmark.abort();\n      deferred.resolve();\n    },\n\n    rejectOnError(this: any, callback: Function) {\n      const self = this;\n      return function(this: any) {\n        try {\n          return callback.apply(this, arguments);\n        } catch (error) {\n          self.reject(error);\n        }\n      };\n    },\n\n    callback: function(this: any, callback: Function) {\n      const self = this;\n      return this.rejectOnError(function(this: any) {\n        const returnValue = callback.apply(this, arguments);\n        self.resolve();\n        return returnValue;\n      });\n    }\n  };\n}\n"]}