{"version":3,"file":"Deferred.js","sourceRoot":"","sources":["../../../src/lib/Deferred.ts"],"names":[],"mappings":";;;;;;;;;;;IAAA;QAKE;YAAA,iBAMC;YALC,IAAI,CAAC,OAAO,GAAG,IAAI,OAAO,CAAI,UAAC,OAAO,EAAE,MAAM;gBAC5C,KAAI,CAAC,SAAS,GAAG,OAAO,CAAC;gBACzB,KAAI,CAAC,SAAS,GAAG,MAAM,CAAC;YAC1B,CAAC,CAAC,CAAC;YACH,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,cAAM,OAAA,KAAI,CAAC,SAAS,EAAd,CAAc,EAAE,cAAM,OAAA,KAAI,CAAC,SAAS,EAAd,CAAc,CAAC,CAAC;QAChE,CAAC;QAMD,2BAAQ,GAAR,UAAS,QAAkB;YACzB,IAAM,GAAG,GAAG,IAAI,CAAC;YACjB,OAAO,IAAI,CAAC,aAAa,CAAC;gBAAoB,cAAc;qBAAd,UAAc,EAAd,qBAAc,EAAd,IAAc;oBAAd,yBAAc;;gBAC1D,IAAM,WAAW,GAAG,QAAQ,CAAC,KAAK,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC;gBAC/C,GAAG,CAAC,OAAO,EAAE,CAAC;gBACd,OAAO,WAAW,CAAC;YACrB,CAAC,CAAC,CAAC;QACL,CAAC;QAKD,gCAAa,GAAb,UAAc,QAAkB;YAC9B,IAAM,GAAG,GAAG,IAAI,CAAC;YACjB,OAAO;gBAAoB,cAAc;qBAAd,UAAc,EAAd,qBAAc,EAAd,IAAc;oBAAd,yBAAc;;gBACvC,IAAI;oBACF,OAAO,QAAQ,CAAC,KAAK,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC;iBACnC;gBAAC,OAAO,KAAK,EAAE;oBACd,GAAG,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;iBACnB;YACH,CAAC,CAAC;QACJ,CAAC;QAED,0BAAO,GAAP,UAAQ,KAAS;YACf,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,CAAC;QACxB,CAAC;QAED,yBAAM,GAAN,UAAO,KAAa;YAClB,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,CAAC;QACxB,CAAC;QAES,4BAAS,GAAnB;YACE,IAAI,CAAC,SAAS,GAAG,cAAO,CAAC,CAAC;YAC1B,IAAI,CAAC,SAAS,GAAG,cAAO,CAAC,CAAC;QAC5B,CAAC;QACH,eAAC;IAAD,CAAC,AApDD,IAoDC","sourcesContent":["export default class Deferred<T> {\n  private _resolver!: (value?: T) => void;\n  private _rejector!: (error?: Error) => void;\n  readonly promise: Promise<T>;\n\n  constructor() {\n    this.promise = new Promise<T>((resolve, reject) => {\n      this._resolver = resolve;\n      this._rejector = reject;\n    });\n    this.promise.then(() => this._finalize, () => this._finalize);\n  }\n\n  /**\n   * Wraps any callback to resolve the deferred so long as the callback\n   * executes without throwing any Errors.\n   */\n  callback(callback: Function): any {\n    const dfd = this;\n    return this.rejectOnError(function(this: any, ...args: any[]) {\n      const returnValue = callback.apply(this, args);\n      dfd.resolve();\n      return returnValue;\n    });\n  }\n\n  /**\n   * Wraps a callback to reject the deferred if the callback throws an Error.\n   */\n  rejectOnError(callback: Function): any {\n    const dfd = this;\n    return function(this: any, ...args: any[]) {\n      try {\n        return callback.apply(this, args);\n      } catch (error) {\n        dfd.reject(error);\n      }\n    };\n  }\n\n  resolve(value?: T) {\n    this._resolver(value);\n  }\n\n  reject(error?: Error) {\n    this._rejector(error);\n  }\n\n  protected _finalize() {\n    this._resolver = () => {};\n    this._rejector = () => {};\n  }\n}\n"]}