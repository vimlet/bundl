{"version":3,"file":"Executor.js","sourceRoot":"","sources":["../../../../src/lib/executors/Executor.ts"],"names":[],"mappings":"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","sourcesContent":["import * as chai from 'chai';\nimport {\n  Handle,\n  deepMixin,\n  duplicate,\n  Task,\n  CancellablePromise,\n  isPromiseLike,\n  isTask,\n  global\n} from '@theintern/common';\n\nimport Suite from '../Suite';\nimport Test from '../Test';\nimport ErrorFormatter, { ErrorFormatOptions } from '../common/ErrorFormatter';\nimport {\n  BenchmarkConfig,\n  Config,\n  PluginDescriptor,\n  ReporterDescriptor\n} from '../common/config';\nimport { normalizePathEnding } from '../common/path';\nimport { processOption, pullFromArray } from '../common/util';\nimport {\n  getInterface as getObjectInterface,\n  ObjectInterface\n} from '../interfaces/object';\nimport {\n  getInterface as getTddInterface,\n  TddInterface\n} from '../interfaces/tdd';\nimport {\n  getInterface as getBddInterface,\n  BddInterface\n} from '../interfaces/bdd';\nimport {\n  getInterface as getBenchmarkInterface,\n  BenchmarkInterface\n} from '../interfaces/benchmark';\nimport { InternError, RuntimeEnvironment } from '../types';\nimport * as console from '../common/console';\n\n/**\n * This interface represents the core functionality of an Executor\n */\nexport interface Executor {\n  readonly config: Config;\n  readonly suites: Suite[];\n\n  addSuite(factory: (parentSuite: Suite) => void): void;\n\n  configure(options: { [key: string]: any }): void;\n\n  emit<T extends NoDataEvents>(eventName: T): CancellablePromise<void>;\n  emit<T extends keyof Events>(\n    eventName: T,\n    data: Events[T]\n  ): CancellablePromise<void>;\n\n  formatError(error: Error, options?: ErrorFormatOptions): string;\n\n  log(...args: any[]): CancellablePromise<void>;\n\n  on<T extends keyof Events>(\n    eventName: T,\n    listener: Listener<Events[T]>\n  ): Handle;\n  on(listener: Listener<{ name: string; data?: any }>): Handle;\n}\n\n/**\n * This is the base executor class.\n *\n * Executors are the main driver of the testing process. An instance of Executor\n * is assigned to the `intern` global.\n */\nexport default abstract class BaseExecutor<\n  E extends Events,\n  C extends Config,\n  P extends Plugins\n> implements Executor {\n  protected _config: C;\n  protected _rootSuite: Suite;\n  protected _events: InternEvent<E>[];\n  protected _errorFormatter: ErrorFormatter | undefined;\n  protected _hasSuiteErrors = false;\n  protected _hasTestErrors = false;\n  protected _hasEmittedErrors = false;\n  protected _loader!: Loader;\n  protected _loaderOptions: any;\n  protected _loaderInit: Promise<Loader> | undefined;\n  protected _loadingPlugins: { name: string; init: CancellablePromise<void> }[];\n  protected _loadingPluginOptions: any | undefined;\n  protected _listeners: { [event: string]: Listener<any>[] };\n  protected _plugins: { [name: string]: any };\n  protected _reporters: Reporter[];\n  protected _runTask: CancellablePromise<void> | undefined;\n  protected _reportersInitialized: boolean;\n\n  constructor(options?: { [key in keyof C]?: any }) {\n    this._config = <C>{\n      bail: false,\n      baseline: false,\n      benchmark: false,\n      browser: {\n        plugins: <PluginDescriptor[]>[],\n        reporters: <ReporterDescriptor[]>[],\n        suites: <string[]>[]\n      },\n      coverageVariable: '__coverage__',\n      debug: false,\n      defaultTimeout: 30000,\n      filterErrorStack: false,\n      grep: new RegExp(''),\n      loader: { script: 'default' },\n      name: 'intern',\n      node: {\n        plugins: <PluginDescriptor[]>[],\n        reporters: <ReporterDescriptor[]>[],\n        suites: <string[]>[]\n      },\n      plugins: <PluginDescriptor[]>[],\n      reporters: <ReporterDescriptor[]>[],\n      sessionId: '',\n      suites: <string[]>[]\n    };\n\n    this._reportersInitialized = false;\n    this._events = [];\n    this._listeners = {};\n    this._reporters = [];\n    this._plugins = {};\n    this._loadingPlugins = [];\n\n    this.registerInterface('object', getObjectInterface(this));\n    this.registerInterface('tdd', getTddInterface(this));\n    this.registerInterface('bdd', getBddInterface(this));\n    this.registerInterface('benchmark', getBenchmarkInterface(this));\n\n    this.registerPlugin('chai', () => chai);\n\n    if (options) {\n      this.configure(options);\n    }\n\n    this._rootSuite = new Suite({ executor: this });\n\n    // This is the first suiteEnd listener. When the root unit test suite\n    // ends, it will emit a coverage message before any other suiteEnd\n    // listeners are called.\n    this.on('suiteEnd', suite => {\n      if (suite.error) {\n        this._hasSuiteErrors = true;\n      }\n      if (!suite.hasParent && !suite.sessionId) {\n        return this._emitCoverage('unit tests');\n      }\n    });\n\n    this.on('testEnd', test => {\n      if (test.error) {\n        this._hasTestErrors = true;\n      }\n    });\n  }\n\n  /**\n   * Get the current enviroment\n   */\n  abstract get environment(): RuntimeEnvironment;\n\n  /**\n   * The resolved configuration for this executor.\n   */\n  get config() {\n    return this._config;\n  }\n\n  /**\n   * The root suites managed by this executor\n   */\n  get suites() {\n    return [this._rootSuite];\n  }\n\n  /**\n   * Format an error, normalizing the stack trace and resolving source map\n   * references\n   */\n  formatError(error: Error, options?: ErrorFormatOptions): string {\n    if (!this._errorFormatter) {\n      this._errorFormatter = new ErrorFormatter(this);\n    }\n    return this._errorFormatter.format(error, options);\n  }\n\n  /**\n   * Load a script or scripts. This is a convenience method for loading and\n   * evaluating simple scripts, not necessarily modules. If multiple script\n   * paths are provided, scripts will be loaded sequentially in the order\n   * given.\n   *\n   * @param script a path to a script\n   */\n  abstract loadScript(script: string | string[]): CancellablePromise<void>;\n\n  /**\n   * Add a suite to the set of suites that will be run when `run` is called.\n   *\n   * The suite is added by calling a factory function. The use of a factory\n   * allows for distinct instances of a given suite to be create when an\n   * executor has multiple root suites.\n   *\n   * ```js\n   * intern.addSuite(parent => {\n   *     const suite = new Suite({\n   *         name: 'create new',\n   *         tests: [\n   *             new Test({\n   *                 name: 'new test',\n   *                 test: () => assert.doesNotThrow(() => new Component())\n   *             })\n   *         ]\n   *     });\n   *     parent.add(suite);\n   * });\n   * ```\n   *\n   * @param factory A function that will add a new Suite object to a given\n   * parent suite.\n   */\n  addSuite(factory: (parentSuite: Suite) => void) {\n    factory(this._rootSuite);\n  }\n\n  /**\n   * Configure the executor with an object containing\n   * [[lib/executors/Executor.Config]] properties.\n   */\n  configure(options: { [key in keyof C]?: any }) {\n    Object.keys(options).forEach(option => {\n      const key = <keyof C>option;\n      this._processOption(key, options[key]);\n    });\n  }\n\n  /**\n   * Emit an event to all registered listeners.\n   *\n   * Event listeners may execute async code, and a failing handler (one that\n   * rejects or throws an error) will cause the emit to fail.\n   *\n   * @param eventName the name of the event to emit\n   * @param data a data object whose type is event-dependent\n   * @returns a CancellablePromise that resolves when all listeners have processed the event\n   */\n  emit<T extends NoDataEvents>(eventName: T): CancellablePromise<void>;\n  emit<T extends keyof E>(eventName: T, data: E[T]): CancellablePromise<void>;\n  emit<T extends keyof E>(eventName: T, data?: E[T]): CancellablePromise<void> {\n    if (eventName === 'error') {\n      this._hasEmittedErrors = true;\n    }\n\n    // Ignore log messages if not in debug mode\n    if (eventName === 'log' && !this.config.debug) {\n      return Task.resolve();\n    }\n\n    // If reporters haven't been loaded yet, queue the event for later\n    if (!this._reportersInitialized) {\n      this._events.push({ eventName, data });\n      return Task.resolve();\n    }\n\n    // Handle the case when an error is emitted by an event listener. If\n    // we're not already handling an error, emit a new error event. If we\n    // are, then assume the error handler is broken and just console.error\n    // the error.\n    const handleListenerError = (error: Error) => {\n      if (eventName === 'error') {\n        console.error(this.formatError(error));\n      } else {\n        return this.emit('error', error);\n      }\n    };\n\n    let error: InternError | undefined;\n    if (eventName === 'error') {\n      error = <any>data;\n    }\n\n    // If this is an error event, mark the error as 'reported'\n    const handleErrorEvent = () => {\n      if (error) {\n        error.reported = true;\n      }\n    };\n\n    let notifications = Task.resolve();\n    let hasNotifications = false;\n\n    // First, notify the listeners specifically listening for this event\n    const listeners = this._listeners[<string>eventName];\n    if (listeners && listeners.length > 0) {\n      hasNotifications = true;\n      for (const listener of listeners) {\n        notifications = notifications\n          .then(() => Task.resolve(listener(data)))\n          .then(handleErrorEvent)\n          .catch(handleListenerError);\n      }\n    }\n\n    // Next, notify 'star' listeners, which listen for all events\n    const starListeners = this._listeners['*'];\n    if (starListeners && starListeners.length > 0) {\n      hasNotifications = true;\n      const starEvent = { name: eventName, data };\n      for (const listener of starListeners) {\n        notifications = notifications\n          .then(() => Task.resolve(listener(starEvent)))\n          .then(handleErrorEvent)\n          .catch(handleListenerError);\n      }\n    }\n\n    if (!hasNotifications) {\n      // If reporters haven't been loaded yet, cache the event\n      if (error) {\n        // Report errors, warnings, deprecation messages when no\n        // listeners are registered\n        console.error(this.formatError(error));\n        error.reported = true;\n      } else if (eventName === 'warning') {\n        console.warn(`WARNING: ${data}`);\n      } else if (eventName === 'deprecated') {\n        const message: Events['deprecated'] = <any>data!;\n        console.warn(\n          `WARNING: ${message.original} is deprecated, use ${\n            message.replacement\n          } instead.`\n        );\n      }\n\n      return Task.resolve();\n    }\n\n    return notifications;\n  }\n\n  /**\n   * Get a registered interface plugin.\n   *\n   * This method calls `getPlugin` behind the scenes.\n   *\n   * @param name the name of the interface\n   * @returns the interface, which may be an object or a callable function, or\n   * undefined if no such interface was registered.\n   */\n  getInterface(name: 'object'): ObjectInterface;\n  getInterface(name: 'tdd'): TddInterface;\n  getInterface(name: 'bdd'): BddInterface;\n  getInterface(name: 'benchmark'): BenchmarkInterface;\n  getInterface(name: string): any {\n    return this.getPlugin(`interface.${name}`);\n  }\n\n  /**\n   * Get any resources registered by a particular plugin.\n   *\n   * @param type the type of plugin (e.g., 'interface' or 'reporter')\n   * @param name the name of the plugin\n   * @returns the resource registered for the given plugin name, or undefined\n   * if no such plugin was registered.\n   */\n  getPlugin<Y extends keyof P>(type: Y, name: string): P[Y];\n  getPlugin(name: 'chai'): typeof chai;\n  getPlugin(name: 'interface.object'): ObjectInterface;\n  getPlugin(name: 'interface.tdd'): TddInterface;\n  getPlugin(name: 'interface.bdd'): BddInterface;\n  getPlugin(name: 'interface.benchmark'): BenchmarkInterface;\n  getPlugin<T>(name: string): T;\n  getPlugin<T>(type: string, name?: string): T {\n    const pluginName = typeof name === 'undefined' ? type : `${type}.${name}`;\n\n    if (!(pluginName in this._plugins)) {\n      throw new Error(`A plugin named \"${pluginName}\" has not been registered`);\n    }\n\n    return <T>this._plugins[pluginName];\n  }\n\n  /**\n   * This is a convenience method for emitting log events.\n   *\n   * When debug mode is enabled, this method emits 'log' events using `emit`.\n   * Otherwise it does nothing.\n   *\n   * @param args A list of arguments that will be stringified and combined\n   * into a space-separated message.\n   * @returns a CancellablePromise that resolves when all listeners have finished processing\n   * the event.\n   */\n  log(...args: any[]): CancellablePromise<void> {\n    if (this.config.debug) {\n      const message = args\n        .map(arg => {\n          const type = typeof arg;\n          if (type === 'string') {\n            return arg;\n          }\n          if (type === 'function' || arg instanceof RegExp) {\n            return arg.toString();\n          }\n          if (arg instanceof Error) {\n            arg = {\n              name: arg.name,\n              message: arg.message,\n              stack: arg.stack\n            };\n          }\n          try {\n            return JSON.stringify(arg);\n          } catch (error) {\n            return arg.toString();\n          }\n        })\n        .join(' ');\n      return this.emit('log', message);\n    } else {\n      return Task.resolve();\n    }\n  }\n\n  /**\n   * Add a listener for a test event.\n   *\n   * ```js\n   * intern.on('error', error => {\n   *     console.log('An error occurred:', error);\n   * });\n   * ```\n   *\n   * A listener can be notified of all events by registering for the '*'\n   * event, or by calling on with only a callback:\n   *\n   * ```js\n   * intern.on(event => {\n   *     console.log(`An ${event.name} event occurred:`, event.data);\n   * });\n   * ```\n   * Note that some events are executor-specific. For example, the\n   * [[lib/executors/Browser]] executor will never emit a tunnelStop\n   * message.\n   *\n   * @param eventName the [[lib/executors/Executor.Events|event]] to listen\n   * for\n   * @param listener a callback that accepts a single data parameter; it may\n   * return a PromiseLike object if it needs to perform async actions\n   * @returns a handle with a `destroy` method that can be used to stop\n   * listening\n   */\n  on<T extends keyof E>(eventName: T, listener: Listener<E[T]>): Handle;\n  on(listener: Listener<{ name: string; data?: any }>): Handle;\n  on<T extends keyof E>(\n    eventName: T | Listener<any>,\n    listener?: Listener<E[T]>\n  ) {\n    let _eventName: T;\n    if (typeof listener === 'undefined') {\n      listener = <Listener<any>>eventName;\n      _eventName = <T>'*';\n    } else {\n      _eventName = <T>eventName;\n    }\n    let listeners = this._listeners[<string>_eventName];\n    if (!listeners) {\n      listeners = this._listeners[<string>_eventName] = [];\n    }\n\n    if (listeners.indexOf(listener) === -1) {\n      listeners.push(listener);\n    }\n\n    const handle: Handle = {\n      destroy(this: any) {\n        this.destroy = function() {};\n        pullFromArray(listeners, listener);\n      }\n    };\n    return handle;\n  }\n\n  /**\n   * Register an interface plugin\n   *\n   * This is a convenience method for registering test interfaces. This method\n   * calls [[lib/executors/Executor.Executor.registerPlugin]] behind the\n   * scenes using the name `interface.${name}`.\n   */\n  registerInterface(name: string, iface: any) {\n    this.registerPlugin(`interface.${name}`, () => iface);\n  }\n\n  /**\n   * Register a module loader.\n   *\n   * This method sets the loader script that will be used to load plugins and\n   * suites. The callback should accept an options object and return a\n   * function that can load modules.\n   *\n   * ```js\n   * intern.registerLoader(options: any => {\n   *     // Register loader can return a Promise if it needs to load something\n   *     // itself\n   *     return intern.loadScript('some/loader.js').then(() => {\n   *         loader.config(options);\n   *         // Return a function that takes a list of modules and returns a\n   *         // Promise that resolves when they've been loaded.\n   *         return (modules: string[]) => {\n   *             return loader.load(modules);\n   *         });\n   *     });\n   * });\n   * ```\n   *\n   * @param init a loader initialzation callback that should return a loader\n   * function, or a Promise that resolves to a loader function\n   */\n  registerLoader(init: LoaderInit) {\n    const options = this._loaderOptions ? duplicate(this._loaderOptions) : {};\n    this._loaderInit = Promise.resolve(init(options));\n  }\n\n  /**\n   * Register a plugin.\n   *\n   * Plugins are resources that are loaded at the beginning of the testing\n   * process, after the loader but before any suites are registered. The\n   * callback may return a Promise if the plugin needs to do some asynchronous\n   * initialization. If the plugin is being loaded via the\n   * [[lib/executors/Executor.Config.plugins|config.plugins]]\n   * property, it's init callback will be passed any configured options. The\n   * resolved return value of the callback will be returned by\n   * [[lib/executors/Executor.Executor.getPlugin]].\n   *\n   * ```js\n   * intern.registerPlugin('foo', (options: any) => {\n   *     return {\n   *         doSomething() {\n   *             // ...\n   *         },\n   *         doSomethingElse() {\n   *             // ...\n   *         }\n   *     };\n   * });\n   * ```\n   *\n   * Code would use the plugin by calling getPlugin:\n   *\n   * ```js\n   * const { doSomething, doSomethingElse } = intern.getPlugin('foo');\n   * doSomething();\n   * ```\n   *\n   * @param name the plugin name\n   * @param init an initializer function that returns the plugin resource, or\n   * a Promise that resolves to the resource\n   */\n  registerPlugin<T extends keyof P>(\n    type: T,\n    name: string,\n    init: PluginInitializer<P[T]>\n  ): void;\n  registerPlugin(name: string, init: PluginInitializer): void;\n  registerPlugin(\n    type: string,\n    name: string | PluginInitializer,\n    init?: PluginInitializer\n  ) {\n    const pluginName = typeof init === 'undefined' ? type : `${type}.${name}`;\n    const pluginInit =\n      typeof init === 'undefined' ? <PluginInitializer>name : init;\n    const options = this._loadingPluginOptions;\n    const result = options ? pluginInit(duplicate(options)) : pluginInit();\n    if (isPromiseLike(result)) {\n      // If the result is thenable, push it on the loading queue\n      this._loadingPlugins.push({\n        name: pluginName,\n        init: new Task<any>(\n          (resolve, reject) => result.then(value => resolve(value), reject),\n          () => {\n            isTask(result) && result.cancel();\n          }\n        )\n      });\n    } else {\n      // If the result is not thenable, immediately add it to the plugins\n      // list\n      this._assignPlugin(pluginName, result);\n    }\n  }\n\n  /**\n   * Register a reporter plugin\n   *\n   * This is a convenience method for registering reporter constructors. This\n   * method calls [[lib/executors/Executor.Executor.registerPlugin]] behind\n   * the scenes using the name `reporter.${name}`.\n   *\n   * @param name the reporter name\n   * @param Ctor a reporter class constructor\n   */\n  registerReporter(name: string, init: ReporterInitializer) {\n    this.registerPlugin('reporter', name, () => init);\n  }\n\n  /**\n   * Run tests.\n   *\n   * This method sets up the environment for test execution, runs the tests,\n   * and runs any finalization code afterwards.\n   */\n  run(): CancellablePromise<void> {\n    // Only allow the executor to be started once\n    if (!this._runTask) {\n      let runError: Error;\n\n      try {\n        this._runTask = this._resolveConfig();\n\n        if (this.config.showConfig) {\n          this._runTask = this._runTask\n            .then(() => {\n              // Emit the config as JSON deeply sorted by key\n              const sort = (value: any) => {\n                if (Array.isArray(value)) {\n                  value = value.map(sort).sort();\n                } else if (typeof value === 'object') {\n                  const newObj: { [key: string]: any } = {};\n                  Object.keys(value)\n                    .sort()\n                    .forEach(key => {\n                      newObj[key] = sort(value[key]);\n                    });\n                  value = newObj;\n                }\n                return value;\n              };\n              console.log(JSON.stringify(sort(this.config), null, '    '));\n            })\n            .catch(error => {\n              // Display resolution errors because reporters\n              // haven't been installed yet\n              console.error(this.formatError(error));\n              throw error;\n            });\n        } else {\n          let currentTask: CancellablePromise<void>;\n\n          this._runTask = this._runTask\n            .then(() => this._loadPlugins())\n            .then(() => this._loadLoader())\n            .then(() => this._loadPluginsWithLoader())\n            .then(() => this._initReporters())\n            .then(() => this._loadSuites())\n            .then(() => this._beforeRun())\n            .then((skipTests: boolean) => {\n              if (skipTests) {\n                return;\n              }\n\n              // Keep track of distinct tasks to allow them to be\n              // cancelled\n              let outerTask: CancellablePromise<void>;\n              let testingTask: CancellablePromise<void>;\n\n              currentTask = new Task<void>(\n                (resolve, reject) => {\n                  outerTask = this.emit('beforeRun')\n                    .then(() => {\n                      return this.emit('runStart')\n                        .then(() => (testingTask = this._runTests()))\n                        .catch(error => {\n                          runError = error;\n                          return this.emit('error', error);\n                        })\n                        .finally(() => this.emit('runEnd'));\n                    })\n                    .finally(() => this.emit('afterRun'))\n                    .then(resolve, reject);\n                },\n                () => {\n                  if (testingTask) {\n                    testingTask.cancel();\n                  }\n                  if (outerTask) {\n                    outerTask.cancel();\n                  }\n                }\n              );\n              return currentTask;\n            })\n            .finally(() => {\n              // Ensure any queued events have been emitted.\n              this._reportersInitialized = true;\n              return this._drainEventQueue();\n            })\n            .finally(() => this._afterRun())\n            .finally(() => {\n              if (currentTask) {\n                currentTask.cancel();\n              }\n            })\n            .catch(error => {\n              return this.emit('error', error).finally(() => {\n                // A runError has priority over any cleanup\n                // errors, so rethrow one if it exists.\n                throw runError || error;\n              });\n            })\n            .then(() => {\n              // If we didn't have any cleanup errors but a\n              // runError was caught, throw it to reject the run\n              // task\n              if (runError) {\n                throw runError;\n              }\n\n              let message = '';\n\n              // If there were no run errors but any suites had\n              // errors, throw an error to reject the run task.\n              if (this._hasSuiteErrors) {\n                message = 'One or more suite errors occurred during testing';\n              } else if (this._hasTestErrors) {\n                // If there were no run errors but any tests\n                // failed, throw an error to reject the run\n                // task.\n                message = 'One or more tests failed';\n              } else if (this._hasEmittedErrors) {\n                // If there were no test or suite errors, but\n                // *some* error was emitted, throw an error to\n                // reject the run task.\n                message = 'An error was emitted';\n              }\n\n              if (message) {\n                const error: InternError = new Error(message);\n                // Mark this error as reported so that the\n                // runner script won't report it again.\n                error.reported = true;\n                throw error;\n              }\n            });\n        }\n      } catch (error) {\n        this._runTask = this.emit('error', error).then(() => {\n          return Task.reject<void>(error);\n        });\n      }\n    }\n\n    return this._runTask;\n  }\n\n  /**\n   * Code to execute after the main test run has finished to shut down the test\n   * system.\n   */\n  protected _afterRun(): CancellablePromise<void> {\n    return Task.resolve();\n  }\n\n  /**\n   * Add a resolved plugin to the internal plugins list\n   */\n  protected _assignPlugin(name: string, plugin: any) {\n    if (name.indexOf('reporter.') === 0 && typeof plugin !== 'function') {\n      throw new Error('A reporter plugin must be a constructor');\n    }\n    this._plugins[name] = plugin;\n  }\n\n  /**\n   * Code to execute before the main test run has started to set up the test\n   * system. This is where Executors can do any last-minute configuration\n   * before the testing process begins.\n   *\n   * This method returns a CancellablePromise that resolves to a boolean. A\n   * value of true indicates that Intern should skip running tests and exit\n   * normally.\n   */\n  protected _beforeRun(): CancellablePromise<boolean> {\n    const { bail, grep, name, sessionId, defaultTimeout } = this.config;\n    this._rootSuite.bail = bail;\n    this._rootSuite.grep = grep;\n    this._rootSuite.name = name;\n    this._rootSuite.sessionId = sessionId;\n    this._rootSuite.timeout = defaultTimeout;\n    return Task.resolve(false);\n  }\n\n  /**\n   * Instantiate any configured built-in reporters\n   */\n  protected _initReporters() {\n    const config = this.config;\n    const envReporters = config[this.environment].reporters;\n\n    // Take reporters from the base config that aren't also specified in an\n    // environment config\n    const baseReporters = config.reporters.filter(reporter => {\n      return !envReporters.some(\n        envReporter => envReporter.name === reporter.name\n      );\n    });\n\n    for (const reporter of [...baseReporters, ...envReporters]) {\n      const initializer = this.getPlugin('reporter', reporter.name);\n      if (!initializer) {\n        throw new Error(\n          `A reporter named ${reporter.name} hasn't been registered`\n        );\n      }\n      if (typeof initializer !== 'function') {\n        throw new Error(\n          `The reporter ${reporter.name} isn't a valid initializer`\n        );\n      }\n      this._reporters.push(initializer(reporter.options));\n    }\n\n    this._reportersInitialized = true;\n\n    return this._drainEventQueue();\n  }\n\n  /**\n   * Emit any queued events. The event queue will be empty after this method\n   * runs.\n   */\n  protected _drainEventQueue(): CancellablePromise<void> {\n    let task = Task.resolve();\n    while (this._events.length > 0) {\n      const event = this._events.shift()!;\n      task = task.then(() => {\n        return this.emit(event.eventName, event.data);\n      });\n    }\n    return task;\n  }\n\n  protected _emitCoverage(source?: string) {\n    const coverage = global[this.config.coverageVariable];\n    if (coverage) {\n      return this.emit('coverage', {\n        coverage,\n        source,\n        sessionId: this.config.sessionId\n      });\n    }\n  }\n\n  /**\n   * Load a loader\n   */\n  protected _loadLoader() {\n    // If registerLoader was already called, just wait for that loader to\n    // initialize\n    if (this._loaderInit) {\n      return this._loaderInit.then(loader => {\n        this._loader = loader;\n      });\n    } else {\n      // No loader has been registered, so load the configured or default\n      // one\n      const config = this.config;\n      const loader: { [key: string]: any } =\n        config[this.environment].loader || config.loader;\n\n      let script = loader.script;\n      switch (script) {\n        case 'default':\n        case 'dojo':\n        case 'dojo2':\n        case 'esm':\n        case 'systemjs':\n          script = `${config.internPath}loaders/${script}.js`;\n      }\n\n      this._loaderOptions = loader.options || {};\n      return this.loadScript(script)\n        .then(() => {\n          if (!this._loaderInit) {\n            throw new Error(\n              `Loader script ${script} did not register a loader callback`\n            );\n          }\n          return this._loaderInit;\n        })\n        .then(loader => {\n          this._loader = loader;\n        });\n    }\n  }\n\n  /**\n   * Load scripts in the `requires` list using an external loader, if\n   * configured, or the platform's native loading mechanism\n   */\n  protected _loadPluginsWithLoader() {\n    const scripts = [\n      ...this.config.plugins,\n      ...this.config[this.environment].plugins\n    ].filter(plugin => plugin.useLoader);\n    return this._loadScripts(scripts, script => this._loader([script]));\n  }\n\n  /**\n   * Load scripts in the `plugins` list using the platform's native loading\n   * mechanism\n   */\n  protected _loadPlugins() {\n    const scripts = [\n      ...this.config.plugins,\n      ...this.config[this.environment].plugins\n    ].filter(plugin => !plugin.useLoader);\n    return this._loadScripts(scripts, script => this.loadScript(script));\n  }\n\n  /**\n   * Load a list of scripts using a given loader. These will be loaded\n   * sequentially in order.\n   */\n  protected _loadScripts(\n    scripts: PluginDescriptor[],\n    loader: (script: string) => Promise<void>\n  ): CancellablePromise<void> {\n    return scripts\n      .reduce((previous, script) => {\n        if (typeof script === 'string') {\n          return previous.then(() => loader(script));\n        } else {\n          return previous\n            .then(() => {\n              this._loadingPluginOptions = script.options;\n            })\n            .then(() => loader(script.script))\n            .then(() => {\n              this._loadingPluginOptions = undefined;\n            });\n        }\n      }, Task.resolve())\n      .then(() => {\n        // Wait for all plugin registrations, both configured ones and\n        // any that were manually registered, to resolve\n        return Task.all(this._loadingPlugins.map(entry => entry.init)).then(\n          plugins => {\n            plugins.forEach((plugin, index) => {\n              this._assignPlugin(this._loadingPlugins[index].name, plugin);\n            });\n          }\n        );\n      });\n  }\n\n  /**\n   * Load suites\n   */\n  protected _loadSuites(): CancellablePromise<void> {\n    // _resolveSuites will expand all suites into <env>.suites for the\n    // current env\n    const suites = this.config[this.environment].suites;\n    return Task.resolve(this._loader(suites!)).then(() => {\n      this.log('Loaded suites:', suites);\n    });\n  }\n\n  /**\n   * Process an option\n   */\n  protected _processOption(key: keyof C, value: any) {\n    processOption(key, value, this.config, this);\n  }\n\n  /**\n   * Resolve the config object.\n   */\n  protected _resolveConfig(): CancellablePromise<void> {\n    const config = this.config;\n\n    if (config.internPath != null) {\n      config.internPath = normalizePathEnding(config.internPath);\n    } else {\n      config.internPath = '';\n    }\n\n    if (config.benchmark) {\n      config.benchmarkConfig = deepMixin(\n        <BenchmarkConfig>{\n          mode: config.baseline ? 'baseline' : 'test',\n          id: 'Benchmark',\n          filename: 'baseline.json',\n          thresholds: {\n            warn: { rme: 3, mean: 5 },\n            fail: { rme: 6, mean: 10 }\n          },\n          verbosity: 0\n        },\n        config.benchmarkConfig || {}\n      );\n    }\n\n    return Task.resolve();\n  }\n\n  /**\n   * Runs each of the root suites, limited to a certain number of suites at\n   * the same time by `maxConcurrency`.\n   */\n  protected _runTests(): CancellablePromise<void> {\n    return this._rootSuite.run();\n  }\n}\n\nexport { BenchmarkConfig, Config, PluginDescriptor, ReporterDescriptor };\n\nexport interface InternEvent<E extends Events> {\n  eventName: keyof E;\n  data?: any;\n}\n\nexport { Handle };\n\n/**\n * A generic event listener\n */\nexport interface Listener<T> {\n  (arg: T): void | Promise<any>;\n}\n\n/**\n * The data accompanying a coverage event\n */\nexport interface CoverageMessage {\n  sessionId?: string;\n  source?: string;\n  coverage: any;\n}\n\nexport interface DeprecationMessage {\n  original: string;\n  replacement?: string;\n  message?: string;\n}\n\nexport interface ExecutorEvent {\n  name: keyof Events;\n  data: any;\n}\n\n/**\n * Events that may be emitted by an Executor. Each event has at most one\n * associated message type. A few (e.g., afterRun) don't have messages.\n */\nexport interface Events {\n  /** A listener can listen for this event to be notified of all events */\n  '*': ExecutorEvent;\n\n  /**\n   * Emitted after the local executor has finished running suites. This is\n   * functionally the same as runEnd.\n   */\n  afterRun: void;\n\n  /** Emitted before the local executor loads suites */\n  beforeRun: void;\n\n  /** Coverage info has been gathered */\n  coverage: CoverageMessage;\n\n  /** A deprecated method was called */\n  deprecated: DeprecationMessage;\n\n  /** An unhandled error occurs */\n  error: Error;\n\n  /** A debug log event */\n  log: string;\n\n  /**\n   * All tests have finished running. This is functionally the same as\n   * afterRun.\n   */\n  runEnd: void;\n\n  /** Emitted just before tests start running  */\n  runStart: void;\n\n  /** A new suite has been added */\n  suiteAdd: Suite;\n\n  /** A suite has fininshed running */\n  suiteEnd: Suite;\n\n  /** A suite has started running */\n  suiteStart: Suite;\n\n  /** A new test has been added */\n  testAdd: Test;\n\n  /** A test has finished */\n  testEnd: Test;\n\n  /** A test has started */\n  testStart: Test;\n\n  /** A non-fatal error occurred */\n  warning: string;\n}\n\n/** A list of event names that don't have associated data */\nexport type NoDataEvents = 'runStart' | 'runEnd' | 'beforeRun' | 'afterRun';\n\n/**\n * Known plugin types\n */\nexport interface Plugins {\n  reporter: ReporterInitializer;\n}\n\n/**\n * An async loader callback.\n */\nexport interface Loader {\n  (modules: string[]): Promise<void>;\n}\n\n/**\n * A loader initialization function.\n */\nexport interface LoaderInit {\n  (options: { [key: string]: any }): Promise<Loader> | Loader;\n}\n\nexport interface PluginInitializer<T extends any = any> {\n  (options?: { [key: string]: any }): CancellablePromise<T> | T;\n}\n\nexport interface ReporterInitializer {\n  (options?: any): Reporter;\n}\n\n/**\n * A 'reporter' as far as Executor is concerned. There is currently no\n * pre-defined functionality required for reporters.\n */\nexport interface Reporter {}\n"]}