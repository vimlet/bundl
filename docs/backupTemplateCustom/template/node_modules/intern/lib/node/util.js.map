{"version":3,"file":"util.js","sourceRoot":"","sources":["../../../../src/lib/node/util.ts"],"names":[],"mappings":";;;;;;;;;;;IAAA,yBAA4C;IAC5C,6BAA0E;IAC1E,2CAAoC;IAEpC,6BAA8C;IAE9C,4CAA6D;IAE7D,qCAAgC;IAChC,uCAKwB;IAOxB,SAAgB,WAAW,CAAC,QAA4B;QACtD,IAAI,CAAC,QAAQ,EAAE;YACb,QAAQ,GAAG,EAAE,CAAC;SACf;aAAM,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,QAAQ,CAAC,EAAE;YACnC,QAAQ,GAAG,CAAC,QAAQ,CAAC,CAAC;SACvB;QAED,IAAM,QAAQ,GAAa,EAAE,CAAC;QAC9B,IAAM,QAAQ,GAAa,EAAE,CAAC;QAC9B,IAAM,KAAK,GAAa,EAAE,CAAC;QAE3B,KAAoB,UAAQ,EAAR,qBAAQ,EAAR,sBAAQ,EAAR,IAAQ,EAAE;YAAzB,IAAI,OAAO,iBAAA;YACd,IAAI,OAAO,CAAC,CAAC,CAAC,KAAK,GAAG,EAAE;gBACtB,QAAQ,CAAC,IAAI,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC;aACjC;iBAAM;gBACL,IAAI,eAAQ,CAAC,OAAO,CAAC,EAAE;oBACrB,QAAQ,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;iBACxB;qBAAM;oBACL,KAAK,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;iBACrB;aACF;SACF;QAED,IAAM,QAAQ,GAAG,QAAQ;aACtB,GAAG,CAAC,UAAA,OAAO,IAAI,OAAA,WAAI,CAAC,OAAO,EAAE,EAAE,MAAM,EAAE,QAAQ,EAAE,CAAC,EAAnC,CAAmC,CAAC;aACnD,MAAM,CAAC,UAAC,QAAQ,EAAE,KAAK,IAAK,OAAA,QAAQ,CAAC,MAAM,CAAC,KAAK,CAAC,EAAtB,CAAsB,EAAE,KAAK,CAAC,CAAC;QAC9D,IAAM,WAAW,GAAgC,EAAE,CAAC;QACpD,QAAQ,CAAC,OAAO,CAAC,UAAA,IAAI,IAAI,OAAA,CAAC,WAAW,CAAC,IAAI,CAAC,GAAG,IAAI,CAAC,EAA1B,CAA0B,CAAC,CAAC;QAErD,OAAO,MAAM,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC;IAClC,CAAC;IA9BD,kCA8BC;IAoBD,SAAgB,SAAS,CACvB,UAA8B,EAC9B,IAAe;QAEf,IAAI,IAAI,GAA2B,EAAE,CAAC;QACtC,IAAI,IAAI,GAAG,OAAO,UAAU,KAAK,QAAQ,CAAC,CAAC,CAAC,UAAU,CAAC,CAAC,CAAC,SAAS,CAAC;QACnE,IAAI,GAAG,KAAK,CAAC,OAAO,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC,UAAU,CAAC,CAAC,CAAC,IAAI,CAAC;QACrD,IAAM,QAAQ,GAAG,CAAC,IAAI,IAAI,iBAAO,CAAC,IAAI,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;QAEjD,IAAI,iBAAO,CAAC,GAAG,CAAC,aAAa,CAAC,EAAE;YAC9B,MAAM,CAAC,MAAM,CAAC,IAAI,EAAE,gBAAS,CAAC,mBAAK,CAAC,iBAAO,CAAC,GAAG,CAAC,aAAa,CAAC,IAAI,EAAE,CAAC,CAAC,CAAC,CAAC;SACzE;QAED,IAAI,QAAQ,CAAC,MAAM,GAAG,CAAC,EAAE;YACvB,MAAM,CAAC,MAAM,CAAC,IAAI,EAAE,gBAAS,CAAC,QAAQ,CAAC,CAAC,CAAC;SAC1C;QAED,IAAI,IAAI,EAAE;YACR,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC;SACpB;QAED,IAAI,IAAgD,CAAC;QAErD,IAAI,IAAI,CAAC,MAAM,EAAE;YAGT,IAAA,oDAA+D,EAA7D,0BAAU,EAAE,4BAAiD,CAAC;YACtE,IAAI,GAAG,cAAO,CAAC,UAAU,IAAI,aAAa,CAAC,CAAC;YAC5C,IAAI,GAAG,iBAAU,CAAC,IAAI,EAAE,QAAQ,EAAE,IAAI,EAAE,WAAW,CAAC,CAAC;SACtD;aAAM;YAGL,IAAI,GAAG,cAAO,CAAC,aAAa,CAAC,CAAC;YAC9B,IAAI,GAAG,iBAAU,CAAC,IAAI,EAAE,QAAQ,EAAE,IAAI,EAAE,SAAS,CAAC,CAAC,KAAK,CACtD,UAAC,KAA4B;gBAC3B,IAAI,KAAK,CAAC,IAAI,KAAK,QAAQ,EAAE;oBAC3B,IAAI,GAAG,SAAS,CAAC;oBACjB,OAAO,IAAI,CAAC;iBACb;gBACD,MAAM,KAAK,CAAC;YACd,CAAC,CACF,CAAC;SACH;QAED,OAAO,IAAI;aACR,IAAI,CAAC,UAAA,MAAM;YAGV,IAAI,IAAI,EAAE;gBACR,MAAM,CAAC,QAAQ,GAAG,kBAAW,CAAC,IAAI,EAAE,MAAM,CAAC,QAAQ,EAAE,iBAAU,EAAE,UAAG,CAAC,CAAC;aACvE;YACD,OAAO,MAAM,CAAC;QAChB,CAAC,CAAC;aACD,IAAI,CAAC,UAAA,MAAM,IAAI,OAAA,CAAC,EAAE,MAAM,QAAA,EAAE,IAAI,MAAA,EAAE,CAAC,EAAlB,CAAkB,CAAC,CAAC;IACxC,CAAC;IAtDD,8BAsDC;IAKD,SAAgB,QAAQ,CAAC,IAAY;QACnC,OAAO,IAAI,aAAI,CAAS,UAAC,OAAO,EAAE,MAAM;YACtC,aAAQ,CAAC,IAAI,EAAE,EAAE,QAAQ,EAAE,MAAM,EAAE,EAAE,UAAC,KAAK,EAAE,IAAI;gBAC/C,IAAI,KAAK,EAAE;oBACT,MAAM,CAAC,KAAK,CAAC,CAAC;iBACf;qBAAM;oBACL,OAAO,CAAC,IAAI,CAAC,CAAC;iBACf;YACH,CAAC,CAAC,CAAC;QACL,CAAC,CAAC,CAAC;IACL,CAAC;IAVD,4BAUC;IAMD,SAAgB,aAAa,CAAC,IAAY;QACxC,OAAO,gBAAS,CAAC,IAAI,CAAC,CAAC,OAAO,CAAC,KAAK,EAAE,GAAG,CAAC,CAAC;IAC7C,CAAC;IAFD,sCAEC;IAMD,SAAgB,aAAa,CAC3B,UAAkB,EAClB,IAAa;QAEb,IAAI,CAAC,IAAI,EAAE;YACT,IAAI,GAAG,iBAAY,CAAC,UAAU,EAAE,EAAE,QAAQ,EAAE,MAAM,EAAE,CAAC,CAAC;SACvD;QAED,IAAI,KAA8B,CAAC;QAInC,IAAM,WAAW,GAAG,IAAI,CAAC,WAAW,CAAC,IAAI,EAAE,IAAI,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;QAC5D,IAAM,QAAQ,GAAG,IAAI,CAAC,KAAK,CAAC,WAAW,GAAG,CAAC,CAAC,CAAC;QAE7C,IAAI,CAAC,KAAK,GAAG,cAAc,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,EAAE;YAC3C,IAAI,KAAK,CAAC,CAAC,CAAC,EAAE;gBACZ,OAAO,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,EAAE,QAAQ,CAAC,CAAC,QAAQ,CAAC,MAAM,CAAC,CAAC,CAAC;aACrE;iBAAM;gBAEL,IAAM,OAAO,GAAG,WAAI,CAAC,cAAO,CAAC,UAAU,CAAC,EAAE,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC;gBACpD,OAAO,IAAI,CAAC,KAAK,CAAC,iBAAY,CAAC,OAAO,EAAE,EAAE,QAAQ,EAAE,MAAM,EAAE,CAAC,CAAC,CAAC;aAChE;SACF;IACH,CAAC;IAxBD,sCAwBC;IAKD,SAAgB,gBAAgB,CAAC,KAAU;QACzC,OAAO,KAAK,CAAC,KAAK,KAAK,IAAI,CAAC;IAC9B,CAAC;IAFD,4CAEC;IAGD,IAAM,cAAc,GAAG,mFAAmF,CAAC","sourcesContent":["import { readFile, readFileSync } from 'fs';\nimport { dirname, isAbsolute, join, normalize, resolve, sep } from 'path';\nimport { parse } from 'shell-quote';\nimport { RawSourceMap } from 'source-map';\nimport { sync as glob, hasMagic } from 'glob';\n\nimport { Task, CancellablePromise } from '@theintern/common';\n\nimport process from './process';\nimport {\n  getBasePath,\n  loadConfig,\n  parseArgs,\n  splitConfigPath\n} from '../common/util';\n\n/**\n * Expand a list of glob patterns into a flat file list. Patterns may be simple\n * file paths or glob patterns. Patterns starting with '!' denote exclusions.\n * Note that exclusion rules will not apply to simple paths.\n */\nexport function expandFiles(patterns?: string[] | string) {\n  if (!patterns) {\n    patterns = [];\n  } else if (!Array.isArray(patterns)) {\n    patterns = [patterns];\n  }\n\n  const excludes: string[] = [];\n  const includes: string[] = [];\n  const paths: string[] = [];\n\n  for (let pattern of patterns) {\n    if (pattern[0] === '!') {\n      excludes.push(pattern.slice(1));\n    } else {\n      if (hasMagic(pattern)) {\n        includes.push(pattern);\n      } else {\n        paths.push(pattern);\n      }\n    }\n  }\n\n  const allPaths = includes\n    .map(pattern => glob(pattern, { ignore: excludes }))\n    .reduce((allFiles, files) => allFiles.concat(files), paths);\n  const uniquePaths: { [name: string]: boolean } = {};\n  allPaths.forEach(path => (uniquePaths[path] = true));\n\n  return Object.keys(uniquePaths);\n}\n\n/**\n * Get the user-supplied config data, which may include command line args and a\n * config file.\n *\n * @param file A config file\n * @param argv An array of command line arguments. This should follow the same\n * format as process.argv (where user args start at index 2).\n */\nexport function getConfig(\n  file?: string\n): CancellablePromise<{ config: any; file?: string }>;\nexport function getConfig(\n  argv?: string[]\n): CancellablePromise<{ config: any; file?: string }>;\nexport function getConfig(\n  file: string,\n  argv?: string[]\n): CancellablePromise<{ config: any; file?: string }>;\nexport function getConfig(\n  fileOrArgv?: string | string[],\n  argv?: string[]\n): CancellablePromise<{ config: any; file?: string }> {\n  let args: { [key: string]: any } = {};\n  let file = typeof fileOrArgv === 'string' ? fileOrArgv : undefined;\n  argv = Array.isArray(fileOrArgv) ? fileOrArgv : argv;\n  const userArgs = (argv || process.argv).slice(2);\n\n  if (process.env['INTERN_ARGS']) {\n    Object.assign(args, parseArgs(parse(process.env['INTERN_ARGS'] || '')));\n  }\n\n  if (userArgs.length > 0) {\n    Object.assign(args, parseArgs(userArgs));\n  }\n\n  if (file) {\n    args.config = file;\n  }\n\n  let load: CancellablePromise<{ [key: string]: any }>;\n\n  if (args.config) {\n    // If a config parameter was provided, load it and mix in any other\n    // command line args.\n    const { configFile, childConfig } = splitConfigPath(args.config, sep);\n    file = resolve(configFile || 'intern.json');\n    load = loadConfig(file, loadText, args, childConfig);\n  } else {\n    // If no config parameter was provided, try 'intern.json', or just\n    // resolve to the original args\n    file = resolve('intern.json');\n    load = loadConfig(file, loadText, args, undefined).catch(\n      (error: NodeJS.ErrnoException) => {\n        if (error.code === 'ENOENT') {\n          file = undefined;\n          return args;\n        }\n        throw error;\n      }\n    );\n  }\n\n  return load\n    .then(config => {\n      // If a basePath wasn't set in the config or via a query arg, and we\n      // have a config file path, use that.\n      if (file) {\n        config.basePath = getBasePath(file, config.basePath, isAbsolute, sep);\n      }\n      return config;\n    })\n    .then(config => ({ config, file }));\n}\n\n/**\n * Loads a text resource.\n */\nexport function loadText(path: string): CancellablePromise<string> {\n  return new Task<string>((resolve, reject) => {\n    readFile(path, { encoding: 'utf8' }, (error, data) => {\n      if (error) {\n        reject(error);\n      } else {\n        resolve(data);\n      }\n    });\n  });\n}\n\n// TODO: Remove in the next version\n/**\n * Normalize a path (e.g., resolve '..')\n */\nexport function normalizePath(path: string) {\n  return normalize(path).replace(/\\\\/g, '/');\n}\n\n/**\n * Given a source filename, and optionally code, return the file's source map if\n * one exists.\n */\nexport function readSourceMap(\n  sourceFile: string,\n  code?: string\n): RawSourceMap | undefined {\n  if (!code) {\n    code = readFileSync(sourceFile, { encoding: 'utf8' });\n  }\n\n  let match: RegExpMatchArray | null;\n\n  // sourceMappingUrl must be on last line of source file; search for last\n  // newline from code.length - 2 in case the file ends with a newline\n  const lastNewline = code.lastIndexOf('\\n', code.length - 2);\n  const lastLine = code.slice(lastNewline + 1);\n\n  if ((match = sourceMapRegEx.exec(lastLine))) {\n    if (match[1]) {\n      return JSON.parse(Buffer.from(match[2], 'base64').toString('utf8'));\n    } else {\n      // Treat map file path as relative to the source file\n      const mapFile = join(dirname(sourceFile), match[2]);\n      return JSON.parse(readFileSync(mapFile, { encoding: 'utf8' }));\n    }\n  }\n}\n\n/**\n * Indicate whether a value is an ErrnoException\n */\nexport function isErrnoException(value: any): value is NodeJS.ErrnoException {\n  return value.errno !== null;\n}\n\n// Regex for matching sourceMappingUrl comments\nconst sourceMapRegEx = /^(?:\\/{2}[#@]{1,2}|\\/\\*)\\s+sourceMappingURL\\s*=\\s*(data:(?:[^;]+;)+base64,)?(\\S+)/;\n"]}