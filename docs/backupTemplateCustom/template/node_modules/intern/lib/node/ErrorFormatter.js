(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports", "tslib", "fs", "path", "source-map", "../common/ErrorFormatter", "./util"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require("tslib");
    var fs_1 = require("fs");
    var path_1 = require("path");
    var source_map_1 = require("source-map");
    var ErrorFormatter_1 = require("../common/ErrorFormatter");
    var util_1 = require("./util");
    var NodeErrorFormatter = (function (_super) {
        tslib_1.__extends(NodeErrorFormatter, _super);
        function NodeErrorFormatter(executor) {
            var _this = _super.call(this, executor) || this;
            _this.fileSourceMaps = {};
            _this.fileSources = {};
            return _this;
        }
        NodeErrorFormatter.prototype._getSource = function (tracepath) {
            if (tracepath === '<anonymous>') {
                return 'anonymous';
            }
            var sourcepath = this._getSourceHelper(tracepath);
            while (sourcepath !== tracepath) {
                tracepath = sourcepath;
                sourcepath = this._getSourceHelper(tracepath);
            }
            return tracepath;
        };
        NodeErrorFormatter.prototype._getSourceHelper = function (tracepath) {
            var match;
            var source;
            var line;
            var col;
            var map;
            var originalPos;
            var result;
            if (!(match = /^(.*?):(\d+)(:\d+)?$/.exec(tracepath))) {
                return tracepath;
            }
            tracepath = match[1];
            line = Number(match[2]);
            col = match[3] ? Number(match[3].substring(1)) : undefined;
            if (tracepath.indexOf(this.executor.config.serverUrl) === 0) {
                tracepath = tracepath.slice(this.executor.config.serverUrl.length);
                tracepath = tracepath.replace(/^__intern\//, this.executor.config.internPath);
            }
            tracepath = path_1.resolve(tracepath);
            var instrumentedStore = this.executor.instrumentedMapStore;
            if (tracepath in instrumentedStore.data) {
                map = new source_map_1.SourceMapConsumer(instrumentedStore.data[tracepath].data);
                originalPos = this.getOriginalPosition(map, line, col);
                line = originalPos.line;
                col = originalPos.column;
                if (originalPos.source) {
                    source = originalPos.source;
                }
            }
            source = source || tracepath;
            var sourceMapStore = this.executor.sourceMapStore;
            if (source in sourceMapStore.data) {
                map = new source_map_1.SourceMapConsumer(sourceMapStore.data[source].data);
            }
            else {
                map = this.getSourceMap(source);
            }
            source = path_1.relative('.', source);
            if (map) {
                originalPos = this.getOriginalPosition(map, line, col);
                line = originalPos.line;
                col = originalPos.column;
                if (originalPos.source) {
                    if (originalPos.source.indexOf('/') === -1 ||
                        /\.\.?\//.test(originalPos.source)) {
                        source = path_1.join(path_1.dirname(source), originalPos.source);
                    }
                    else {
                        source = originalPos.source;
                    }
                }
            }
            source = path_1.relative('.', source);
            result = source + ':' + line;
            if (col !== null) {
                result += ':' + col;
            }
            return result;
        };
        NodeErrorFormatter.prototype.getOriginalPosition = function (map, line, column) {
            var originalPosition = map.originalPositionFor({
                line: line,
                column: column
            });
            if (originalPosition.line != null) {
                return originalPosition;
            }
            var entries = [];
            map.eachMapping(function (entry) {
                if (entry.generatedLine === line) {
                    entries.push(entry);
                }
            }, null, source_map_1.SourceMapConsumer.GENERATED_ORDER);
            if (entries.length === 0) {
                return { line: line, column: column };
            }
            var position = entries[0];
            if (column != null) {
                var entry = void 0;
                for (var i = 1; i < entries.length; i++) {
                    entry = entries[i];
                    if (column > position.generatedColumn &&
                        column >= entry.generatedColumn) {
                        position = entry;
                    }
                }
            }
            return {
                line: position.originalLine,
                column: position.originalColumn,
                source: position.source
            };
        };
        NodeErrorFormatter.prototype.getSourceMap = function (filepath) {
            if (filepath in this.fileSourceMaps) {
                return this.fileSourceMaps[filepath];
            }
            try {
                var data = void 0;
                if (filepath in this.fileSources) {
                    data = this.fileSources[filepath];
                }
                else {
                    data = fs_1.readFileSync(filepath).toString('utf-8');
                    this.fileSources[filepath] = data;
                }
                var rawMap = util_1.readSourceMap(filepath, data);
                if (rawMap) {
                    this.fileSourceMaps[filepath] = new source_map_1.SourceMapConsumer(rawMap);
                    return this.fileSourceMaps[filepath];
                }
            }
            catch (error) {
            }
        };
        return NodeErrorFormatter;
    }(ErrorFormatter_1.default));
    exports.default = NodeErrorFormatter;
});
//# sourceMappingURL=ErrorFormatter.js.map