{"version":3,"file":"util.js","sourceRoot":"","sources":["../../../../src/lib/browser/util.ts"],"names":[],"mappings":"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","sourcesContent":["import { request, CancellablePromise, global } from '@theintern/common';\n\nimport {\n  getBasePath,\n  loadConfig,\n  parseArgs,\n  splitConfigPath\n} from '../common/util';\n\n/**\n * Resolve the user-supplied config data, which may include query args and a\n * config file.\n */\nexport function getConfig(file?: string) {\n  const args = parseArgs(parseQuery());\n  const configBase = getDefaultBasePath();\n  if (file) {\n    args.config = file;\n  }\n\n  let load: CancellablePromise<{ [key: string]: any }>;\n\n  if (args.config) {\n    // If a config parameter was provided, load it, mix in any other query\n    // params, then initialize the executor with that\n    const { configFile, childConfig } = splitConfigPath(args.config);\n    file = resolvePath(configFile || 'intern.json', configBase);\n    load = loadConfig(file, loadText, args, childConfig);\n  } else {\n    // If no config parameter was provided, try 'intern.json'. If that file\n    // doesn't exist, just return the args\n    file = resolvePath('intern.json', configBase);\n    load = loadConfig(file, loadText, args).catch(error => {\n      if (error.message.indexOf('Request failed') === 0) {\n        // The file wasn't found, clear the file name\n        file = undefined;\n        return args;\n      }\n      throw error;\n    });\n  }\n\n  return load\n    .then(config => {\n      // If a basePath wasn't set in the config or via a query arg, and we\n      // have a config file path, use that.\n      if (file) {\n        config.basePath = getBasePath(\n          file,\n          config.basePath,\n          path => path[0] === '/',\n          '/'\n        );\n      }\n      return config;\n    })\n    .then(config => ({ config, file }));\n}\n\n/**\n * Return a base path based on the current location pathname\n */\nexport function getDefaultBasePath() {\n  const match = /^(.*\\/)node_modules\\/intern\\/?/.exec(global.location.pathname);\n  if (match) {\n    // If the current location contains `node_modules/intern`,\n    // assume the base path is the parent of\n    // `node_modules/intern`\n    return match[1];\n  } else {\n    return '/';\n  }\n}\n\n// TODO: Remove in the next version\n/**\n * Normalize a path (e.g., resolve '..')\n */\nexport function normalizePath(path: string) {\n  const parts = path.replace(/\\\\/g, '/').split('/');\n  let result: string[] = [];\n  for (let i = 0; i < parts.length; ++i) {\n    let part = parts[i];\n\n    if (!part || part === '.') {\n      if (i === 0 || i === parts.length - 1) {\n        result.push('');\n      }\n\n      continue;\n    }\n\n    if (part === '..') {\n      if (result.length && result[result.length - 1] !== '..') {\n        result.pop();\n      } else {\n        result.push(part);\n      }\n    } else {\n      result.push(part);\n    }\n  }\n\n  return result.join('/');\n}\n\n/**\n * Parse a query string and return a set of decoded name=value pairs\n */\nexport function parseQuery(query?: string) {\n  query = query || global.location.search;\n\n  const parsed: string[] = [];\n  const params = new URLSearchParams(query);\n  params.forEach((value, key) => {\n    parsed.push(value ? `${key}=${value}` : key);\n  });\n\n  return parsed;\n}\n\n/**\n * Parse a URL\n */\nexport type Url = {\n  protocol: string;\n  hostname: string;\n  port: string;\n  path: string;\n  query: string;\n  hash: string;\n};\nexport function parseUrl(url: string): Url | undefined {\n  if (url) {\n    const match = /^(([^:\\/?#]+):)?(\\/\\/(([^:\\/?#]*)(:(\\d+))?))?([^?#]*)(\\?([^#]*))?(#(.*))?/.exec(\n      url\n    );\n    if (match) {\n      return {\n        protocol: match[2],\n        hostname: match[5],\n        port: match[7],\n        path: match[8],\n        query: match[10],\n        hash: match[12]\n      };\n    }\n  }\n}\n\n/**\n * Load a text resource\n */\nfunction loadText(path: string): CancellablePromise<any> {\n  return request(path).then(response => {\n    if (!response.ok) {\n      throw new Error('Request failed: ' + response.status);\n    }\n    return response.text();\n  });\n}\n\n/**\n * Resolve a path against a base path\n */\nfunction resolvePath(path: string, basePath: string) {\n  if (path[0] === '/') {\n    return path;\n  }\n\n  const pathParts = path.split('/');\n  const basePathParts = basePath.split('/');\n\n  if (basePathParts[basePathParts.length - 1] === '') {\n    basePathParts.pop();\n  }\n\n  for (const part of pathParts) {\n    if (part === '..') {\n      basePathParts.pop();\n    } else if (part !== '.') {\n      basePathParts.push(part);\n    }\n  }\n\n  return basePathParts.join('/');\n}\n"]}