{"version":3,"file":"benchmark.js","sourceRoot":"","sources":["../../../../src/lib/interfaces/benchmark.ts"],"names":[],"mappings":";;;;;;;;;;;IAGA,4CAA2C;IAG3C,mCAAiE;IACjE,kDAG0B;IAC1B,oDAA6E;IAK7E,SAAwB,aAAa,CACnC,IAAY,EACZ,mBAGkB;QAElB,OAAO,cAAc,CAAC,eAAM,CAAC,MAAM,EAAE,IAAI,EAAE,mBAAmB,CAAC,CAAC;IAClE,CAAC;IARD,gCAQC;IAKD,SAAgB,YAAY,CAAC,QAAkB;QAC7C,OAAO;YACL,aAAa,YACX,IAAY,EACZ,mBAGkB;gBAElB,OAAO,cAAc,CAAC,QAAQ,EAAE,IAAI,EAAE,mBAAmB,CAAC,CAAC;YAC7D,CAAC;YAED,KAAK,EAAE,uBAAa,CAAC,KAAK;SAC3B,CAAC;IACJ,CAAC;IAdD,oCAcC;IAiCD,SAAS,cAAc,CACrB,QAAkB,EAClB,IAAY,EACZ,mBAGkB;QAGlB,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC,SAAS,EAAE;YAC9B,QAAQ,CAAC,GAAG,CACV,kCAAkC;gBAChC,IAAI;gBACJ,mCAAmC,CACtC,CAAC;YACF,OAAO;SACR;QAED,QAAQ,CAAC,QAAQ,CAAC,UAAA,MAAM;YAKtB,IAAI,UAAqD,CAAC;YAE1D,IAAI,iCAAwB,CAAwB,mBAAmB,CAAC,EAAE;gBACxE,UAAU,GAAG,mBAAmB,EAAE,CAAC;aACpC;iBAAM;gBACL,UAAU,GAAG,mBAAmB,CAAC;aAClC;YAED,MAAM,CAAC,GAAG,CACR,oBAAW,CAAC,IAAI,EAAE,MAAM,EAAE,UAAU,EAAE,wBAAc,EAAE,uBAAa,CAAC,CACrE,CAAC;QACJ,CAAC,CAAC,CAAC;IACL,CAAC","sourcesContent":["/**\n * Interface for registering benchmark suites\n */ /** */\nimport { global } from '@theintern/common';\n\nimport { Executor } from '../executors/Executor';\nimport { createSuite, isSuiteDescriptorFactory } from './object';\nimport BenchmarkTest, {\n  BenchmarkDeferredTestFunction,\n  BenchmarkTestFunction\n} from '../BenchmarkTest';\nimport BenchmarkSuite, { BenchmarkSuiteProperties } from '../BenchmarkSuite';\n\n/**\n * Importable interface that uses the currently installed global executor\n */\nexport default function registerSuite(\n  name: string,\n  descriptorOrFactory:\n    | BenchmarkSuiteDescriptor\n    | BenchmarkSuiteFactory\n    | BenchmarkTests\n) {\n  return _registerSuite(global.intern, name, descriptorOrFactory);\n}\n\n/**\n * Interface factory used by Executor\n */\nexport function getInterface(executor: Executor) {\n  return {\n    registerSuite(\n      name: string,\n      descriptorOrFactory:\n        | BenchmarkSuiteDescriptor\n        | BenchmarkSuiteFactory\n        | BenchmarkTests\n    ) {\n      return _registerSuite(executor, name, descriptorOrFactory);\n    },\n\n    async: BenchmarkTest.async\n  };\n}\n\nexport interface BenchmarkInterface {\n  registerSuite(\n    name: string,\n    descriptor:\n      | BenchmarkSuiteDescriptor\n      | BenchmarkSuiteFactory\n      | BenchmarkTests\n  ): void;\n\n  async: (\n    testFunction: BenchmarkDeferredTestFunction,\n    numCallsUntilResolution?: number\n  ) => BenchmarkTestFunction;\n}\n\nexport interface BenchmarkTests {\n  [name: string]:\n    | BenchmarkSuiteDescriptor\n    | BenchmarkTestFunction\n    | BenchmarkTests;\n}\n\nexport interface BenchmarkSuiteDescriptor\n  extends Partial<BenchmarkSuiteProperties> {\n  tests: BenchmarkTests;\n}\n\nexport interface BenchmarkSuiteFactory {\n  (): BenchmarkSuiteDescriptor | BenchmarkTests;\n}\n\nfunction _registerSuite(\n  executor: Executor,\n  name: string,\n  descriptorOrFactory:\n    | BenchmarkSuiteDescriptor\n    | BenchmarkSuiteFactory\n    | BenchmarkTests\n) {\n  // Only register benchmark suites if we're in benchmark mode\n  if (!executor.config.benchmark) {\n    executor.log(\n      'Not registering benchmark suite ' +\n        name +\n        ' because benchmarking is disabled'\n    );\n    return;\n  }\n\n  executor.addSuite(parent => {\n    // Enable per-suite closure, to match feature parity with other\n    // interfaces like tdd/bdd more closely; without this, it becomes\n    // impossible to use the object interface for functional tests since\n    // there is no other way to create a closure for each main suite\n    let descriptor: BenchmarkSuiteDescriptor | BenchmarkTests;\n\n    if (isSuiteDescriptorFactory<BenchmarkSuiteFactory>(descriptorOrFactory)) {\n      descriptor = descriptorOrFactory();\n    } else {\n      descriptor = descriptorOrFactory;\n    }\n\n    parent.add(\n      createSuite(name, parent, descriptor, BenchmarkSuite, BenchmarkTest)\n    );\n  });\n}\n"]}