{"version":3,"file":"path.js","sourceRoot":"","sources":["../../../../src/lib/common/path.ts"],"names":[],"mappings":";;;;;;;;;;;IAGA,SAAgB,OAAO,CAAC,IAAY;QAClC,IAAM,GAAG,GAAG,UAAU,CAAC,IAAI,CAAC,CAAC;QAC7B,IAAM,KAAK,GAAG,SAAS,CAAC,IAAI,CAAC,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;QACzC,KAAK,CAAC,GAAG,EAAE,CAAC;QACZ,IAAI,KAAK,CAAC,MAAM,KAAK,CAAC,IAAI,KAAK,CAAC,CAAC,CAAC,KAAK,EAAE,EAAE;YACzC,OAAO,GAAG,CAAC;SACZ;QACD,OAAO,KAAK,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;IACzB,CAAC;IARD,0BAQC;IAKD,SAAgB,UAAU;QAAC,eAAkB;aAAlB,UAAkB,EAAlB,qBAAkB,EAAlB,IAAkB;YAAlB,0BAAkB;;QAC3C,OAAO,KAAK,CAAC,IAAI,CAAC,UAAA,IAAI,IAAI,OAAA,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,EAAf,CAAe,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,GAAG,CAAC;IAC1D,CAAC;IAFD,gCAEC;IAMD,SAAgB,IAAI;QAAC,eAAkB;aAAlB,UAAkB,EAAlB,qBAAkB,EAAlB,IAAkB;YAAlB,0BAAkB;;QACrC,IAAM,GAAG,GAAG,UAAU,eAAI,KAAK,CAAC,CAAC;QACjC,IAAM,WAAW,GAAG,KAAK,CAAC,GAAG,CAAC,SAAS,CAAC,CAAC;QACzC,IAAM,aAAa,GAAG,WAAW,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;QAEhD,IACE,aAAa,CAAC,MAAM,GAAG,CAAC;YACxB,aAAa,CAAC,aAAa,CAAC,MAAM,GAAG,CAAC,CAAC,KAAK,EAAE,EAC9C;YACA,aAAa,CAAC,GAAG,EAAE,CAAC;SACrB;QAED,KAAmB,UAAoB,EAApB,KAAA,WAAW,CAAC,KAAK,CAAC,CAAC,CAAC,EAApB,cAAoB,EAApB,IAAoB,EAAE;YAApC,IAAM,IAAI,SAAA;YACb,KAAmB,UAAe,EAAf,KAAA,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,EAAf,cAAe,EAAf,IAAe,EAAE;gBAA/B,IAAM,IAAI,SAAA;gBACb,IAAI,IAAI,KAAK,IAAI,EAAE;oBACjB,aAAa,CAAC,GAAG,EAAE,CAAC;iBACrB;qBAAM,IAAI,IAAI,KAAK,GAAG,EAAE;oBACvB,aAAa,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;iBAC1B;aACF;SACF;QACD,OAAO,aAAa,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;IACjC,CAAC;IAtBD,oBAsBC;IAKD,SAAgB,SAAS,CAAC,IAAY;QACpC,OAAO,IAAI,CAAC,OAAO,CAAC,KAAK,EAAE,GAAG,CAAC,CAAC;IAClC,CAAC;IAFD,8BAEC;IAKD,SAAgB,mBAAmB,CAAC,IAAY,EAAE,OAAa;QAAb,wBAAA,EAAA,aAAa;QAC7D,IAAI,IAAI,IAAI,IAAI,CAAC,MAAM,GAAG,CAAC,IAAI,IAAI,CAAC,IAAI,CAAC,MAAM,GAAG,CAAC,CAAC,KAAK,OAAO,EAAE;YAChE,OAAO,KAAG,IAAI,GAAG,OAAS,CAAC;SAC5B;QACD,OAAO,IAAI,CAAC;IACd,CAAC;IALD,kDAKC","sourcesContent":["/**\n * Get the parent directory name of a path\n */\nexport function dirname(path: string) {\n  const sep = getPathSep(path);\n  const parts = normalize(path).split('/');\n  parts.pop();\n  if (parts.length === 1 && parts[0] === '') {\n    return sep;\n  }\n  return parts.join(sep);\n}\n\n/**\n * Get the path separator used for a given set of paths.\n */\nexport function getPathSep(...paths: string[]) {\n  return paths.some(path => /\\\\/.test(path)) ? '\\\\' : '/';\n}\n\n/**\n * Join a set of paths, resolving any relative segments (. or ..) in subsequent\n * paths against the first path.\n */\nexport function join(...paths: string[]) {\n  const sep = getPathSep(...paths);\n  const normalPaths = paths.map(normalize);\n  const basePathParts = normalPaths[0].split('/');\n\n  if (\n    basePathParts.length > 1 &&\n    basePathParts[basePathParts.length - 1] === ''\n  ) {\n    basePathParts.pop();\n  }\n\n  for (const path of normalPaths.slice(1)) {\n    for (const part of path.split('/')) {\n      if (part === '..') {\n        basePathParts.pop();\n      } else if (part !== '.') {\n        basePathParts.push(part);\n      }\n    }\n  }\n  return basePathParts.join(sep);\n}\n\n/**\n * Normalize a path, replacing any occurrences of '\\' with '/'\n */\nexport function normalize(path: string) {\n  return path.replace(/\\\\/g, '/');\n}\n\n/**\n * Normalize a path such that it ends with a path separator\n */\nexport function normalizePathEnding(path: string, pathSep = '/') {\n  if (path && path.length > 0 && path[path.length - 1] !== pathSep) {\n    return `${path}${pathSep}`;\n  }\n  return path;\n}\n"]}