{"version":3,"file":"instrument.js","sourceRoot":"","sources":["../../../../src/lib/middleware/instrument.ts"],"names":[],"mappings":"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","sourcesContent":["import { stat, readFile } from 'fs';\nimport * as createError from 'http-errors';\nimport { lookup } from 'mime-types';\nimport { join, resolve } from 'path';\nimport { RequestHandler } from 'express';\n\nimport { Context } from '../Server';\n\nexport default function instrument(context: Context): RequestHandler {\n  const codeCache: {\n    [filename: string]: { mtime: number; data: string };\n  } = Object.create(null);\n\n  return (request, response, next) => {\n    const { basePath, executor } = context;\n    const wholePath = resolve(join(basePath, request.url));\n\n    if (\n      !(request.method === 'HEAD' || request.method === 'GET') ||\n      !executor.shouldInstrumentFile(wholePath)\n    ) {\n      return next();\n    }\n\n    stat(wholePath, (error, stats) => {\n      // The server was stopped before this file was served\n      if (context.stopped) {\n        return;\n      }\n\n      if (error || !stats.isFile()) {\n        executor.log('Unable to serve', wholePath, '(unreadable)');\n        return next(createError(404, error, { expose: false }));\n      }\n\n      executor.log('Serving', wholePath);\n\n      const send = (contentType: string, data: string) => {\n        response.writeHead(200, {\n          'Content-Type': contentType,\n          'Content-Length': Buffer.byteLength(data)\n        });\n        response.end(request.method === 'HEAD' ? '' : data, callback);\n      };\n      const callback = (error?: Error) => {\n        if (error) {\n          executor.emit(\n            'error',\n            new Error(`Error serving ${wholePath}: ${error.message}`)\n          );\n        } else {\n          executor.log('Served', wholePath);\n        }\n      };\n\n      const contentType = lookup(wholePath) || 'application/octet-stream';\n      const mtime = stats.mtime.getTime();\n\n      if (codeCache[wholePath] && codeCache[wholePath].mtime === mtime) {\n        send(contentType, codeCache[wholePath].data);\n      } else {\n        readFile(wholePath, 'utf8', (error, data) => {\n          // The server was stopped in the middle of the file read\n          if (context.stopped) {\n            return;\n          }\n\n          if (error) {\n            return next(createError(404, error, { expose: false }));\n          }\n\n          // providing `wholePath` to the instrumenter instead of a\n          // partial filename is necessary because lcov.info requires\n          // full path names as per the lcov spec\n          data = executor.instrumentCode(data, wholePath);\n          codeCache[wholePath] = {\n            // strictly speaking mtime could reflect a previous\n            // version, assume those race conditions are rare\n            mtime,\n            data\n          };\n          send(contentType, data);\n        });\n      }\n    });\n  };\n}\n"]}