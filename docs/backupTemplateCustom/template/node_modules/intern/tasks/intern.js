(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports", "tslib", "@theintern/common", "../lib/executors/Node", "../lib/node/util"], factory);
    }
})(function (require, exports) {
    "use strict";
    var tslib_1 = require("tslib");
    var common_1 = require("@theintern/common");
    var Node_1 = require("../lib/executors/Node");
    var util_1 = require("../lib/node/util");
    function getConfigAndOptions(options) {
        if (options.config) {
            return util_1.getConfig(options.config, []).then(function (_a) {
                var config = _a.config;
                var opts = tslib_1.__assign({}, options);
                delete opts.config;
                return { config: config, options: opts };
            });
        }
        return Promise.resolve({ config: {}, options: options });
    }
    return function (grunt) {
        grunt.registerMultiTask('intern', function () {
            var done = this.async();
            var options = this.options({});
            process.env.FORCE_COLOR = 'true';
            getConfigAndOptions(options)
                .then(function (_a) {
                var config = _a.config, options = _a.options;
                var intern = (common_1.global.intern = new Node_1.default());
                intern.configure(config);
                intern.configure(options);
                return intern.run();
            })
                .then(finish, finish);
            function finish(error) {
                common_1.global.intern = null;
                done(error);
            }
        });
    };
});
//# sourceMappingURL=intern.js.map