{"version":3,"file":"Tunnel.js","sourceRoot":"","sources":["../../src/Tunnel.ts"],"names":[],"mappings":"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","sourcesContent":["import {\n  Evented,\n  EventObject,\n  Handle,\n  createCompositeHandle,\n  Task,\n  CancellablePromise,\n  request,\n  Response\n} from '@theintern/common';\nimport { spawn, ChildProcess } from 'child_process';\nimport { join } from 'path';\nimport { format as formatUrl, Url } from 'url';\nimport { fileExists, kill, on } from './lib/util';\nimport { JobState } from './interfaces';\nimport * as decompress from 'decompress';\n\n/**\n * A Tunnel is a mechanism for connecting to a WebDriver service provider that\n * securely exposes local services for testing within the service providerâ€™s\n * network.\n */\nexport default class Tunnel extends Evented<TunnelEvents, string>\n  implements TunnelProperties, Url {\n  /**\n   * The URL of a service that provides a list of environments supported by\n   * the tunnel.\n   */\n  environmentUrl: string | undefined;\n\n  /**\n   * The tunnel access key. This will be initialized with a tunnel-specific\n   * environment variable if not specified.\n   */\n  accessKey: string | undefined;\n\n  /**\n   * The tunnel username. This will be initialized with a tunnel-specific\n   * environment variable if not specified.\n   */\n  username: string | undefined;\n\n  /**\n   * The architecture the tunnel will run against. This information is\n   * automatically retrieved for the current system at runtime.\n   */\n  architecture!: string;\n\n  /**\n   * An HTTP authorization string to use when initiating connections to the\n   * tunnel. This value of this property is defined by Tunnel subclasses.\n   */\n  auth: string | undefined;\n\n  /**\n   * The directory where the tunnel software will be extracted. If the\n   * directory does not exist, it will be created. This value is set by the\n   * tunnel subclasses.\n   */\n  directory!: string;\n\n  /**\n   * The executable to spawn in order to create a tunnel. This value is set\n   * by the tunnel subclasses.\n   */\n  executable!: string;\n\n  /**\n   * The host on which a WebDriver client can access the service provided by\n   * the tunnel. This may or may not be the host where the tunnel application\n   * is running.\n   */\n  hostname!: string;\n\n  /**\n   * The path that a WebDriver client should use to access the service\n   * provided by the tunnel.\n   */\n  pathname!: string;\n\n  /**\n   * The operating system the tunnel will run on. This information is\n   * automatically retrieved for the current system at runtime.\n   */\n  platform!: string;\n\n  /**\n   * The local port where the WebDriver server should be exposed by the\n   * tunnel. This is typed as a string for Url compatibility, but should be a\n   * number.\n   */\n  port!: string;\n\n  /**\n   * The protocol (e.g., 'http') that a WebDriver client should use to access\n   * the service provided by the tunnel.\n   */\n  protocol!: string;\n\n  /**\n   * The URL of a proxy server for the tunnel to go through. Only the\n   * hostname, port, and auth are used.\n   */\n  proxy: string | undefined;\n\n  /** A unique identifier for the newly created tunnel. */\n  tunnelId: string | undefined;\n\n  /** The URL where the tunnel software can be downloaded. */\n  url!: string;\n\n  /** Whether or not to tell the tunnel to provide verbose logging output. */\n  verbose!: boolean;\n\n  protected _startTask: CancellablePromise<any> | undefined;\n  protected _stopTask: Promise<number | void> | undefined;\n  protected _handle: Handle | undefined;\n  protected _process: ChildProcess | undefined;\n  protected _state!: 'stopped' | 'starting' | 'running' | 'stopping';\n\n  constructor(options?: TunnelOptions) {\n    super();\n    Object.assign(\n      this,\n      {\n        architecture: process.arch,\n        hostname: 'localhost',\n        pathname: '/wd/hub/',\n        platform: process.platform,\n        port: 4444,\n        protocol: 'http',\n        verbose: false,\n        state: 'stopped'\n      },\n      options || {}\n    );\n  }\n\n  /**\n   * The URL that a WebDriver client should used to interact with this\n   * service.\n   */\n  get clientUrl(): string {\n    return formatUrl(this);\n  }\n\n  /**\n   * A map of additional capabilities that need to be sent to the provider\n   * when a new session is being created.\n   */\n  get extraCapabilities(): object {\n    return {};\n  }\n\n  /**\n   * Whether or not the tunnel software has already been downloaded.\n   */\n  get isDownloaded(): boolean {\n    return fileExists(this.executable);\n  }\n\n  /**\n   * Whether or not the tunnel is currently running.\n   */\n  get isRunning(): boolean {\n    return this._state === 'running';\n  }\n\n  /**\n   * Whether or not the tunnel is currently starting up.\n   */\n  get isStarting(): boolean {\n    return this._state === 'starting';\n  }\n\n  /**\n   * Whether or not the tunnel is currently stopping.\n   */\n  get isStopping(): boolean {\n    return this._state === 'stopping';\n  }\n\n  /**\n   * Downloads and extracts the tunnel software if it is not already\n   * downloaded.\n   *\n   * This method can be extended by implementations to perform any necessary\n   * post-processing, such as setting appropriate file permissions on the\n   * downloaded executable.\n   *\n   * @param forceDownload Force downloading the software even if it already\n   * has been downloaded.\n   * @returns A promise that resolves once the download and extraction process\n   * has completed.\n   */\n  download(forceDownload = false): CancellablePromise<void> {\n    if (!forceDownload && this.isDownloaded) {\n      return Task.resolve();\n    }\n    return this._downloadFile(this.url, this.proxy);\n  }\n\n  /**\n   * Get a list of environments available on the service.\n   *\n   * This method should be overridden and use a specific implementation that\n   * returns normalized environments from the service. E.g.\n   *\n   * ```js\n   * {\n   *     browserName: 'firefox',\n   *     version: '12',\n   *     platform: 'windows',\n   *     descriptor: { <original returned environment> }\n   * }\n   * ```\n   *\n   * @returns An object containing the response and helper functions\n   */\n  getEnvironments(): CancellablePromise<NormalizedEnvironment[]> {\n    if (!this.environmentUrl) {\n      return Task.resolve([]);\n    }\n\n    return request(this.environmentUrl, {\n      password: this.accessKey,\n      username: this.username,\n      proxy: this.proxy\n    }).then(response => {\n      if (response.status >= 200 && response.status < 400) {\n        return response.json<any[]>().then(data => {\n          return data.reduce(\n            (environments: NormalizedEnvironment[], environment: any) => {\n              return environments.concat(\n                this._normalizeEnvironment(environment)\n              );\n            },\n            []\n          );\n        });\n      } else {\n        if (response.status === 401) {\n          throw new Error('Missing or invalid username and access key');\n        }\n        throw new Error(`Server replied with a status of ${response.status}`);\n      }\n    });\n  }\n\n  /**\n   * Sends information about a job to the tunnel provider.\n   *\n   * @param jobId The job to send data about. This is usually a session ID.\n   * @param data Data to send to the tunnel provider about the job.\n   * @returns A promise that resolves once the job state request is complete.\n   */\n  sendJobState(_jobId: string, _data: JobState): CancellablePromise<void> {\n    return Task.reject(new Error('Job state is not supported by this tunnel.'));\n  }\n\n  /**\n   * Starts the tunnel, automatically downloading dependencies if necessary.\n   *\n   * @returns A promise that resolves once the tunnel has been established.\n   */\n  start(): CancellablePromise<void> {\n    switch (this._state) {\n      case 'stopping':\n        throw new Error('Previous tunnel is still terminating');\n      case 'running':\n      case 'starting':\n        return this._startTask!;\n    }\n\n    this._state = 'starting';\n\n    this._startTask = this.download().then(() => {\n      return this._start(child => {\n        this._process = child;\n        this._handle = createCompositeHandle(\n          this._handle || { destroy: function() {} },\n          on(child.stdout, 'data', proxyIOEvent(this, 'stdout')),\n          on(child.stderr, 'data', proxyIOEvent(this, 'stderr')),\n          on(child, 'exit', () => {\n            this._state = 'stopped';\n          })\n        );\n      });\n    });\n\n    this._startTask\n      .then(() => {\n        this._startTask = undefined;\n        this._state = 'running';\n        this.emit({\n          type: 'status',\n          target: this,\n          status: 'Ready'\n        });\n      })\n      .catch(error => {\n        this._startTask = undefined;\n        this._state = 'stopped';\n        this.emit({\n          type: 'status',\n          target: this,\n          status:\n            error.name === 'CancelError'\n              ? 'Start cancelled'\n              : 'Failed to start tunnel'\n        });\n      });\n\n    return this._startTask!;\n  }\n\n  /**\n   * Stops the tunnel.\n   *\n   * @returns A promise that resolves to the exit code for the tunnel once it\n   * has been terminated.\n   */\n  stop(): Promise<number | void> {\n    switch (this._state) {\n      case 'starting':\n        this._startTask!.cancel();\n        return this._startTask!.finally(() => null);\n      case 'stopping':\n        return this._stopTask!;\n    }\n\n    this._state = 'stopping';\n\n    this.emit({\n      type: 'status',\n      target: this,\n      status: 'Stopping'\n    });\n\n    this._stopTask = this._stop()\n      .then(returnValue => {\n        if (this._handle) {\n          this._handle.destroy();\n        }\n        this._process = this._handle = undefined;\n        this._state = 'stopped';\n        this.emit({\n          type: 'status',\n          target: this,\n          status: 'Stopped'\n        });\n        return returnValue;\n      })\n      .catch(error => {\n        this._state = 'running';\n        throw error;\n      });\n\n    return this._stopTask;\n  }\n\n  protected _downloadFile(\n    url: string | undefined,\n    proxy: string | undefined,\n    options?: DownloadOptions\n  ): CancellablePromise<void> {\n    let req: CancellablePromise<Response>;\n\n    if (!url) {\n      return Task.reject(new Error('URL is empty'));\n    }\n\n    return new Task<void>(\n      (resolve, reject) => {\n        req = request(url, {\n          proxy,\n          onDownloadProgress: event => {\n            this.emit({\n              type: 'downloadprogress',\n              target: this,\n              url,\n              total: event.total,\n              received: event.received\n            });\n          }\n        });\n\n        req\n          .then(response => {\n            if (response.status >= 400) {\n              throw new Error(\n                `Download server returned status code ${\n                  response.status\n                } for ${url}`\n              );\n            } else {\n              response.arrayBuffer().then(data => {\n                resolve(this._postDownloadFile(Buffer.from(data), options));\n              });\n            }\n          })\n          .catch(error => {\n            reject(error);\n          });\n      },\n      () => {\n        req && req.cancel();\n      }\n    );\n  }\n\n  /**\n   * Creates the list of command-line arguments to be passed to the spawned\n   * tunnel. Implementations should override this method to provide the\n   * appropriate command-line arguments.\n   *\n   * Arguments passed to [[Tunnel._makeChild]] will be passed as-is to this\n   * method.\n   *\n   * @returns A list of command-line arguments.\n   */\n  protected _makeArgs(..._values: string[]): string[] {\n    return [];\n  }\n\n  /**\n   * Creates a newly spawned child process for the tunnel software.\n   * Implementations should call this method to create the tunnel process.\n   *\n   * Arguments passed to this method will be passed as-is to\n   * [[Tunnel._makeArgs]] and [[Tunnel._makeOptions]].\n   *\n   * @returns An object containing a newly spawned Process and a Deferred that\n   * will be resolved once the tunnel has started successfully.\n   */\n  protected _makeChild(\n    executor: ChildExecutor,\n    ...values: string[]\n  ): CancellablePromise {\n    const command = this.executable;\n    const args = this._makeArgs(...values);\n    const options = this._makeOptions(...values);\n    const child = spawn(command, args, options);\n\n    child.stdout.setEncoding('utf8');\n    child.stderr.setEncoding('utf8');\n\n    let handle: Handle;\n    let canceled = false;\n    const task = new Task(\n      (resolve, reject) => {\n        let errorMessage = '';\n        let exitCode: number | undefined;\n        let stderrClosed = false;\n        let exitted = false;\n\n        function handleChildExit() {\n          reject(\n            new Error(\n              `Tunnel failed to start: ${errorMessage ||\n                `Exit code: ${exitCode}`}`\n            )\n          );\n        }\n\n        handle = createCompositeHandle(\n          on(child, 'error', reject),\n\n          on(child.stderr, 'data', (data: string) => {\n            errorMessage += data;\n          }),\n\n          on(child, 'exit', () => {\n            exitted = true;\n            if (stderrClosed) {\n              handleChildExit();\n            }\n          }),\n\n          // stderr might still have data in buffer at the time the\n          // exit event is sent, so we have to store data from stderr\n          // and the exit code and reject only once stderr closes\n          on(child.stderr, 'close', () => {\n            stderrClosed = true;\n            if (exitted) {\n              handleChildExit();\n            }\n          })\n        );\n\n        const result = executor(child, resolve, reject);\n        if (result) {\n          handle = createCompositeHandle(handle, result);\n        }\n      },\n      () => {\n        canceled = true;\n\n        // Make a best effort to kill the process, but don't throw\n        // exceptions\n        try {\n          kill(child.pid);\n        } catch (error) {}\n      }\n    );\n\n    return task.finally(() => {\n      handle.destroy();\n      if (canceled) {\n        // We only want this to run when cancelation has occurred\n        return new Promise(resolve => {\n          child.once('exit', () => {\n            resolve();\n          });\n        });\n      }\n    });\n  }\n\n  /**\n   * Creates the set of options to use when spawning the tunnel process.\n   * Implementations should override this method to provide the appropriate\n   * options for the tunnel software.\n   *\n   * Arguments passed to [[Tunnel._makeChild]] will be passed as-is to this\n   * method.\n   *\n   * @returns A set of options matching those provided to Node.js\n   * `child_process.spawn`.\n   */\n  protected _makeOptions(..._values: string[]) {\n    return { env: process.env };\n  }\n\n  /**\n   * Normalizes a specific Tunnel environment descriptor to a general form. To\n   * be overriden by a child implementation.\n   *\n   * @param environment an environment descriptor specific to the Tunnel\n   * @returns a normalized environment\n   */\n  protected _normalizeEnvironment(environment: Object): NormalizedEnvironment {\n    return <any>environment;\n  }\n\n  /**\n   * Called with the response after a file download has completed\n   */\n  protected _postDownloadFile(\n    data: Buffer,\n    options?: DownloadOptions\n  ): Promise<void> {\n    return new Promise<void>((resolve, reject) => {\n      let directory = this.directory;\n      if (options && options.directory) {\n        directory = join(directory, options.directory);\n      }\n      decompress(data, directory)\n        .then(() => resolve())\n        .catch(reject);\n    });\n  }\n\n  /**\n   * This method provides the implementation that actually starts the tunnel\n   * and any other logic for emitting events on the Tunnel based on data\n   * passed by the tunnel software.\n   *\n   * The default implementation that assumes the tunnel is ready for use once\n   * the child process has written to `stdout` or `stderr`. This method should\n   * be reimplemented by other tunnel launchers to implement correct launch\n   * detection logic.\n   *\n   * @returns An object containing a reference to the child process, and a\n   * Deferred that is resolved once the tunnel is ready for use. Normally this\n   * will be the object returned from a call to [[Tunnel._makeChild]].\n   */\n  protected _start(executor: ChildExecutor) {\n    return this._makeChild((child, resolve, reject) => {\n      const handle = createCompositeHandle(\n        on(child.stdout, 'data', resolve),\n        on(child.stderr, 'data', resolve),\n        on(child, 'error', (error: Error) => {\n          reject(error);\n        })\n      );\n\n      try {\n        executor(child, resolve, reject);\n      } catch (error) {\n        reject(error);\n      }\n\n      return handle;\n    });\n  }\n\n  /**\n   * This method provides the implementation that actually stops the tunnel.\n   *\n   * The default implementation that assumes the tunnel has been closed once\n   * the child process has exited. This method should be reimplemented by\n   * other tunnel launchers to implement correct shutdown logic, if necessary.\n   *\n   * @returns A promise that resolves once the tunnel has shut down.\n   */\n  protected _stop() {\n    return new Promise<number | void>((resolve, reject) => {\n      const childProcess = this._process;\n      if (!childProcess) {\n        resolve();\n        return;\n      }\n\n      childProcess.once('exit', code => {\n        resolve(code);\n      });\n\n      try {\n        kill(childProcess.pid);\n      } catch (error) {\n        reject(error);\n      }\n    });\n  }\n}\n\nexport interface TunnelEventObject<T> extends EventObject<string> {\n  readonly target: T;\n}\n\nexport interface TunnelEvents {\n  stdout: IOEvent;\n  stderr: IOEvent;\n  status: StatusEvent;\n  downloadprogress: DownloadProgressEvent;\n  [index: string]: any;\n}\n\n/**\n * A chunk of raw string data output by the tunnel software to stdout or stderr.\n */\n// tslint:disable-next-line:interface-name\nexport interface IOEvent extends TunnelEventObject<Tunnel> {\n  readonly type: 'stdout' | 'stderr';\n  readonly data: string;\n}\n\n/**\n * An event containing information about the status of the tunnel setup process\n * that is suitable for presentation to end-users.\n */\nexport interface StatusEvent extends TunnelEventObject<Tunnel> {\n  readonly type: 'status';\n  readonly status: string;\n}\n\n/**\n * An event indicating that part of a tunnel binary has been downloaded from the\n * server.\n */\nexport interface DownloadProgressEvent extends TunnelEventObject<Tunnel> {\n  /** The event type */\n  readonly type: 'downloadprogress';\n  /** The URL being downloaded from */\n  readonly url: string;\n  /** The total number of bytes being downloaded */\n  readonly total: number;\n  /** The number of bytes received so far */\n  readonly received: number;\n}\n\n/**\n * A handle to a child process, along with resolve and reject callbacks that can\n * be used to settle an associated Promise.\n */\nexport interface ChildExecutor {\n  (\n    child: ChildProcess,\n    resolve: () => void,\n    reject: (reason?: any) => void\n  ): Handle | void;\n}\n\n/** Options for file downloads */\nexport interface DownloadProperties {\n  directory: string | undefined;\n  proxy: string | undefined;\n  url: string;\n}\n\nexport type DownloadOptions = Partial<DownloadProperties>;\n\n/**\n * A normalized environment descriptor.\n *\n * A NormalizedEnvironment contains a mix of W3C WebDriver and JSONWireProtocol\n * capabilities, as well as a set of standardized capabilities that can be used\n * to specify the given environment in an Intern `environments` descriptor.\n */\nexport interface NormalizedEnvironment {\n  browserName: string;\n  browserVersion?: string;\n  descriptor: Object;\n  platform: string;\n  platformName?: string;\n  platformVersion?: string;\n  version: string;\n\n  intern: {\n    platform: string;\n    browserName: string;\n    version: string;\n  };\n}\n\n/** Properties of a tunnel */\nexport interface TunnelProperties extends DownloadProperties {\n  /** [[Tunnel.Tunnel.architecture|More info]] */\n  architecture: string;\n\n  /** [[Tunnel.Tunnel.auth|More info]] */\n  auth: string | undefined;\n\n  /** [[Tunnel.Tunnel.accessKey|More info]] */\n  accessKey: string | undefined;\n\n  /** [[Tunnel.Tunnel.executable|More info]] */\n  executable: string | undefined;\n\n  /** [[Tunnel.Tunnel.hostname|More info]] */\n  hostname: string;\n\n  /** [[Tunnel.Tunnel.pathname|More info]] */\n  pathname: string;\n\n  /** [[Tunnel.Tunnel.platform|More info]] */\n  platform: string;\n\n  /** [[Tunnel.Tunnel.port|More info]] */\n  port: string;\n\n  /** [[Tunnel.Tunnel.protocol|More info]] */\n  protocol: string;\n\n  /** [[Tunnel.Tunnel.tunnelId|More info]] */\n  tunnelId: string | undefined;\n\n  /** [[Tunnel.Tunnel.username|More info]] */\n  username: string | undefined;\n\n  /** [[Tunnel.Tunnel.verbose|More info]] */\n  verbose: boolean;\n}\n\nexport type TunnelOptions = Partial<TunnelProperties>;\n\nfunction proxyIOEvent(target: Tunnel, type: 'stdout' | 'stderr') {\n  return function(data: any) {\n    target.emit({\n      type,\n      target,\n      data: String(data)\n    });\n  };\n}\n\ndelete Tunnel.prototype.on;\n"]}