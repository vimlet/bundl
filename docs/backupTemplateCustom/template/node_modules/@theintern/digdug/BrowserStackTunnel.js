"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var fs_1 = require("fs");
var path_1 = require("path");
var common_1 = require("@theintern/common");
var Tunnel_1 = require("./Tunnel");
var url_1 = require("url");
var util_1 = require("./lib/util");
/**
 * A BrowserStack tunnel.
 *
 * The accessKey and username properties will be initialized using
 * BROWSERSTACK_ACCESS_KEY and BROWSERSTACK_USERNAME.
 */
var BrowserStackTunnel = /** @class */ (function (_super) {
    __extends(BrowserStackTunnel, _super);
    function BrowserStackTunnel(options) {
        return _super.call(this, Object.assign({
            accessKey: process.env.BROWSERSTACK_ACCESS_KEY,
            automateOnly: true,
            directory: path_1.join(__dirname, 'browserstack'),
            environmentUrl: 'https://www.browserstack.com/automate/browsers.json',
            forceLocal: false,
            hostname: 'hub.browserstack.com',
            killOtherTunnels: false,
            port: '443',
            protocol: 'https',
            servers: [],
            skipServerValidation: true,
            username: process.env.BROWSERSTACK_USERNAME
        }, options || {})) || this;
    }
    Object.defineProperty(BrowserStackTunnel.prototype, "auth", {
        get: function () {
            return (this.username || '') + ":" + (this.accessKey || '');
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(BrowserStackTunnel.prototype, "executable", {
        get: function () {
            return path_1.join(this.directory, "BrowserStackLocal" + (this.platform === 'win32' ? '.exe' : ''));
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(BrowserStackTunnel.prototype, "extraCapabilities", {
        get: function () {
            var capabilities = {
                'browserstack.local': 'true'
            };
            if (this.tunnelId) {
                capabilities['browserstack.localIdentifier'] = this.tunnelId;
            }
            return capabilities;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(BrowserStackTunnel.prototype, "url", {
        get: function () {
            var platform = this.platform;
            var architecture = this.architecture;
            var url = 'https://www.browserstack.com/browserstack-local/BrowserStackLocal-';
            if (platform === 'darwin' && architecture === 'x64') {
                url += platform + '-' + architecture;
            }
            else if (platform === 'win32') {
                url += platform;
            }
            else if (platform === 'linux' &&
                (architecture === 'ia32' || architecture === 'x64')) {
                url += platform + '-' + architecture;
            }
            else {
                throw new Error(platform + ' on ' + architecture + ' is not supported');
            }
            url += '.zip';
            return url;
        },
        enumerable: true,
        configurable: true
    });
    BrowserStackTunnel.prototype._postDownloadFile = function (data, options) {
        var _this = this;
        return _super.prototype._postDownloadFile.call(this, data, options).then(function () {
            var executable = _this.executable;
            fs_1.chmodSync(executable, parseInt('0755', 8));
        });
    };
    BrowserStackTunnel.prototype._makeArgs = function () {
        var _values = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            _values[_i] = arguments[_i];
        }
        if (!this.username || !this.accessKey) {
            throw new Error('BrowserStackTunnel requires a username and access key');
        }
        var args = [
            this.accessKey,
            this.servers
                .map(function (server) {
                var url = url_1.parse(String(server));
                return [
                    url.hostname,
                    url.port,
                    url.protocol === 'https:' ? 1 : 0
                ].join(',');
            })
                .join(',')
        ];
        this.automateOnly && args.push('-onlyAutomate');
        this.forceLocal && args.push('-forcelocal');
        this.killOtherTunnels && args.push('-force');
        this.skipServerValidation && args.push('-skipCheck');
        this.tunnelId && args.push('-localIdentifier', this.tunnelId);
        this.verbose && args.push('-v');
        if (this.proxy) {
            var proxy = url_1.parse(this.proxy);
            proxy.hostname && args.push('-proxyHost', proxy.hostname);
            proxy.port && args.push('-proxyPort', proxy.port);
            if (proxy.auth) {
                var auth = proxy.auth.split(':');
                args.push('-proxyUser', auth[0], '-proxyPass', auth[1]);
            }
            /*else {
                      proxy.username && args.push('-proxyUser', proxy.username);
                      proxy.password && args.push('-proxyPass', proxy.password);
                  }*/
        }
        return args;
    };
    BrowserStackTunnel.prototype.sendJobState = function (jobId, data) {
        var payload = JSON.stringify({
            status: data.status || data.success ? 'completed' : 'error'
        });
        var url = "https://www.browserstack.com/automate/sessions/" + jobId + ".json";
        return common_1.request(url, {
            method: 'put',
            data: payload,
            headers: {
                'Content-Length': String(Buffer.byteLength(payload, 'utf8')),
                'Content-Type': 'application/json'
            },
            password: this.accessKey,
            username: this.username,
            proxy: this.proxy
        }).then(function (response) {
            if (response.status < 200 || response.status >= 300) {
                return response.text().then(function (text) {
                    throw new Error(text || "Server reported " + response.status + " with no other data.");
                });
            }
        });
    };
    BrowserStackTunnel.prototype._start = function (executor) {
        var _this = this;
        return this._makeChild(function (child, resolve, reject) {
            var handle = util_1.on(child.stdout, 'data', function (data) {
                data = String(data);
                var error = /\s*\*\*\* Error: (.*)$/m.exec(data);
                if (error) {
                    handle.destroy();
                    reject(new Error("The tunnel reported: " + error[1]));
                }
                else if (data.indexOf('You can now access your local server(s) in our remote browser') > -1) {
                    handle.destroy();
                    resolve();
                }
                else {
                    var line = data.replace(/^\s+/, '').replace(/\s+$/, '');
                    if (/^BrowserStackLocal v/.test(line) ||
                        /^Connecting to BrowserStack/.test(line) ||
                        /^Connected/.test(line)) {
                        _this.emit({
                            type: 'status',
                            target: _this,
                            status: line
                        });
                    }
                }
            });
            executor(child, resolve, reject);
        });
    };
    BrowserStackTunnel.prototype._stop = function () {
        var _this = this;
        return new Promise(function (resolve) {
            var childProcess = _this._process;
            if (!childProcess) {
                resolve();
                return;
            }
            var exited = false;
            childProcess.once('exit', function (code) {
                exited = true;
                resolve(code);
            });
            util_1.kill(childProcess.pid);
            // As of at least version 5.1, BrowserStackLocal spawns a secondary
            // process. This is the one that needs to receive the CTRL-C, but
            // Node doesn't provide an easy way to get the PID of the secondary
            // process, so we'll just wait a few seconds, then kill the process
            // if it hasn't ended cleanly.
            setTimeout(function () {
                if (!exited) {
                    util_1.kill(childProcess.pid);
                }
            }, 5000);
        });
    };
    /**
     * Attempt to normalize a BrowserStack described environment with the
     * standard Selenium capabilities
     *
     * BrowserStack returns a list of environments that looks like:
     *
     * {
     *     "browser": "opera",
     *     "os_version": "Lion",
     *     "browser_version":"12.15",
     *     "device": null,
     *     "os": "OS X"
     * }
     *
     * @param environment a BrowserStack environment descriptor
     * @returns a normalized descriptor
     */
    BrowserStackTunnel.prototype._normalizeEnvironment = function (environment) {
        var platformMap = {
            Windows: {
                '10': 'WINDOWS',
                '8.1': 'WIN8',
                '8': 'WIN8',
                '7': 'WINDOWS',
                XP: 'XP'
            },
            'OS X': 'MAC'
        };
        var browserMap = {
            ie: 'internet explorer'
        };
        // Create the BS platform name for a given os + version
        var platform = platformMap[environment.os] || environment.os;
        if (typeof platform === 'object') {
            platform = platform[environment.os_version];
        }
        var browserName = browserMap[environment.browser] || environment.browser;
        var version = environment.browser_version;
        return {
            platform: platform,
            platformName: environment.os,
            platformVersion: environment.os_version,
            browserName: browserName,
            browserVersion: version,
            version: environment.browser_version,
            descriptor: environment,
            intern: {
                platform: platform,
                browserName: browserName,
                version: version
            }
        };
    };
    return BrowserStackTunnel;
}(Tunnel_1.default));
exports.default = BrowserStackTunnel;
//# sourceMappingURL=BrowserStackTunnel.js.map