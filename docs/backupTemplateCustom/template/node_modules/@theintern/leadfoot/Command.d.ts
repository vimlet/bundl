/// <reference types="node" />
import Element from './Element';
import { CancellablePromise } from '@theintern/common';
import Session from './Session';
import Locator, { Strategy } from './lib/Locator';
import { LogEntry, Geolocation, WebDriverCookie } from './interfaces';
export default class Command<T, P = any, StringResult = string> extends Locator<Command<Element, P, string>, Command<Element[], P, string[]>, Command<void, P, StringResult>> implements PromiseLike<T> {
    static addSessionMethod<U, P, S>(target: Command<U, P, S>, key: string, originalFn: Function): void;
    static addElementMethod<T, P, S>(target: Command<T, P, S>, key: string): void;
    private _parent;
    private _session;
    private _context;
    private _task;
    constructor(parentOrSession: Session | Command<P, any, StringResult> | null, initialiser?: (this: Command<T>, setContext: SetContextMethod, value: T) => T | CancellablePromise<T>, errback?: (this: Command<T>, setContext: SetContextMethod, error: Error) => T | CancellablePromise<T>);
    readonly parent: Command<P, any, StringResult>;
    readonly session: Session;
    readonly context: Context;
    readonly promise: CancellablePromise<any>;
    sleep(ms: number): Command<void, P, StringResult>;
    end(numCommandsToPop?: number): Command<void, P, StringResult>;
    then<U = T, R = never>(callback?: ((this: Command<T>, value: T, setContext: SetContextMethod) => U | PromiseLike<U>) | null | undefined, errback?: ((this: Command<T>, error: any) => R | PromiseLike<R>) | null | undefined): Command<U | R, P, StringResult>;
    catch<R = never>(errback: (this: Command<T>, reason: any) => R | PromiseLike<R>): Command<T | R, P, StringResult>;
    finally(callback: () => void): this;
    cancel(): this;
    find(strategy: Strategy, value: string): Command<Element, P, string>;
    findAll(strategy: Strategy, value: string): Command<Element[], P, string[]>;
    findDisplayed(strategy: Strategy, value: string): Command<Element, P, string>;
    private _callFindElementMethod;
    private _callElementMethod;
    private _callSessionMethod;
    getTimeout(type: string): Command<number, P, StringResult>;
    setTimeout(type: string, ms: number): Command<void, P, StringResult>;
    getCurrentWindowHandle(): Command<string, P, StringResult>;
    getAllWindowHandles(): Command<string[], P, StringResult>;
    getCurrentUrl(): Command<string, P, StringResult>;
    get(url: string): Command<void, P, StringResult>;
    goForward(): Command<void, P, StringResult>;
    goBack(): Command<void, P, StringResult>;
    refresh(): Command<void, P, StringResult>;
    execute<T = any>(script: Function | string, args?: any[]): Command<T, P, StringResult>;
    executeAsync<T = any>(script: Function | string, args?: any[]): Command<T, P, StringResult>;
    takeScreenshot(): Command<Buffer, P, StringResult>;
    getAvailableImeEngines(): Command<string[], P, StringResult>;
    getActiveImeEngine(): Command<string, P, StringResult>;
    isImeActivated(): Command<boolean, P, StringResult>;
    deactivateIme(): Command<void, P, StringResult>;
    activateIme(engine: string): Command<void, P, StringResult>;
    switchToFrame(id: string | number | Element | null): Command<void, P, StringResult>;
    switchToWindow(handle: string): Command<void, P, StringResult>;
    switchToParentFrame(): Command<void, P, StringResult>;
    closeCurrentWindow(): Command<void, P, StringResult>;
    setWindowSize(width: number, height: number): Command<void, P, StringResult>;
    setWindowSize(windowHandle: string, width: number, height: number): Command<void, P, StringResult>;
    getWindowSize(_windowHandle?: string): Command<{
        width: number;
        height: number;
    }, P, StringResult>;
    setWindowPosition(x: number, y: number): Command<void, P, StringResult>;
    setWindowPosition(windowHandle: string, x: number, y: number): Command<void, P, StringResult>;
    getWindowPosition(windowHandle?: string): Command<{
        x: number;
        y: number;
    }, P, StringResult>;
    maximizeWindow(windowHandle?: string): Command<void, P, StringResult>;
    getCookies(): Command<WebDriverCookie[], P, StringResult>;
    setCookie(cookie: WebDriverCookie): Command<void, P, StringResult>;
    clearCookies(): Command<void, P, StringResult>;
    deleteCookie(name: string): Command<void, P, StringResult>;
    getPageSource(): Command<string, P, StringResult>;
    getPageTitle(): Command<string, P, StringResult>;
    getActiveElement(): Command<Element, P, StringResult>;
    pressKeys(keys: string | string[]): Command<void, P, StringResult>;
    getOrientation(): Command<"landscape" | "portrait", P, StringResult>;
    setOrientation(orientation: 'portrait' | 'landscape'): Command<void, P, StringResult>;
    getAlertText(): Command<string, P, StringResult>;
    typeInPrompt(text: string | string[]): Command<void, P, StringResult>;
    acceptAlert(): Command<void, P, StringResult>;
    dismissAlert(): Command<void, P, StringResult>;
    moveMouseTo(element?: Element, xOffset?: number, yOffset?: number): Command<void, P, StringResult>;
    moveMouseTo(xOffset?: number, yOffset?: number): Command<void, P, StringResult>;
    clickMouseButton(button?: number): Command<void, P, StringResult>;
    pressMouseButton(button?: number): Command<void, P, StringResult>;
    releaseMouseButton(button?: number): Command<void, P, StringResult>;
    doubleClick(): Command<void, P, StringResult>;
    tap(element: Element): Command<void, P, StringResult>;
    pressFinger(x: number, y: number): Command<void, P, StringResult>;
    releaseFinger(x: number, y: number): Command<void, P, StringResult>;
    moveFinger(x: number, y: number): Command<void, P, StringResult>;
    touchScroll(xOffset: number, yOffset: number): Command<void, P, StringResult>;
    touchScroll(element?: Element, xOffset?: number, yOffset?: number): Command<void, P, StringResult>;
    doubleTap(element?: Element): Command<void, P, StringResult>;
    longTap(element?: Element): Command<void, P, StringResult>;
    flickFinger(element: Element, xOffset: number, yOffset: number, speed?: number): Command<void, P, StringResult>;
    flickFinger(xOffset: number, yOffset: number, speed?: number): Command<void, P, StringResult>;
    getGeolocation(): Command<Geolocation, P, StringResult>;
    setGeolocation(location: Geolocation): Command<void, P, StringResult>;
    getLogsFor(type: string): Command<LogEntry[], P, StringResult>;
    getAvailableLogTypes(): Command<string[], P, StringResult>;
    getApplicationCacheStatus(): Command<number, P, StringResult>;
    quit(): Command<void, P, StringResult>;
    waitForDeleted(using: Strategy, value: string): Command<void, P, StringResult>;
    getExecuteAsyncTimeout(): Command<number, P, StringResult>;
    setExecuteAsyncTimeout(ms: number): Command<void, P, StringResult>;
    getFindTimeout(): Command<number, P, StringResult>;
    setFindTimeout(ms: number): Command<void, P, StringResult>;
    getPageLoadTimeout(): Command<number, P, StringResult>;
    setPageLoadTimeout(ms: number): Command<void, P, StringResult>;
    click(): Command<void, P, StringResult>;
    submit(): Command<void, P, StringResult>;
    getVisibleText(): Command<StringResult, P, StringResult>;
    type(value: string | string[]): Command<void, P, StringResult>;
    getTagName(): Command<StringResult, P, StringResult>;
    clearValue(): Command<void, P, StringResult>;
    isSelected(): Command<boolean, P, StringResult>;
    isEnabled(): Command<boolean, P, StringResult>;
    getSpecAttribute(name: string): Command<StringResult, P, StringResult>;
    getAttribute<S = StringResult>(name: string): Command<S, P, StringResult>;
    getProperty<T = any>(name: string): Command<T, P, StringResult>;
    equals(other: Element): Command<boolean, P, StringResult>;
    isDisplayed(): Command<boolean, P, StringResult>;
    getPosition(): Command<{
        x: number;
        y: number;
    }, P, StringResult>;
    getSize(): Command<{
        width: number;
        height: number;
    }, P, StringResult>;
    getComputedStyle(propertyName: string): Command<StringResult, P, StringResult>;
}
export interface SetContextMethod {
    (context: Element | Element[]): void;
}
export interface Context extends Array<any> {
    isSingle?: boolean;
    depth?: number;
}
