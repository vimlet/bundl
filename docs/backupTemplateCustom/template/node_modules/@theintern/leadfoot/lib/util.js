"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var common_1 = require("@theintern/common");
/**
 * Creates a promise that resolves itself after `ms` milliseconds.
 *
 * @param ms Time until resolution in milliseconds.
 */
function sleep(ms) {
    var timer;
    return new common_1.Task(function (resolve) {
        timer = setTimeout(function () {
            resolve();
        }, ms);
    }, function () { return clearTimeout(timer); });
}
exports.sleep = sleep;
/**
 * Annotates the method with additional properties that provide guidance to
 * [[Command]] about how the method interacts with stored context elements.
 */
function forCommand(fn, properties) {
    return Object.assign(fn, properties);
}
exports.forCommand = forCommand;
/**
 * Get method names, including inherited methods, on an object
 */
function getMethods(obj) {
    return getOwnProperties(obj).filter(function (name) { return typeof obj[name] === 'function'; });
}
exports.getMethods = getMethods;
/**
 * Get all property names for an object, including non-enumerable properties
 */
function getOwnProperties(obj) {
    if (obj === Object.prototype) {
        return [];
    }
    return Object.getOwnPropertyNames(obj).filter(function (name) { return name !== 'constructor' && name.indexOf('__') !== 0; }).concat(getOwnProperties(Object.getPrototypeOf(obj)));
}
exports.getOwnProperties = getOwnProperties;
/**
 * Searches a document or element subtree for links with the given
 * normalized text. This method works for 'link text' and 'partial link
 * text' search strategies.
 *
 * Note that this method should be passed to an `execute` call, not called
 * directly. It has an 'istanbul ignore' comment for this reason.
 *
 * @param using The strategy in use ('link text' or 'partial link text')
 * @param value The link text to search for
 * @param multiple If true, return all matching links
 * @param element A context element
 * @returns The found element or elements
 */
/* istanbul ignore next */
function manualFindByLinkText(using, value, multiple, element) {
    var check = using === 'link text'
        ? function (linkText, text) {
            return linkText === text;
            // tslint:disable-next-line:indent
        }
        : function (linkText, text) {
            return linkText.indexOf(text) !== -1;
            // tslint:disable-next-line:indent
        };
    var links = (element || document).getElementsByTagName('a');
    var linkText;
    var found = [];
    for (var i = 0; i < links.length; i++) {
        // Normalize the link text whitespace
        linkText = links[i].innerText
            .replace(/^\s+/, '')
            .replace(/\s+$/, '')
            .replace(/\s*\r\n\s*/g, '\n')
            .replace(/ +/g, ' ');
        if (check(linkText, value)) {
            if (!multiple) {
                return links[i];
            }
            found.push(links[i]);
        }
    }
    if (multiple) {
        return found;
    }
}
exports.manualFindByLinkText = manualFindByLinkText;
/**
 * Converts a function to a string representation suitable for use with the
 * `execute` API endpoint.
 */
function toExecuteString(fn) {
    if (typeof fn === 'function') {
        // If someone runs code through Istanbul in the test runner, inline
        // functions that are supposed to execute on the client will contain
        // code coverage variables that will cause script execution failure.
        // These statements are very simple and are generated in a consistent
        // manner, so we can get rid of them easily with a regular expression
        fn = fn.toString().replace(/\b__cov_[^,;]+[,;]/g, '');
        fn = 'return (' + fn + ').apply(this, arguments);';
    }
    return fn;
}
exports.toExecuteString = toExecuteString;
/**
 * Removes the first line of a stack trace, which in V8 is the string
 * representation of the object holding the stack trace (which is garbage for
 * captured stack traces).
 */
function trimStack(stack) {
    return stack.replace(/^[^\n]+/, '');
}
exports.trimStack = trimStack;
//# sourceMappingURL=util.js.map