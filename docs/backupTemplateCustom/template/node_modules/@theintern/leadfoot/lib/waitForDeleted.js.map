{"version":3,"file":"waitForDeleted.js","sourceRoot":"","sources":["../../../src/lib/waitForDeleted.ts"],"names":[],"mappings":";;AAAA,4CAA6D;AAC7D,6CAAwC;AAMxC;;;;;;;;;;;;;;;;GAgBG;AACH,SAAwB,cAAc,CACpC,OAAgB,EAChB,OAA0B,EAC1B,KAAe,EACf,KAAa;IAEb,IAAI,eAAuB,CAAC;IAE5B,OAAO,OAAO;SACX,UAAU,CAAC,UAAU,CAAC;SACtB,IAAI,CAAC,UAAA,KAAK;QACT,eAAe,GAAG,KAAK,CAAC;QACxB,OAAO,CAAC,UAAU,CAAC,UAAU,EAAE,CAAC,CAAC,CAAC;IACpC,CAAC,CAAC;SACD,IAAI,CAAC;QACJ,OAAO,IAAI,aAAI,CAAC,UAAC,OAAO,EAAE,MAAM;YAC9B,IAAM,SAAS,GAAG,IAAI,CAAC,GAAG,EAAE,CAAC;YAE7B,CAAC,SAAS,IAAI;gBACZ,IAAI,IAAI,CAAC,GAAG,EAAE,GAAG,SAAS,GAAG,eAAe,EAAE;oBAC5C,IAAM,MAAM,GAAG;wBACb,IAAM,KAAK,GAAQ,IAAI,KAAK,EAAE,CAAC;wBAC/B,KAAK,CAAC,MAAM,GAAG,EAAE,CAAC;wBACZ,IAAA,wCAAkD,EAAjD,YAAI,EAAE,eAA2C,CAAC;wBACzD,KAAK,CAAC,IAAI,GAAG,IAAI,CAAC;wBAClB,KAAK,CAAC,OAAO,GAAG,OAAO,CAAC;wBACxB,MAAM,CAAC,KAAK,CAAC,CAAC;oBAChB,CAAC,CAAC;oBACF,OAAO;yBACJ,UAAU,CAAC,UAAU,EAAE,eAAe,CAAC;yBACvC,IAAI,CAAC,MAAM,EAAE,MAAM,CAAC,CAAC;oBACxB,OAAO;iBACR;gBAED,OAAO,CAAC,IAAI,CAAC,KAAK,EAAE,KAAK,CAAC,CAAC,IAAI,CAAC,IAAI,EAAE,UAAS,KAAK;oBAClD,IAAM,MAAM,GAAG;wBACb,mFAAmF;wBACnF,IAAI,KAAK,CAAC,IAAI,KAAK,eAAe,EAAE;4BAClC,OAAO,EAAE,CAAC;yBACX;6BAAM;4BACL,MAAM,CAAC,KAAK,CAAC,CAAC;yBACf;oBACH,CAAC,CAAC;oBACF,OAAO;yBACJ,UAAU,CAAC,UAAU,EAAE,eAAe,CAAC;yBACvC,IAAI,CAAC,MAAM,EAAE,MAAM,CAAC,CAAC;gBAC1B,CAAC,CAAC,CAAC;YACL,CAAC,CAAC,EAAE,CAAC;QACP,CAAC,CAAC,CAAC;IACL,CAAC,CAAC;SACD,IAAI,CAAC,cAAO,CAAC,CAAC,CAAC;AACpB,CAAC;AAnDD,iCAmDC","sourcesContent":["import { Task, CancellablePromise } from '@theintern/common';\nimport statusCodes from './statusCodes';\nimport Session from '../Session';\nimport Element from '../Element';\n\nimport { Strategy } from './Locator';\n\n/**\n * Waits for all elements findable in the currently active window/frame\n * using the given strategy and value to be destroyed.\n *\n * @param session The session to consider.\n *\n * @param locator The particular instance that will perform the locating.\n *\n * @param using The element retrieval strategy to use. See\n * [[Command.Command.find]] for options.\n *\n * @param value The strategy-specific value to search for. See\n * [[Command.Command.find]] for details.\n *\n * @returns a Task that resolves when no matching elements can be found, or\n * rejects if matching elements still exist after the find timeout.\n */\nexport default function waitForDeleted(\n  session: Session,\n  locator: Session | Element,\n  using: Strategy,\n  value: string\n): CancellablePromise<void> {\n  let originalTimeout: number;\n\n  return session\n    .getTimeout('implicit')\n    .then(value => {\n      originalTimeout = value;\n      session.setTimeout('implicit', 0);\n    })\n    .then(function() {\n      return new Task((resolve, reject) => {\n        const startTime = Date.now();\n\n        (function poll() {\n          if (Date.now() - startTime > originalTimeout) {\n            const always = function() {\n              const error: any = new Error();\n              error.status = 21;\n              const [name, message] = (<any>statusCodes)[error.status];\n              error.name = name;\n              error.message = message;\n              reject(error);\n            };\n            session\n              .setTimeout('implicit', originalTimeout)\n              .then(always, always);\n            return;\n          }\n\n          locator.find(using, value).then(poll, function(error) {\n            const always = function() {\n              /* istanbul ignore else: other errors should never occur during normal operation */\n              if (error.name === 'NoSuchElement') {\n                resolve();\n              } else {\n                reject(error);\n              }\n            };\n            session\n              .setTimeout('implicit', originalTimeout)\n              .then(always, always);\n          });\n        })();\n      });\n    })\n    .then(() => {});\n}\n"]}