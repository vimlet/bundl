{"version":3,"file":"WebSocket.js","sourceRoot":"","sources":["../../../../src/lib/channels/WebSocket.ts"],"names":[],"mappings":"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","sourcesContent":["import { Task, CancellablePromise, global } from '@theintern/common';\n\nimport BaseChannel, { ChannelOptions, Message } from './Base';\nimport { parseUrl } from '../browser/util';\n\nexport default class WebSocketChannel extends BaseChannel {\n  /** Time to wait for response before rejecting a send */\n  timeout!: number;\n\n  protected _socket: WebSocket;\n  protected _sendQueue: {\n    [key: string]:\n      | { resolve: (value: any) => void; reject: (error: Error) => void }\n      | undefined;\n  };\n  protected _ready: CancellablePromise<any>;\n  protected _sequence: number;\n\n  constructor(options: ChannelOptions) {\n    super(options);\n\n    if (this.timeout == null) {\n      this.timeout = 10000;\n    }\n\n    if (!options.port) {\n      throw new Error('A port is required for a WebSocket channel');\n    }\n\n    const url = parseUrl(options.url);\n    const host = url!.hostname;\n    const protocol = url!.protocol === 'https' ? 'wss' : 'ws';\n    this._socket = new global.WebSocket(\n      `${protocol}://${host}:${options.port}`\n    );\n\n    this._ready = new Task((resolve, reject) => {\n      this._socket.addEventListener('open', resolve);\n      this._socket.addEventListener('error', reject);\n    });\n\n    this._socket.addEventListener('message', event => {\n      this._handleMessage(JSON.parse(event.data));\n    });\n\n    this._socket.addEventListener('error', _event => {\n      this._handleError(new Error('WebSocket error'));\n    });\n\n    this._sendQueue = Object.create(null);\n    this._sequence = 1;\n  }\n\n  protected _sendData(name: string, data: any) {\n    return this._ready.then(\n      () =>\n        new Task<void>((resolve, reject) => {\n          const id = String(this._sequence++);\n          const sessionId = this.sessionId;\n          const message: Message = { id, sessionId, name, data };\n\n          this._socket.send(JSON.stringify(message));\n\n          const timer = setTimeout(() => {\n            reject(new Error('Send timed out'));\n          }, this.timeout);\n\n          this._sendQueue[id] = {\n            resolve(data: any) {\n              clearTimeout(timer);\n              resolve(data);\n            },\n            reject(error: Error) {\n              reject(error);\n            }\n          };\n        })\n    );\n  }\n\n  protected _handleMessage(message: any) {\n    const id = message.id;\n    this._sendQueue[id]!.resolve(message);\n    this._sendQueue[id] = undefined;\n  }\n\n  protected _handleError(error: Error) {\n    // Make the _ready task a reject to reject future _sendData calls\n    this._ready = Task.reject(error);\n\n    // Reject any open sends\n    Object.keys(this._sendQueue)\n      .filter(id => this._sendQueue[id] != null)\n      .forEach(id => {\n        this._sendQueue[id]!.reject(error);\n        this._sendQueue[id] = undefined;\n      });\n  }\n}\n"]}