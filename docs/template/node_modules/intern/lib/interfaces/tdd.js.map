{"version":3,"file":"tdd.js","sourceRoot":"","sources":["../../../../src/lib/interfaces/tdd.ts"],"names":[],"mappings":";;;;;;;;;;;IAyBA,4CAA2C;IAC3C,kCAIkB;IAClB,gCAA+C;IAiB/C,SAAgB,KAAK,CAAC,IAAY,EAAE,OAAwB;QAC1D,OAAO,MAAM,CAAC,eAAM,CAAC,MAAM,EAAE,IAAI,EAAE,OAAO,CAAC,CAAC;IAC9C,CAAC;IAFD,sBAEC;IAED,SAAgB,IAAI,CAAC,IAAY,EAAE,IAA4B;QAC7D,IAAI,CAAC,YAAY,EAAE;YACjB,MAAM,IAAI,KAAK,CAAC,wCAAwC,CAAC,CAAC;SAC3D;QACD,YAAY,CAAC,GAAG,CAAC,IAAI,cAAI,CAAC,EAAE,IAAI,MAAA,EAAE,IAAI,MAAA,EAAE,CAAC,CAAC,CAAC;IAC7C,CAAC;IALD,oBAKC;IAED,SAAgB,MAAM,CAAC,EAA6B;QAClD,IAAI,CAAC,YAAY,EAAE;YACjB,MAAM,IAAI,KAAK,CAAC,0DAA0D,CAAC,CAAC;SAC7E;QACD,MAAM,CAAC,YAAY,EAAE,QAAQ,EAAE,EAAG,CAAC,CAAC;IACtC,CAAC;IALD,wBAKC;IAED,SAAgB,KAAK,CAAC,EAA4B;QAChD,IAAI,CAAC,YAAY,EAAE;YACjB,MAAM,IAAI,KAAK,CAAC,0DAA0D,CAAC,CAAC;SAC7E;QACD,MAAM,CAAC,YAAY,EAAE,OAAO,EAAE,EAAG,CAAC,CAAC;IACrC,CAAC;IALD,sBAKC;IAED,SAAgB,UAAU,CAAC,EAAiC;QAC1D,IAAI,CAAC,YAAY,EAAE;YACjB,MAAM,IAAI,KAAK,CAAC,0DAA0D,CAAC,CAAC;SAC7E;QACD,MAAM,CAAC,YAAY,EAAE,YAAY,EAAE,EAAG,CAAC,CAAC;IAC1C,CAAC;IALD,gCAKC;IAED,SAAgB,SAAS,CAAC,EAAgC;QACxD,IAAI,CAAC,YAAY,EAAE;YACjB,MAAM,IAAI,KAAK,CAAC,0DAA0D,CAAC,CAAC;SAC7E;QACD,MAAM,CAAC,YAAY,EAAE,WAAW,EAAE,EAAG,CAAC,CAAC;IACzC,CAAC;IALD,8BAKC;IAED,SAAgB,YAAY,CAAC,QAAkB;QAC7C,OAAO;YACL,KAAK,YAAC,IAAY,EAAE,OAAwB;gBAC1C,OAAO,MAAM,CAAC,QAAQ,EAAE,IAAI,EAAE,OAAO,CAAC,CAAC;YACzC,CAAC;YAED,IAAI,MAAA;YACJ,MAAM,QAAA;YACN,KAAK,OAAA;YACL,UAAU,YAAA;YACV,SAAS,WAAA;SACV,CAAC;IACJ,CAAC;IAZD,oCAYC;IAED,IAAI,YAA0B,CAAC;IAE/B,SAAS,aAAa,CAAC,IAAY,EAAE,OAAwB;QAC3D,IAAM,MAAM,GAAG,YAAa,CAAC;QAE7B,YAAY,GAAG,IAAI,eAAK,CAAC,EAAE,IAAI,MAAA,EAAE,MAAM,QAAA,EAAE,CAAC,CAAC;QAC3C,MAAM,CAAC,GAAG,CAAC,YAAY,CAAC,CAAC;QAEzB,OAAO,CAAC,YAAY,CAAC,CAAC;QAEtB,YAAY,GAAG,MAAM,CAAC;IACxB,CAAC;IAED,SAAS,MAAM,CAAC,QAAkB,EAAE,IAAY,EAAE,OAAwB;QACxE,IAAI,CAAC,YAAY,EAAE;YACjB,QAAQ,CAAC,QAAQ,CAAC,UAAA,MAAM;gBACtB,YAAY,GAAG,MAAM,CAAC;gBACtB,aAAa,CAAC,IAAI,EAAE,OAAO,CAAC,CAAC;gBAC7B,YAAY,GAAG,IAAI,CAAC;YACtB,CAAC,CAAC,CAAC;SACJ;aAAM;YACL,aAAa,CAAC,IAAI,EAAE,OAAO,CAAC,CAAC;SAC9B;IACH,CAAC;IAED,SAAS,MAAM,CACb,KAAY,EACZ,MAAuD,EACvD,QAAwD;QAExD,IAAM,cAAc,GAAG,KAAK,CAAC,MAAM,CAAC,CAAC;QACrC,KAAK,CAAC,MAAM,CAAC,GAAG;YACd,IAAM,IAAI,GAAG,KAAK,CAAC,SAAS,CAAC,KAAK,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC;YACnD,IAAM,cAAc,GAAG,cAAc;gBACnC,CAAC,CAAC,cAAc,CAAC,KAAK,CAAC,KAAK,EAAE,IAAI,CAAC;gBACnC,CAAC,CAAC,SAAS,CAAC;YACd,OAAO,OAAO,CAAC,OAAO,CAAC,cAAc,CAAC,CAAC,IAAI,CAAC;gBAC1C,OAAA,QAAQ,CAAC,KAAK,CAAC,YAAY,EAAE,IAAI,CAAC;YAAlC,CAAkC,CACnC,CAAC;QACJ,CAAC,CAAC;IACJ,CAAC","sourcesContent":["/**\n * This is the TDD interface for registering suites. Typically it will be\n * accessed using [[lib/executors/Executor.Executor.getInterface]], like:\n *\n * ```js\n * const { suite, test } = intern.getInterface('tdd');\n * ```\n *\n * It may also be imported as a module, like\n *\n * ```js\n * import { suite, test } from 'intern/lib/interfaces/tdd';\n * ```\n *\n * Suites are registered using callback functions, and tests can be registered\n * within the suite callbacks.\n *\n * ```js\n * suite('foo', () => {\n *     before(() => { ... });\n *     afterEach(() => { ... });\n *     test('bar', () => { ... });\n *     test('baz', () => { ... });\n * });\n */ /** */\nimport { global } from '@theintern/common';\nimport Suite, {\n  SuiteProperties,\n  SuiteLifecycleFunction,\n  TestLifecycleFunction\n} from '../Suite';\nimport Test, { TestProperties } from '../Test';\nimport { Executor } from '../executors/Executor';\n\nexport interface TddInterface extends TddLifecycleInterface {\n  suite(name: string, factory: TddSuiteFactory): void;\n  test(name: string, test: TestProperties['test']): void;\n}\n\nexport interface TddLifecycleInterface {\n  before(fn: SuiteProperties['before']): void;\n  after(fn: SuiteProperties['after']): void;\n  beforeEach(fn: SuiteProperties['beforeEach']): void;\n  afterEach(fn: SuiteProperties['afterEach']): void;\n}\n\nexport type TddSuiteFactory = (suite: Suite) => void;\n\nexport function suite(name: string, factory: TddSuiteFactory) {\n  return _suite(global.intern, name, factory);\n}\n\nexport function test(name: string, test: TestProperties['test']) {\n  if (!currentSuite) {\n    throw new Error('A test must be declared within a suite');\n  }\n  currentSuite.add(new Test({ name, test }));\n}\n\nexport function before(fn: SuiteProperties['before']) {\n  if (!currentSuite) {\n    throw new Error('A suite lifecycle method must be declared within a suite');\n  }\n  aspect(currentSuite, 'before', fn!);\n}\n\nexport function after(fn: SuiteProperties['after']) {\n  if (!currentSuite) {\n    throw new Error('A suite lifecycle method must be declared within a suite');\n  }\n  aspect(currentSuite, 'after', fn!);\n}\n\nexport function beforeEach(fn: SuiteProperties['beforeEach']) {\n  if (!currentSuite) {\n    throw new Error('A suite lifecycle method must be declared within a suite');\n  }\n  aspect(currentSuite, 'beforeEach', fn!);\n}\n\nexport function afterEach(fn: SuiteProperties['afterEach']) {\n  if (!currentSuite) {\n    throw new Error('A suite lifecycle method must be declared within a suite');\n  }\n  aspect(currentSuite, 'afterEach', fn!);\n}\n\nexport function getInterface(executor: Executor): TddInterface {\n  return {\n    suite(name: string, factory: TddSuiteFactory) {\n      return _suite(executor, name, factory);\n    },\n\n    test,\n    before,\n    after,\n    beforeEach,\n    afterEach\n  };\n}\n\nlet currentSuite: Suite | null;\n\nfunction registerSuite(name: string, factory: TddSuiteFactory) {\n  const parent = currentSuite!;\n\n  currentSuite = new Suite({ name, parent });\n  parent.add(currentSuite);\n\n  factory(currentSuite);\n\n  currentSuite = parent;\n}\n\nfunction _suite(executor: Executor, name: string, factory: TddSuiteFactory) {\n  if (!currentSuite) {\n    executor.addSuite(parent => {\n      currentSuite = parent;\n      registerSuite(name, factory);\n      currentSuite = null;\n    });\n  } else {\n    registerSuite(name, factory);\n  }\n}\n\nfunction aspect(\n  suite: Suite,\n  method: 'before' | 'after' | 'beforeEach' | 'afterEach',\n  callback: SuiteLifecycleFunction | TestLifecycleFunction\n) {\n  const originalMethod = suite[method];\n  suite[method] = function() {\n    const args = Array.prototype.slice.call(arguments);\n    const originalReturn = originalMethod\n      ? originalMethod.apply(suite, args)\n      : undefined;\n    return Promise.resolve(originalReturn).then(() =>\n      callback.apply(currentSuite, args)\n    );\n  };\n}\n"]}