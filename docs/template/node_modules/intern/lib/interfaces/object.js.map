{"version":3,"file":"object.js","sourceRoot":"","sources":["../../../../src/lib/interfaces/object.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * This is the object interface for registering suites. Typically it will be\n * accessed using [[lib/executors/Executor.Executor.getInterface]], like:\n *\n * ```js\n * const { registerSuite } = intern.getInterface('object');\n * ```\n *\n * It may also be imported as a module, like\n *\n * ```js\n * import registerSuite from 'intern/lib/interfaces/object';\n * ```\n *\n * Suites are described using objects. The object structure is a subset of suite\n * properties, specifically name, the lifecycle methods, and tests.\n *\n * ```js\n * registerSuite('foo', {\n *     before() {},\n *     afterEach() {},\n *     tests: {\n *         bar() {},\n *         baz() {}\n *     }\n * });\n * ```\n *\n * Tests may also describe sub-suites:\n *\n * ```js\n * registerSuite('foo', {\n *     tests: {\n *         fooStuff {\n *             tests: {\n *                 bar() {},\n *                 baz() {}\n *             }\n *         }\n *     }\n * });\n * ```\n *\n * Sub-suites don't need name properties, and may also omit the 'tests' nesting\n * if no lifecycle functions are in use. The rule is that if a 'tests' property\n * isn't in the sub-suite object, then every property is assumed to refer to a\n * test.\n *\n * ```js\n * registerSuite('foo', {\n *     fooStuff {\n *         bar() {},\n *         baz() {}\n *     }\n * });\n * ```\n */ /** */\nimport { global } from '@theintern/common';\n\nimport Suite, { SuiteOptions, SuiteProperties } from '../Suite';\nimport Test, { TestFunction, isTestFunction } from '../Test';\nimport { Executor } from '../executors/Executor';\n\n/**\n * Importable interface that uses the currently installed global executor\n */\nexport default function registerSuite(\n  name: string,\n  descriptorOrFactory: ObjectSuiteDescriptor | ObjectSuiteFactory | Tests\n) {\n  return _registerSuite(global.intern, name, descriptorOrFactory);\n}\n\n/**\n * Interface factory used by Executor\n */\nexport function getInterface(executor: Executor) {\n  return {\n    registerSuite(\n      name: string,\n      descriptorOrFactory: ObjectSuiteDescriptor | ObjectSuiteFactory | Tests\n    ) {\n      return _registerSuite(executor, name, descriptorOrFactory);\n    }\n  };\n}\n\nexport interface ObjectInterface {\n  registerSuite(\n    name: string,\n    mainDescriptor: ObjectSuiteDescriptor | ObjectSuiteFactory | Tests\n  ): void;\n}\n\nexport interface Tests {\n  [name: string]: ObjectSuiteDescriptor | TestFunction | Tests;\n}\n\nexport interface ObjectSuiteDescriptor extends Partial<SuiteProperties> {\n  tests: Tests;\n}\n\nexport interface ObjectSuiteFactory {\n  (): ObjectSuiteDescriptor | Tests;\n}\n\nexport function isSuiteDescriptorFactory<T>(value: any): value is T {\n  return typeof value === 'function';\n}\n\nexport function createSuite<S extends typeof Suite, T extends typeof Test>(\n  name: string,\n  parent: Suite,\n  descriptor: ObjectSuiteDescriptor | Tests,\n  SuiteClass: S,\n  TestClass: T\n) {\n  let options: SuiteOptions = { name: name, parent };\n  let tests: Tests;\n\n  // Initialize a new SuiteOptions object from the provided\n  // ObjectSuiteDescriptor\n  if (isObjectSuiteDescriptor(descriptor)) {\n    const keys = Object.keys(descriptor).filter(key => key !== 'tests');\n    for (const key of keys) {\n      let optionsKey = <keyof SuiteOptions>key;\n\n      // Convert 'setup' and 'teardown' to 'before' and 'after'\n      if (key === 'setup') {\n        parent.executor.emit('deprecated', {\n          original: 'Suite#setup',\n          replacement: 'Suite#before'\n        });\n        optionsKey = 'before';\n      } else if (key === 'teardown') {\n        parent.executor.emit('deprecated', {\n          original: 'Suite#teardown',\n          replacement: 'Suite#after'\n        });\n        optionsKey = 'after';\n      }\n\n      options[optionsKey] = <any>descriptor[<keyof ObjectSuiteDescriptor>key];\n    }\n\n    tests = descriptor.tests;\n  } else {\n    tests = descriptor;\n  }\n\n  const suite = new SuiteClass(options);\n\n  Object.keys(tests)\n    .map(name => {\n      if (\n        name === 'before' ||\n        name === 'after' ||\n        name === 'setup' ||\n        name === 'teardown' ||\n        name === 'beforeEach' ||\n        name === 'afterEach'\n      ) {\n        parent.executor.log(\n          `Warning: created test with lifecycle method name \"${name}\"`\n        );\n      }\n\n      const thing = tests[name];\n      if (isTestFunction(thing)) {\n        return new TestClass({ name, test: thing, parent: suite });\n      }\n      return createSuite(name, suite, { ...thing }, SuiteClass, TestClass);\n    })\n    .forEach(suiteOrTest => {\n      suite.add(suiteOrTest);\n    });\n\n  return suite;\n}\n\nfunction isObjectSuiteDescriptor(value: any): value is ObjectSuiteDescriptor {\n  return typeof value === 'object' && typeof value.tests === 'object';\n}\n\nfunction _registerSuite(\n  executor: Executor,\n  name: string,\n  descriptorOrFactory: ObjectSuiteDescriptor | ObjectSuiteFactory | Tests\n) {\n  executor.addSuite(parent => {\n    // Enable per-suite closure, to match feature parity with other\n    // interfaces like tdd/bdd more closely; without this, it becomes\n    // impossible to use the object interface for functional tests since\n    // there is no other way to create a closure for each main suite\n    let descriptor: ObjectSuiteDescriptor | Tests;\n\n    if (isSuiteDescriptorFactory<ObjectSuiteFactory>(descriptorOrFactory)) {\n      descriptor = descriptorOrFactory();\n    } else {\n      descriptor = descriptorOrFactory;\n    }\n\n    parent.add(createSuite(name, parent, descriptor, Suite, Test));\n  });\n}\n"]}