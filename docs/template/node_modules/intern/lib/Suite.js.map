{"version":3,"file":"Suite.js","sourceRoot":"","sources":["../../../src/lib/Suite.ts"],"names":[],"mappings":"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","sourcesContent":["import {\n  Task,\n  CancellablePromise,\n  isPromiseLike,\n  isTask\n} from '@theintern/common';\n\nimport Deferred from './Deferred';\nimport { Executor } from './executors/Executor';\nimport Test, { isTest, SKIP } from './Test';\nimport { InternError } from './types';\nimport { Remote } from './executors/Node';\n\n/**\n * The Suite class manages a group of tests.\n */\nexport default class Suite implements SuiteProperties {\n  /**\n   * An optional method that is run after all the suite's tests have completed\n   */\n  after: SuiteLifecycleFunction | undefined;\n\n  /**\n   * An optional method that is run after each test has completed\n   */\n  afterEach: TestLifecycleFunction | undefined;\n\n  /**\n   * A convenience function that generates and returns a special\n   * [[lib/Deferred.Deferred]] that can be used for asynchronous testing\n   */\n  async: ((timeout?: number) => Deferred<void>) | undefined;\n\n  /**\n   * An optional method that is run before any of this suite's tests are\n   * started\n   */\n  before: SuiteLifecycleFunction | undefined;\n\n  /**\n   * An optional method that is run before each test\n   */\n  beforeEach: TestLifecycleFunction | undefined;\n\n  /** The error that caused this suite to fail */\n  error: InternError | undefined;\n\n  /** This suite's parent Suite */\n  parent: Suite | undefined;\n\n  /**\n   * If true, the suite will emit a suiteStart event after the `before`\n   * callback has finished, and will emit a suiteEnd event before the `after`\n   * callback has finished.\n   */\n  publishAfterSetup = false;\n\n  /** The reason why this suite was skipped */\n  skipped: string | undefined;\n\n  /** The tests or other suites managed by this suite */\n  tests: (Suite | Test)[] = [];\n\n  /** The time required to run all the tests in this suite */\n  timeElapsed: number | undefined;\n\n  private _bail: boolean | undefined;\n  private _executor: Executor | undefined;\n  private _name: string | undefined;\n  private _grep: RegExp | undefined;\n  private _remote: Remote | undefined;\n  private _sessionId: string | undefined;\n  private _timeout: number | undefined;\n\n  /**\n   * @param options an object with default property values\n   */\n  constructor(options: SuiteOptions | RootSuiteOptions) {\n    Object.keys(options)\n      .filter(key => {\n        return key !== 'tests';\n      })\n      .forEach(option => {\n        const key = <keyof (SuiteOptions | RootSuiteOptions)>option;\n        this[key] = options[key]!;\n      });\n\n    if (options.tests) {\n      options.tests.forEach(suiteOrTest => this.add(suiteOrTest));\n    }\n\n    if (!this.name && this.parent) {\n      throw new Error('A non-root Suite must have a name');\n    }\n  }\n\n  /**\n   * A flag used to indicate whether a test run should stop after a failed\n   * test.\n   */\n  get bail() {\n    return this._bail || (this.parent && this.parent.bail)!;\n  }\n\n  set bail(value: boolean) {\n    this._bail = value;\n  }\n\n  /**\n   * The executor used to run this Suite.\n   */\n  get executor(): Executor {\n    // Prefer the parent's executor\n    return (this.parent && this.parent.executor) || this._executor!;\n  }\n\n  set executor(value: Executor) {\n    if (this._executor) {\n      const error = new Error('An executor may only be set once per suite');\n      error.name = 'AlreadyAssigned';\n      throw error;\n    }\n    this._executor = value;\n  }\n\n  /**\n   * A regular expression used to filter, by test ID, which tests are run.\n   */\n  get grep() {\n    return this._grep || (this.parent && this.parent.grep) || /.*/;\n  }\n\n  set grep(value: RegExp) {\n    this._grep = value;\n    this._applyGrepToChildren();\n  }\n\n  /**\n   * This suite's name\n   */\n  get name() {\n    return this._name;\n  }\n\n  set name(value: string | undefined) {\n    this._name = value;\n\n    // If the name of the suite is set then we need to re-run the grep\n    this._applyGrepToChildren();\n  }\n\n  /**\n   * The unique identifier of the suite, assuming all combinations of suite +\n   * test are unique.\n   */\n  get id() {\n    let name: string[] = [];\n    let suite: Suite = this;\n\n    do {\n      suite.name != null && name.unshift(suite.name);\n    } while ((suite = suite.parent!));\n\n    return name.join(' - ');\n  }\n\n  /**\n   * The unique identifier of the suite's parent.\n   */\n  get parentId() {\n    const parent = this.parent;\n    if (parent) {\n      return parent.id;\n    }\n  }\n\n  /**\n   * The WebDriver interface for driving a remote environment. This value is\n   * only guaranteed to exist from the before/beforeEach/afterEach/after and\n   * test methods, since environments are not instantiated until they are\n   * actually ready to be tested against.\n   */\n  get remote() {\n    return this.parent && this.parent.remote\n      ? this.parent.remote\n      : this._remote!;\n  }\n\n  set remote(value: Remote) {\n    if (this._remote) {\n      throw new Error('AlreadyAssigned: remote may only be set once per suite');\n    }\n    this._remote = value;\n  }\n\n  /**\n   * The sessionId of the environment in which the suite executed.\n   */\n  get sessionId(): string {\n    if (this.parent) {\n      return this.parent.sessionId;\n    }\n    if (this._sessionId) {\n      return this._sessionId;\n    }\n    if (this.remote) {\n      return this.remote.session.sessionId;\n    }\n    return '';\n  }\n\n  set sessionId(value: string) {\n    this._sessionId = value;\n  }\n\n  /**\n   * The total number of tests in this suite and any sub-suites. To get only\n   * the number of tests for this suite, look at `this.tests.length`.\n   */\n  get numTests(): number {\n    return this.tests.reduce((numTests, suiteOrTest) => {\n      if (isSuite(suiteOrTest)) {\n        return numTests + suiteOrTest.numTests;\n      }\n      return numTests + 1;\n    }, 0);\n  }\n\n  /**\n   * The total number of tests in this test suite that passed.\n   */\n  get numPassedTests(): number {\n    return this.tests.reduce((numPassedTests, suiteOrTest) => {\n      if (isSuite(suiteOrTest)) {\n        return numPassedTests + suiteOrTest.numPassedTests;\n      } else if (suiteOrTest.hasPassed) {\n        return numPassedTests + 1;\n      }\n      return numPassedTests;\n    }, 0);\n  }\n\n  /**\n   * The total number of tests in this test suite and any sub-suites that\n   * failed.\n   */\n  get numFailedTests(): number {\n    return this.tests.reduce((numFailedTests, suiteOrTest) => {\n      if (isSuite(suiteOrTest)) {\n        return numFailedTests + suiteOrTest.numFailedTests;\n      } else if (suiteOrTest.error) {\n        return numFailedTests + 1;\n      }\n      return numFailedTests;\n    }, 0);\n  }\n\n  /**\n   * The total number of tests in this test suite and any sub-suites that were\n   * skipped.\n   */\n  get numSkippedTests(): number {\n    return this.tests.reduce((numSkippedTests, suiteOrTest) => {\n      if (isSuite(suiteOrTest)) {\n        return numSkippedTests + suiteOrTest.numSkippedTests;\n      } else if (suiteOrTest.skipped) {\n        return numSkippedTests + 1;\n      }\n      return numSkippedTests;\n    }, 0);\n  }\n\n  /**\n   * Whether or not this suite has a parent (for parity with serialized\n   * Suites).\n   */\n  get hasParent() {\n    return Boolean(this.parent);\n  }\n\n  get timeout() {\n    if (this._timeout != null) {\n      return this._timeout;\n    }\n    if (this.parent) {\n      return this.parent.timeout;\n    }\n    return 30000;\n  }\n\n  set timeout(value: number) {\n    this._timeout = value;\n  }\n\n  /**\n   * Add a test or suite to this suite.\n   */\n  add(suiteOrTest: Suite | Test) {\n    if (!isTest(suiteOrTest) && !isSuite(suiteOrTest)) {\n      throw new Error('Tried to add invalid suite or test');\n    }\n\n    if (suiteOrTest.parent != null && suiteOrTest.parent !== this) {\n      throw new Error('This Suite or Test already belongs to another parent');\n    }\n\n    this.tests.forEach(existingSuiteOrTest => {\n      if (existingSuiteOrTest.name === suiteOrTest.name) {\n        throw new Error(\n          `A suite or test named \"${suiteOrTest.name}\" has already been added`\n        );\n      }\n    });\n\n    suiteOrTest.parent = this;\n\n    this.tests.push(suiteOrTest);\n    this._applyGrepToSuiteOrTest(suiteOrTest);\n\n    if (isTest(suiteOrTest)) {\n      this.executor.emit('testAdd', suiteOrTest);\n    } else {\n      this.executor.emit('suiteAdd', suiteOrTest);\n    }\n  }\n\n  private _applyGrepToSuiteOrTest(suiteOrTest: Suite | Test) {\n    if (suiteOrTest instanceof Suite) {\n      suiteOrTest._applyGrepToChildren();\n    } else {\n      const grepSkipReason = 'grep';\n      if (suiteOrTest.skipped === grepSkipReason) {\n        // If the test was previously skipped with a grep clear that it was skipped\n        suiteOrTest.skipped = undefined;\n      }\n\n      if (!this.grep.test(suiteOrTest.id)) {\n        suiteOrTest.skipped = grepSkipReason;\n      }\n    }\n  }\n\n  private _applyGrepToChildren() {\n    this.tests.forEach(suiteOrTest =>\n      this._applyGrepToSuiteOrTest(suiteOrTest)\n    );\n  }\n\n  /**\n   * Runs test suite in order:\n   *\n   * * before\n   * * (for each test)\n   *   * beforeEach\n   *   * test\n   *   * afterEach\n   * * after\n   *\n   * If before, beforeEach, afterEach, or after throw, the suite itself will\n   * be marked as failed and no further tests in the suite will be executed.\n   */\n  run(): CancellablePromise<void> {\n    let startTime: number;\n\n    // Run when the suite starts\n    const start = () => {\n      return this.executor.emit('suiteStart', this).then(function() {\n        startTime = Date.now();\n      });\n    };\n\n    // Run when the suite has ended\n    const end = () => {\n      this.timeElapsed = Date.now() - startTime;\n      return this.executor.emit('suiteEnd', this);\n    };\n\n    // Important to check this outside of the lifecycle as skip may have been\n    // called within a child\n    const allTestsSkipped = this.numTests === this.numSkippedTests;\n\n    // Run the before and after suite lifecycle methods\n    const runLifecycleMethod = (\n      suite: Suite,\n      name: keyof Suite,\n      test?: Test\n    ): CancellablePromise<void> => {\n      let result: PromiseLike<void> | undefined;\n\n      // If we are the root suite with our own executor then we want to run life\n      // cycle functions regardless of whether all tests are skipped\n      if (!this._executor && allTestsSkipped) {\n        // If all descendant tests are skipped then do not run the suite\n        // lifecycles\n        return Task.resolve();\n      }\n\n      return new Task<void>(\n        (resolve, reject) => {\n          let dfd: Deferred<any> | undefined;\n          let timeout: number | undefined;\n\n          // Provide a new Suite#async method for each call of a\n          // lifecycle method since there's no concept of a Suite-wide\n          // async deferred as there is for Tests.\n          suite.async = function(_timeout?: number) {\n            timeout = _timeout;\n\n            const _dfd = new Deferred<any>();\n            dfd = _dfd;\n\n            suite.async = function() {\n              return _dfd;\n            };\n\n            return _dfd;\n          };\n\n          const suiteFunc: SuiteLifecycleFunction = <any>suite[name];\n\n          // Call the lifecycle function. The suite.async method above\n          // may be called within this function call. If `test` is\n          // defined (i.e., this is beforeEach or afterEach), pass it\n          // first, followed by the suite. If `test` is not defined,\n          // just pass the suite. This ordering is maintain backwards\n          // compatibility with previous versions of Intern.\n          result =\n            suiteFunc &&\n            (test\n              ? suiteFunc.call(suite, test, suite)\n              : suiteFunc.call(suite, suite));\n\n          // If dfd is set, it means the async method was called\n          if (dfd) {\n            // Assign to a const so TS knows it's defined\n            const _dfd = dfd;\n\n            // If a timeout was set, async was called, so we should\n            // use the dfd created by the call to manage the\n            // timeout.\n            if (timeout) {\n              let timer = setTimeout(function() {\n                const error = new Error(\n                  `Timeout reached on ${suite.id}#${name}`\n                );\n                error.name = 'TimeoutError';\n                _dfd.reject(error);\n              }, timeout);\n\n              _dfd.promise\n                .catch(_error => {})\n                .then(() => timer && clearTimeout(timer));\n            }\n\n            // If the return value looks like a promise, resolve the\n            // dfd if the return value resolves\n            if (isPromiseLike(result)) {\n              result.then(() => _dfd.resolve(), error => _dfd.reject(error));\n            }\n\n            // Use the dfd.promise as the final result\n            result = dfd.promise;\n          }\n\n          if (isPromiseLike(result)) {\n            result.then(() => resolve(), reject);\n          } else {\n            resolve();\n          }\n        },\n        () => {\n          if (isTask(result)) {\n            result.cancel();\n          }\n        }\n      )\n        .finally(() => {\n          // Remove the async method since it should only be available\n          // within a lifecycle function call\n          suite.async = undefined;\n        })\n        .catch((error: InternError) => {\n          if (error !== SKIP) {\n            if (!this.error) {\n              this.executor.log('Suite errored with non-skip error', error);\n              this.error = error;\n            }\n            throw error;\n          }\n        });\n    };\n\n    // Convenience method to run 'before' suite lifecycle method\n    const before = () => {\n      return runLifecycleMethod(this, 'before');\n    };\n\n    // Convenience method to run the 'after' suite lifecycle method\n    const after = () => {\n      return runLifecycleMethod(this, 'after');\n    };\n\n    // Reset some state in case someone tries to re-run the same suite\n    // TODO: Cancel any previous outstanding suite run\n    // TODO: Test\n    this.error = undefined;\n    this.timeElapsed = 0;\n\n    let task: CancellablePromise<void>;\n    let runTask: CancellablePromise<void>;\n\n    try {\n      task = this.publishAfterSetup\n        ? before().then(start)\n        : start().then(before);\n    } catch (error) {\n      return Task.reject<void>(error);\n    }\n\n    // The task that manages running this suite's tests\n    return task\n      .then(() => {\n        // Run the beforeEach or afterEach methods for a given test in\n        // the proper order based on the current nested Suite structure\n        const runTestLifecycle = (\n          name: keyof Suite,\n          test: Test\n        ): CancellablePromise<void> => {\n          let methodQueue: Suite[] = [];\n          let suite: Suite = this;\n\n          do {\n            if (name === 'beforeEach') {\n              // beforeEach executes in order parent -> child;\n              methodQueue.push(suite);\n            } else {\n              // afterEach executes in order child -> parent\n              methodQueue.unshift(suite);\n            }\n          } while ((suite = suite.parent!));\n\n          let currentMethod: CancellablePromise<any>;\n\n          return new Task(\n            (resolve, reject) => {\n              let firstError: Error;\n\n              const handleError = (error: Error) => {\n                // Note that a SKIP error will only be treated\n                // as a 'skip' when thrown from beforeEach. If\n                // thrown from afterEach it will be a suite\n                // error.\n                if (name === 'afterEach') {\n                  firstError = firstError || error;\n                  next();\n                } else {\n                  reject(error);\n                }\n              };\n\n              const next = () => {\n                const suite = methodQueue.pop();\n\n                if (!suite) {\n                  firstError ? reject(firstError) : resolve();\n                  return;\n                }\n\n                currentMethod = runLifecycleMethod(suite, name, test).then(\n                  next,\n                  handleError\n                );\n              };\n\n              next();\n            },\n            () => {\n              methodQueue.splice(0, methodQueue.length);\n              if (currentMethod) {\n                currentMethod.cancel();\n              }\n            }\n          );\n        };\n\n        let i = 0;\n        let tests = this.tests;\n        let current: CancellablePromise<void>;\n\n        // Run each of the tests in this suite\n        runTask = new Task<void>(\n          (resolve, reject) => {\n            let firstError: Error;\n            let testTask: CancellablePromise<void> | undefined;\n\n            const next = () => {\n              const test = tests[i++];\n\n              // The task is over when there are no more tests to\n              // run\n              if (!test) {\n                firstError ? reject(firstError) : resolve();\n                return;\n              }\n\n              const handleError = (error: InternError) => {\n                // An error may be associated with a deeper test\n                // already, in which case we do not want to\n                // reassociate it with a more generic parent\n                if (error && error.relatedTest == null) {\n                  error.relatedTest = <Test>test;\n                }\n              };\n\n              const runTest = () => {\n                // Errors raised when running child tests should\n                // be reported but should not cause this suite’s\n                // run to reject, since this suite itself has\n                // not failed.\n                const result = test.run().catch(error => {\n                  handleError(error);\n                });\n                testTask = new Task<void>(\n                  resolve => {\n                    result.then(resolve);\n                  },\n                  () => {\n                    result.cancel();\n                  }\n                );\n                return testTask;\n              };\n\n              // If the suite will be skipped, mark the current\n              // test as skipped. This will skip both individual\n              // tests and nested suites.\n              if (this.skipped != null) {\n                test.skipped = this.skipped;\n              }\n\n              // test is a suite\n              if (isSuite(test)) {\n                current = runTest();\n              } else {\n                if (test.skipped != null) {\n                  current = this.executor.emit('testEnd', test);\n                } else {\n                  current = runTestLifecycle('beforeEach', test)\n                    .then(() => {\n                      // A test may have been skipped in a\n                      // beforeEach call\n                      if (test.skipped != null) {\n                        return this.executor.emit('testEnd', test);\n                      } else {\n                        return runTest();\n                      }\n                    })\n                    .finally(() => {\n                      if (testTask) {\n                        testTask.cancel();\n                      }\n                      testTask = undefined;\n                      return runTestLifecycle('afterEach', test);\n                    })\n                    .catch(error => {\n                      firstError = firstError || error;\n                      return handleError(error);\n                    });\n                }\n              }\n\n              current.then(() => {\n                const skipRestOfSuite = () => {\n                  this.skipped =\n                    this.skipped != null ? this.skipped : BAIL_REASON;\n                };\n\n                // If the test was a suite and the suite was\n                // skipped due to bailing, skip the rest of this\n                // suite\n                if (isSuite(test) && test.skipped === BAIL_REASON) {\n                  skipRestOfSuite();\n                } else if (test.error && this.bail) {\n                  // If the test errored and bail mode is\n                  // enabled, skip the rest of this suite\n                  skipRestOfSuite();\n                }\n\n                next();\n              });\n            };\n\n            next();\n          },\n          () => {\n            // Ensure no more tests will run\n            i = Infinity;\n            if (current) {\n              current.cancel();\n            }\n          }\n        );\n\n        return runTask;\n      })\n      .finally(() => {\n        if (runTask) {\n          runTask.cancel();\n        }\n      })\n      .finally(() => (this.publishAfterSetup ? end() : after()))\n      .finally(() => (this.publishAfterSetup ? after() : end()));\n  }\n\n  /**\n   * Skips this suite.\n   *\n   * Calling this function will cause all remaining tests in the suite to be\n   * skipped. If a message was provided, a reporter may report the suite’s\n   * tests as skipped. Skipped tests are not treated as passing or failing.\n   *\n   * If this method is called from a test function (as this.parent.skip()),\n   * the test will be immediately halted, just as if the test’s own skip\n   * method were called.\n   *\n   * @param message If provided, will be stored in this suite's `skipped`\n   * property.\n   */\n  skip(message: string = 'suite skipped') {\n    this.skipped = message;\n    // Use the SKIP constant from Test so that calling Suite#skip from a\n    // test won't fail the test.\n    throw SKIP;\n  }\n\n  toJSON(): object {\n    const json: { [key: string]: any } = {\n      hasParent: Boolean(this.parent),\n      tests: this.tests.map(test => test.toJSON())\n    };\n    const properties: (keyof Suite)[] = [\n      'name',\n      'id',\n      'parentId',\n      'sessionId',\n      'timeElapsed',\n      'numTests',\n      'numPassedTests',\n      'numFailedTests',\n      'numSkippedTests',\n      'skipped'\n    ];\n\n    properties.forEach(key => {\n      const value = this[key];\n      if (typeof value !== 'undefined') {\n        json[key] = value;\n      }\n    });\n\n    if (this.error) {\n      json.error = {\n        name: this.error.name,\n        message: this.error.message,\n        stack: this.error.stack\n      };\n\n      if (this.error.relatedTest && this.error.relatedTest !== <any>this) {\n        // relatedTest can be the Suite itself in the case of nested\n        // suites (a nested Suite's error is caught by a parent Suite,\n        // which assigns the nested Suite as the relatedTest, resulting\n        // in nestedSuite.relatedTest === nestedSuite); in that case,\n        // don't serialize it\n        json.error.relatedTest = this.error.relatedTest.toJSON();\n      }\n    }\n\n    return json;\n  }\n}\n\nexport function isSuite(value: any): value is Suite {\n  return Array.isArray(value.tests) && typeof value.hasParent === 'boolean';\n}\n\nexport interface SuiteLifecycleFunction {\n  (this: Suite, suite: Suite): void | PromiseLike<any>;\n}\n\nexport interface TestLifecycleFunction {\n  (this: Suite, test: Test, suite: Suite): void | PromiseLike<any>;\n}\n\n/**\n * Properties that can be set on a Suite.\n *\n * Note that 'tests' isn't included so that other interfaces, such as the object\n * interface, can use a different definition for it.\n */\nexport interface SuiteProperties {\n  after: SuiteLifecycleFunction | undefined;\n  afterEach: TestLifecycleFunction | undefined;\n  bail: boolean | undefined;\n  before: SuiteLifecycleFunction | undefined;\n  beforeEach: TestLifecycleFunction | undefined;\n  grep: RegExp;\n  name: string | undefined;\n  publishAfterSetup: boolean;\n  timeout: number;\n}\n\n/**\n * Options that can be passed into a Suite constructor to initialize a suite\n */\nexport type SuiteOptions = Partial<SuiteProperties> & {\n  name: string;\n  parent: Suite;\n  tests?: (Suite | Test)[];\n};\n\n/**\n * Options that can be passed into a Suite constructor to initialize a root\n * suite\n */\nexport type RootSuiteOptions = Partial<SuiteProperties> & {\n  executor: Executor;\n  tests?: (Suite | Test)[];\n};\n\n// BAIL_REASON needs to be a string so that Intern can tell when a remote has\n// bailed during unit tests so that it can skip functional tests.\nconst BAIL_REASON = 'bailed';\n"]}