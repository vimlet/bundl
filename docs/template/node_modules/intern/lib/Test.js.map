{"version":3,"file":"Test.js","sourceRoot":"","sources":["../../../src/lib/Test.ts"],"names":[],"mappings":"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","sourcesContent":["import {\n  Task,\n  CancellablePromise,\n  isPromiseLike,\n  isTask\n} from '@theintern/common';\n\nimport { Executor } from './executors/Executor';\nimport Deferred from './Deferred';\nimport { InternError } from './types';\nimport { Remote } from './executors/Node';\nimport Suite from './Suite';\n\n/**\n * A Test is a single unit or functional test.\n */\nexport default class Test implements TestProperties {\n  /** The name of this test */\n  name!: string;\n\n  /** This test's parent Suite */\n  parent!: Suite;\n\n  /** If this test was skipped, this will contain a message indicating why */\n  skipped: string | undefined;\n\n  /** The test function that is run by this Test */\n  test!: TestFunction;\n\n  /** The error that caused this Test to fail */\n  error: InternError | undefined;\n\n  protected _hasPassed = false;\n\n  protected _isAsync = false;\n\n  protected _timeout: number | undefined;\n\n  protected _runTask: CancellablePromise<any> | undefined;\n\n  protected _timeElapsed: number | undefined;\n\n  // Use type 'any' because we may be running under Node (NodeJS.Timer) or a\n  // browser (number)\n  protected _timer: any | undefined;\n\n  protected _usesRemote = false;\n\n  constructor(\n    options: TestOptions & { timeElapsed?: number; hasPassed?: boolean }\n  ) {\n    if (!options.name || !options.test) {\n      throw new Error('A Test requires a name and a test function');\n    }\n\n    ['timeElapsed', 'hasPassed'].forEach(property => {\n      const name = <keyof TestOptions>property;\n      if (options[name] != null) {\n        (<any>this)[`_${name}`] = options[name];\n      }\n      delete options[name];\n    });\n\n    Object.assign(this, options);\n  }\n\n  /**\n   * The executor running this test.\n   */\n  get executor(): Executor {\n    return this.parent && this.parent.executor;\n  }\n\n  /**\n   * True if the test function completed successfully\n   */\n  get hasPassed() {\n    return this._hasPassed;\n  }\n\n  /**\n   * The unique identifier of the test, assuming all combinations of suite +\n   * test are unique.\n   */\n  get id() {\n    let name: string[] = [];\n    let suiteOrTest: Suite | Test = this;\n\n    do {\n      suiteOrTest.name != null && name.unshift(suiteOrTest.name);\n    } while ((suiteOrTest = suiteOrTest.parent));\n\n    return name.join(' - ');\n  }\n\n  /**\n   * If true, this Test's test function is async\n   */\n  get isAsync() {\n    return this._isAsync;\n  }\n\n  /**\n   * The unique identifier of the test's parent.\n   */\n  get parentId() {\n    return this.parent.id;\n  }\n\n  /**\n   * The WebDriver interface for driving a remote environment.\n   * @see Suite#remote\n   */\n  get remote(): Remote {\n    this._usesRemote = true;\n    return this.parent.remote;\n  }\n\n  /**\n   * An identifier for the test session this Test is running in.\n   */\n  get sessionId() {\n    return this.parent.sessionId;\n  }\n\n  /**\n   * The number of milliseconds the test function took to complete.\n   */\n  get timeElapsed() {\n    return this._timeElapsed;\n  }\n\n  /**\n   * The number of milliseconds this test can run before it will be canceled.\n   */\n  get timeout() {\n    if (this._timeout != null) {\n      return this._timeout;\n    }\n    if (this.parent && this.parent.timeout != null) {\n      return this.parent.timeout;\n    }\n    return 30000;\n  }\n\n  set timeout(value) {\n    this._timeout = value;\n  }\n\n  /**\n   * This is a convenience function that generates and returns a special\n   * [[lib/Deferred.Deferred]] that can be used for asynchronous testing.\n   *\n   * Once this method is called, a test is assumed to be asynchronous no\n   * matter its return value (the generated Deferred's promise will always be\n   * used as the implied return value if a promise is not returned by the test\n   * function).\n   *\n   * The optional `numCallsUntilResolution` argument to `async` affects how the\n   * callback method operates. By default, the Deferred is resolved (assuming\n   * it hasnâ€™t already been rejected) the first time the function returned by\n   * `callback` is called. If `numCallsUntilResolution` is set (it must be a\n   * value > 0), the function returned by `callback` must be called\n   * `numCallsUntilResolution` times before the Deferred resolves.\n   *\n   * @param timeout If provided, the amount of time to wait before rejecting\n   * the test with a timeout error, in milliseconds.\n   * @param numCallsUntilResolution The number of times that resolve needs to\n   * be called before the Deferred is actually resolved.\n   * @returns a lib/Deferred that can be used to resolve the test\n   */\n  async(timeout?: number, numCallsUntilResolution?: number): Deferred<any> {\n    this._isAsync = true;\n\n    if (timeout != null) {\n      this.timeout = timeout;\n    }\n\n    let remainingCalls = numCallsUntilResolution || 1;\n    const dfd = new Deferred();\n    const oldResolve = dfd.resolve;\n\n    /**\n     * Eventually resolves the deferred, once `resolve` has been called as\n     * many times as specified by the `numCallsUntilResolution` parameter of\n     * the original `async` call.\n     */\n    dfd.resolve = function(this: any) {\n      --remainingCalls;\n      if (remainingCalls === 0) {\n        oldResolve.apply(this, arguments);\n      } else if (remainingCalls < 0) {\n        throw new Error('resolve called too many times');\n      }\n    };\n\n    // A test may call this function multiple times and should always get\n    // the same Deferred\n    this.async = function() {\n      return dfd;\n    };\n\n    return dfd;\n  }\n\n  /**\n   * During an asynchronous test run, restarts the timeout timer.\n   */\n  restartTimeout(timeout?: number) {\n    if (timeout != null) {\n      this.timeout = timeout;\n    }\n\n    if (this._runTask) {\n      if (this._timer) {\n        clearTimeout(this._timer);\n      }\n      this._timer = setTimeout(() => {\n        this._timer = undefined;\n        if (this._runTask) {\n          const error = new Error(`Timeout reached on ${this.id}#`);\n          error.name = 'TimeoutError';\n          this.error = error;\n          this._runTask.cancel();\n        }\n      }, this.timeout);\n    }\n  }\n\n  /**\n   * Runs the test.\n   */\n  run() {\n    let startTime: number;\n\n    // Cancel any currently running test\n    if (this._runTask) {\n      this._runTask.cancel();\n      this._runTask = undefined;\n    }\n\n    if (this._timer) {\n      clearTimeout(this._timer);\n      this._timer = undefined;\n    }\n\n    // Reset some state in case someone tries to re-run the same test\n    this._usesRemote = false;\n    this._hasPassed = false;\n    this._isAsync = false;\n    this._timeElapsed = 0;\n    this._runTask = undefined;\n    this.async = Object.getPrototypeOf(this).async;\n    this.error = undefined;\n    this.skipped = undefined;\n\n    return this.executor\n      .emit('testStart', this)\n      .then(() => {\n        startTime = Date.now();\n      })\n      .then<void>(() => {\n        let result: PromiseLike<any> | void = this.test(this);\n\n        // Someone called `this.async`, so this test is async; we have\n        // to prefer one or the other, so prefer the promise returned\n        // from the test function if it exists, otherwise get the one\n        // that was generated by `Test#async`\n        if (this.isAsync) {\n          if (!isPromiseLike(result)) {\n            result = this.async().promise;\n          } else {\n            // If the user called this.async and returned a\n            // thenable, wait for the first one to resolve or\n            // reject.\n            result = Task.race([this.async().promise, result]);\n          }\n        }\n\n        if (isPromiseLike(result)) {\n          // Even if a user did not call `this.async`, we still mark\n          // this test as asynchronous if a promise was returned\n          this._isAsync = true;\n\n          // Wrap the runTask in another Task so that a canceled test\n          // can be treated like a skip.\n          return new Task((resolve, reject) => {\n            this._runTask = new Task(\n              (resolve, reject) => {\n                let settled = false;\n\n                if (isPromiseLike(result)) {\n                  result.then(\n                    () => {\n                      settled = true;\n                      resolve();\n                    },\n                    error => {\n                      settled = true;\n                      reject(error);\n                    }\n                  );\n                }\n\n                // Most promise implementations that allow\n                // cancellation don't signal that a promise was\n                // canceled. In order to ensure that a timed out\n                // test is never accidentally resolved, reject a\n                // canceled test, treating it as a skipped test.\n                if (isTask(result)) {\n                  result\n                    // Reject with SKIP in case we got here\n                    // before the promise resolved\n                    .finally(() => {\n                      if (!settled) {\n                        this.skipped = 'Canceled';\n                        reject(SKIP);\n                      }\n                    })\n                    // If the result rejected, consume the\n                    // error; it's handled above\n                    .catch(_error => {});\n                }\n              },\n              () => {\n                // Only cancel the result if it's actually a\n                // Task\n                if (isTask(result)) {\n                  result.cancel();\n                }\n                // If the test task was canceled between the\n                // time it failed and the time it resolved,\n                // reject it\n                if (this.error) {\n                  reject(this.error);\n                }\n              }\n            ).then(() => {\n              resolve();\n            }, reject);\n\n            this.restartTimeout();\n          });\n        }\n      })\n      .finally(() => {\n        // If we got here but the test task hasn't finished, the test\n        // was canceled\n        if (this._runTask) {\n          this._runTask.cancel();\n        }\n\n        this._runTask = undefined;\n        this._timeElapsed = Date.now() - startTime;\n\n        // Ensure the timeout timer is cleared so the testing process\n        // doesn't hang at exit\n        if (this._timer) {\n          clearTimeout(this._timer);\n          this._timer = undefined;\n        }\n      })\n      .then(() => {\n        // Test completed successfully -- potentially passed\n        if (this._usesRemote && !this.isAsync) {\n          throw new Error(\n            'Remote used in synchronous test! Tests using this.remote must ' +\n              'return a promise or resolve a this.async deferred.'\n          );\n        }\n        this._hasPassed = true;\n      })\n      .catch(error => {\n        // There was an error running the test; could be a skip, could\n        // be an assertion failure\n        if (error !== SKIP) {\n          this.error = error;\n          throw error;\n        }\n      })\n      .finally(() => this.executor.emit('testEnd', this));\n  }\n\n  /**\n   * Skips this test.\n   *\n   * Calling this function will cause a test to halt immediately. If a message\n   * was provided, a reporter may report the test as skipped. Skipped tests\n   * are not treated as passing or failing.\n   *\n   * @param message If provided, will be stored in this test's `skipped`\n   * property.\n   */\n  skip(message: string = 'skipped') {\n    this.skipped = message;\n    throw SKIP;\n  }\n\n  /**\n   * Return a JSON-representation of this test\n   */\n  toJSON() {\n    const json: { [key: string]: any } = {};\n    const properties: (keyof Test)[] = [\n      'id',\n      'parentId',\n      'name',\n      'sessionId',\n      'timeElapsed',\n      'timeout',\n      'hasPassed',\n      'skipped'\n    ];\n\n    properties.forEach(key => {\n      const value = this[key];\n      if (typeof value !== 'undefined') {\n        json[key] = value;\n      }\n    });\n\n    if (this.error) {\n      json.error = {\n        name: this.error.name,\n        message: this.error.message,\n        stack: this.error.stack,\n        showDiff: Boolean(this.error.showDiff)\n      };\n\n      if (this.error.showDiff) {\n        json.error.actual = this.error.actual;\n        json.error.expected = this.error.expected;\n      }\n    }\n\n    return json;\n  }\n}\n\nexport function isTest(value: any): value is Test {\n  return (\n    value != null &&\n    typeof value.test === 'function' &&\n    typeof value.hasPassed === 'boolean'\n  );\n}\n\nexport function isTestOptions(value: any): value is TestOptions {\n  return (\n    value != null &&\n    !(value instanceof Test) &&\n    value.name != null &&\n    value.test != null\n  );\n}\n\nexport interface TestFunction {\n  (this: Test, test: Test): void | PromiseLike<any>;\n}\n\nexport function isTestFunction(value: any): value is TestFunction {\n  return typeof value === 'function';\n}\n\nexport interface TestProperties {\n  hasPassed: boolean;\n  name: string;\n  parent: Suite;\n  skipped: string | undefined;\n  test: TestFunction;\n  timeout: number;\n}\n\nexport type TestOptions = Partial<TestProperties> & {\n  name: string;\n  test: TestFunction;\n};\n\nexport const SKIP: any = {};\n"]}