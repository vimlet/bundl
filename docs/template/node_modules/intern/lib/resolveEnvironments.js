(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports", "tslib", "path", "./node/process", "./Environment"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require("tslib");
    var path_1 = require("path");
    var process_1 = require("./node/process");
    var Environment_1 = require("./Environment");
    function resolveEnvironments(capabilities, environments, available) {
        environments = environments.map(expandPwd);
        var flatEnvironments = createPermutations(capabilities, environments);
        var expandedEnvironments = flatEnvironments.map(function (environment) {
            var version = resolveVersions(environment, available);
            if (version == null) {
                return environment;
            }
            return Object.assign({}, environment, { version: version });
        });
        return createPermutations({}, expandedEnvironments).map(function (environment) {
            return new Environment_1.default(environment);
        });
    }
    exports.default = resolveEnvironments;
    function expandPwd(value) {
        if (value == null) {
            return value;
        }
        if (typeof value === 'string' && /{pwd}/.test(value)) {
            return path_1.normalize(value.replace(/{pwd}/g, process_1.default.cwd()));
        }
        if (Array.isArray(value)) {
            return value.map(expandPwd);
        }
        if (typeof value === 'object') {
            return Object.keys(value).reduce(function (newObj, key) {
                var _a;
                return (tslib_1.__assign({}, newObj, (_a = {}, _a[key] = expandPwd(value[key]), _a)));
            }, {});
        }
        return value;
    }
    function expandVersionRange(left, right, availableVersions) {
        if (availableVersions.indexOf(left) === -1 ||
            availableVersions.indexOf(right) === -1) {
            throw new Error('The version range ' + left + '..' + right + ' is unavailable');
        }
        return availableVersions.filter(function (version) {
            return version >= left && version <= right;
        });
    }
    function resolveVersionAlias(version, availableVersions) {
        var pieces = version.split('-');
        if (pieces.length > 2) {
            throw new Error('Invalid alias syntax "' + version + '"');
        }
        pieces = pieces.map(function (piece) {
            return piece.trim();
        });
        if ((pieces.length === 2 &&
            (pieces[0] !== 'latest' || isNaN(Number(pieces[1])))) ||
            (pieces.length === 1 && isNaN(Number(pieces[0])) && pieces[0] !== 'latest')) {
            throw new Error('Invalid alias syntax "' + version + '"');
        }
        if (pieces[0] === 'latest') {
            var numericVersions = availableVersions
                .filter(function (version) {
                return !isNaN(Number(version));
            })
                .sort(function (a, b) {
                return Number(a) - Number(b);
            });
            var offset = pieces.length === 2 ? Number(pieces[1]) : 0;
            if (offset > numericVersions.length) {
                var message = "Can't get " + version + '; ' + numericVersions.length + ' version';
                message +=
                    (numericVersions.length !== 1 ? 's are' : ' is') + ' available';
                throw new Error(message);
            }
            return numericVersions[numericVersions.length - 1 - offset];
        }
        else {
            return pieces[0];
        }
    }
    function splitVersions(versionSpec) {
        var versions = versionSpec.split('..');
        if (versions.length > 2) {
            throw new Error('Invalid version syntax');
        }
        return versions.map(function (version) {
            return version.trim();
        });
    }
    function getVersions(environment, available) {
        var versions = {};
        available
            .filter(function (availableEnvironment) {
            return !Object.keys(environment)
                .filter(function (key) { return key !== 'version'; })
                .some(function (envKey) {
                var key = envKey;
                return (key in availableEnvironment &&
                    availableEnvironment[key] !== environment[key]);
            });
        })
            .forEach(function (availableEnvironment) {
            versions[availableEnvironment.version] = true;
        });
        return Object.keys(versions).sort(function (a, b) {
            var na = Number(a);
            var nb = Number(b);
            if (!isNaN(na) && !isNaN(nb)) {
                return na - nb;
            }
            if (a < b) {
                return -1;
            }
            if (a > b) {
                return 1;
            }
            return 0;
        });
    }
    function resolveVersions(environment, available) {
        var versionSpec = environment.version;
        var versions;
        available = available || [];
        if (versionSpec && isNaN(Number(versionSpec))) {
            var availableVersions_1 = getVersions(environment, available);
            versions = splitVersions(versionSpec).map(function (version) {
                var resolved = resolveVersionAlias(version, availableVersions_1);
                if (resolved == null) {
                    throw new Error("Unable to resolve version \"" + version + "\" for " + environment.browserName + ". Are you using the " +
                        'proper browser and platform names for the tunnel?');
                }
                return resolved;
            });
            if (versions.length === 2) {
                if (versions[0] > versions[1]) {
                    throw new Error('Invalid range [' + versions + '], must be in ascending order');
                }
                versions = expandVersionRange(versions[0], versions[1], availableVersions_1);
            }
            return versions;
        }
        return versionSpec;
    }
    function createPermutations(base, sources) {
        if (!sources || sources.length === 0) {
            return [Object.assign({}, base)];
        }
        return sources
            .map(function (source) {
            return Object.keys(source).reduce(function (permutations, key) {
                if (Array.isArray(source[key])) {
                    permutations = source[key]
                        .map(function (value) {
                        return permutations.map(function (permutation) {
                            var _a;
                            return Object.assign({}, permutation, (_a = {}, _a[key] = value, _a));
                        });
                    })
                        .reduce(function (newPermutations, keyPermutations) {
                        return newPermutations.concat(keyPermutations);
                    }, []);
                }
                else {
                    permutations.forEach(function (permutation) {
                        permutation[key] = source[key];
                    });
                }
                return permutations;
            }, [Object.assign({}, base)]);
        })
            .reduce(function (newPermutations, sourcePermutations) {
            return newPermutations.concat(sourcePermutations);
        }, []);
    }
});
//# sourceMappingURL=resolveEnvironments.js.map