(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports", "tslib", "@theintern/common", "lodash", "platform", "benchmark", "./Test"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require("tslib");
    var common_1 = require("@theintern/common");
    var _ = require("lodash");
    var platform = require("platform");
    var Benchmark = require("benchmark");
    var Test_1 = require("./Test");
    Benchmark.runInContext({ _: _, platform: platform });
    var BenchmarkTest = (function (_super) {
        tslib_1.__extends(BenchmarkTest, _super);
        function BenchmarkTest(descriptor) {
            var _this = this;
            var args = {};
            Object.keys(descriptor).forEach(function (descriptorKey) {
                var key = descriptorKey;
                switch (key) {
                    case 'options':
                        break;
                    default:
                        args[key] = descriptor[key];
                }
            });
            args.test = args.test || function () { };
            _this = _super.call(this, args) || this;
            var options = Object.assign({}, _this.test.options || {}, {
                async: true,
                setup: createLifecycle(true),
                teardown: createLifecycle(false)
            });
            if (options.defer) {
                _this.test = (function (testFunction) {
                    return (function (deferred) {
                        var dfd = createDeferred(this.benchmark, deferred, options.numCallsUntilResolution);
                        testFunction.call(this, dfd);
                    });
                })(_this.test);
            }
            _this.benchmark = new Benchmark(descriptor.name, options.defer
                ? 'this.benchmark.internTest.test(deferred);'
                : 'this.internTest.test();', options);
            Object.defineProperty(_this.benchmark, 'name', {
                get: function () {
                    return _this.name;
                },
                set: function (name) {
                    _this.name = name;
                }
            });
            _this.benchmark.internTest = _this;
            return _this;
        }
        Object.defineProperty(BenchmarkTest.prototype, "timeElapsed", {
            get: function () {
                if (this.benchmark && this.benchmark.times) {
                    return this.benchmark.times.elapsed;
                }
                return 0;
            },
            set: function (_value) {
            },
            enumerable: true,
            configurable: true
        });
        BenchmarkTest.prototype.async = function (_timeout, _numCallsUntilResolution) {
            throw new Error('Benchmark tests must be marked as asynchronous and use the deferred ' +
                'passed to them rather than call `this.async()`.');
        };
        BenchmarkTest.prototype.run = function () {
            var _this = this;
            this._hasPassed = false;
            this._usesRemote = false;
            var benchmark = this.benchmark;
            return new common_1.Task(function (resolve, reject) {
                benchmark.on('abort', function () {
                    reject(benchmark.error);
                });
                benchmark.on('error', function () {
                    if (benchmark.error === Test_1.SKIP) {
                        resolve();
                    }
                    else {
                        reject(benchmark.error);
                    }
                });
                benchmark.on('complete', function () {
                    resolve();
                });
                _this.executor.emit('testStart', _this).then(function () {
                    benchmark.run();
                });
            }, function () {
                benchmark.abort();
            })
                .finally(function () {
                benchmark.off();
            })
                .then(function () {
                _this._hasPassed = true;
            }, function (error) {
                _this.error = error;
                throw error;
            })
                .finally(function () { return _this.executor.emit('testEnd', _this); });
        };
        BenchmarkTest.prototype.toJSON = function () {
            var json = _super.prototype.toJSON.call(this);
            var benchmark = this.benchmark;
            json.benchmark = {
                hz: benchmark.hz,
                times: benchmark.times,
                stats: benchmark.stats
            };
            return json;
        };
        BenchmarkTest.async = function (testFunction, numCallsUntilResolution) {
            testFunction.options = Object.assign({}, testFunction.options || {}, {
                defer: true,
                numCallsUntilResolution: numCallsUntilResolution
            });
            return testFunction;
        };
        return BenchmarkTest;
    }(Test_1.default));
    exports.default = BenchmarkTest;
    function isBenchmarkTest(value) {
        return value && value.benchmark != null && Test_1.isTest(value);
    }
    exports.isBenchmarkTest = isBenchmarkTest;
    var createLifecycle = function (before) {
        var queueName = before ? 'Before' : 'After';
        var queueMethod = before ? 'push' : 'unshift';
        var methodName = before ? 'before' : 'after';
        return [
            '(function (benchmark) {',
            "\tvar queue = benchmark.intern" + queueName + "EachLoopQueue;",
            '	var suite;',
            '	if (!queue) {',
            '		suite = benchmark.internTest;',
            "\t\tbenchmark.intern" + queueName + "EachLoopQueue = queue = [];",
            '		while ((suite = suite.parent)) {',
            "\t\t\tif (suite." + methodName + "EachLoop) {",
            "\t\t\t\tqueue." + queueMethod + "(suite);",
            '			}',
            '		}',
            '	}',
            '	var i = queue.length;',
            '	while((suite = queue[--i])) {',
            "\t\tsuite." + methodName + "EachLoop();",
            '	}',
            '})(this.benchmark || this);\n'
        ].join('\n');
    };
    function createDeferred(benchmark, deferred, numCallsUntilResolution) {
        var remainingCalls = numCallsUntilResolution || 1;
        return {
            resolve: function () {
                --remainingCalls;
                if (remainingCalls === 0) {
                    deferred.resolve();
                }
                else if (remainingCalls < 0) {
                    throw new Error('resolve called too many times');
                }
            },
            reject: function (error) {
                benchmark.error = error;
                benchmark.abort();
                deferred.resolve();
            },
            rejectOnError: function (callback) {
                var self = this;
                return function () {
                    try {
                        return callback.apply(this, arguments);
                    }
                    catch (error) {
                        self.reject(error);
                    }
                };
            },
            callback: function (callback) {
                var self = this;
                return this.rejectOnError(function () {
                    var returnValue = callback.apply(this, arguments);
                    self.resolve();
                    return returnValue;
                });
            }
        };
    }
});
//# sourceMappingURL=BenchmarkTest.js.map