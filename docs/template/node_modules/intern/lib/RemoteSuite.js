(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports", "tslib", "url", "path", "querystring", "@theintern/common", "./Suite", "./common/util", "./Deferred"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require("tslib");
    var url_1 = require("url");
    var path_1 = require("path");
    var querystring_1 = require("querystring");
    var common_1 = require("@theintern/common");
    var Suite_1 = require("./Suite");
    var util_1 = require("./common/util");
    var Deferred_1 = require("./Deferred");
    var RemoteSuite = (function (_super) {
        tslib_1.__extends(RemoteSuite, _super);
        function RemoteSuite(options) {
            var _this = this;
            options = options || {};
            if (options.name == null) {
                options.name = 'remote unit tests';
            }
            _this = _super.call(this, options) || this;
            if (_this.timeout == null) {
                _this.timeout = Infinity;
            }
            return _this;
        }
        Object.defineProperty(RemoteSuite.prototype, "id", {
            get: function () {
                var name = [];
                var suite = this.parent;
                do {
                    suite.name != null && name.unshift(suite.name);
                } while ((suite = suite.parent));
                return name.join(' - ');
            },
            enumerable: true,
            configurable: true
        });
        RemoteSuite.prototype.run = function () {
            var _this = this;
            var remote = this.remote;
            var sessionId = remote.session.sessionId;
            var server = this.executor.server;
            var listenerHandle;
            var connectTimer;
            return new common_1.Task(function (resolve, reject) {
                var handleError = function (error) {
                    _this.error = error;
                    reject(error);
                };
                var config = _this.executor.config;
                var pendingConnection = new Deferred_1.default();
                var connectTimeout = config.connectTimeout;
                connectTimer = global.setTimeout(function () {
                    var error = new Error('Timed out waiting for remote to connect');
                    error.name = 'TimeoutError';
                    pendingConnection.reject(error);
                }, connectTimeout);
                listenerHandle = server.subscribe(sessionId, function (eventName, data) {
                    var _a;
                    var name = eventName;
                    var suite;
                    switch (name) {
                        case 'remoteStatus':
                            if (data === 'initialized') {
                                clearTimeout(connectTimer);
                                pendingConnection.resolve();
                            }
                            break;
                        case 'suiteStart':
                            suite = data;
                            if (!suite.hasParent) {
                                (_a = _this.tests).push.apply(_a, suite.tests);
                                return _this.executor.emit('suiteStart', _this);
                            }
                            else {
                                return _this.executor.emit(name, data);
                            }
                        case 'suiteEnd':
                            suite = data;
                            _this.skipped = suite.skipped;
                            if (!suite.hasParent) {
                                suite.tests.forEach(function (test, index) {
                                    _this.tests[index] = test;
                                });
                                if (suite.error) {
                                    handleError(suite.error);
                                }
                            }
                            else {
                                return _this.executor.emit(name, data);
                            }
                            break;
                        case 'beforeRun':
                        case 'afterRun':
                        case 'runStart':
                            break;
                        case 'runEnd':
                            var promise = remote.setHeartbeatInterval(0);
                            if (_this.executor.hasCoveredFiles) {
                                promise = promise.get('about:blank');
                            }
                            return promise.then(resolve, reject);
                        case 'error':
                            if (!/One or more suite errors/.test(data.message)) {
                                handleError(data);
                            }
                            break;
                        default:
                            return _this.executor.emit(name, data);
                    }
                });
                var serverUrl = url_1.parse(config.serverUrl);
                var timeout = config.heartbeatInterval;
                if (timeout >= 1 && timeout < Infinity) {
                    remote.setHeartbeatInterval((timeout - 1) * 1000);
                }
                var queryOptions = {
                    basePath: serverUrl.pathname,
                    runInSync: config.runInSync || false,
                    serverUrl: serverUrl.href,
                    sessionId: sessionId,
                    socketPort: server.socketPort
                };
                var queryParams = {};
                Object.keys(queryOptions)
                    .filter(function (option) {
                    var key = option;
                    return queryOptions[key] != null;
                })
                    .forEach(function (option) {
                    var key = option;
                    var value = queryOptions[key];
                    if (typeof value === 'object') {
                        value = JSON.stringify(value);
                    }
                    queryParams[key] = value;
                });
                var query = querystring_1.stringify(queryParams);
                var harness = config.serverUrl + "__intern/browser/remote.html";
                var internPath = path_1.relative(config.basePath, config.internPath);
                var remoteConfig = {
                    debug: config.debug,
                    internPath: "" + serverUrl.pathname + internPath,
                    name: _this.id,
                    reporters: [{ name: 'dom' }]
                };
                var excludeKeys = {
                    basePath: true,
                    internPath: true,
                    name: true,
                    reporters: true,
                    serverUrl: true,
                    sessionId: true,
                    socketPort: true
                };
                Object.keys(config)
                    .filter(function (key) { return !excludeKeys[key]; })
                    .forEach(function (property) {
                    var key = property;
                    remoteConfig[key] = config[key];
                });
                _this.executor.log('Configuring remote "', _this.name, '" with', remoteConfig);
                remote
                    .get(harness + "?" + query)
                    .then(function () { return pendingConnection.promise; })
                    .execute(function (configString) {
                    var options = JSON.parse(configString);
                    intern.configure(options);
                    intern.run().catch(function (_error) { });
                }, [util_1.stringify(remoteConfig)])
                    .catch(function (error) {
                    return remote.setHeartbeatInterval(0).finally(function () { return handleError(error); });
                });
            }, function () { return remote.setHeartbeatInterval(0); })
                .catch(function (error) {
                if (!_this.error) {
                    _this.error = error;
                }
                throw error;
            })
                .finally(function () {
                if (connectTimer) {
                    clearTimeout(connectTimer);
                }
                listenerHandle.destroy();
            })
                .finally(function () { return _this.executor.emit('suiteEnd', _this); });
        };
        return RemoteSuite;
    }(Suite_1.default));
    exports.default = RemoteSuite;
});
//# sourceMappingURL=RemoteSuite.js.map