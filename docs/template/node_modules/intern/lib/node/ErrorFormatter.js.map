{"version":3,"file":"ErrorFormatter.js","sourceRoot":"","sources":["../../../../src/lib/node/ErrorFormatter.ts"],"names":[],"mappings":"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","sourcesContent":["import { readFileSync } from 'fs';\nimport { dirname, join, relative, resolve } from 'path';\nimport { MappingItem, SourceMapConsumer } from 'source-map';\n\nimport ErrorFormatter from '../common/ErrorFormatter';\nimport { readSourceMap } from './util';\nimport Node from '../executors/Node';\n\nexport default class NodeErrorFormatter extends ErrorFormatter {\n  readonly executor!: Node;\n\n  private fileSourceMaps: { [path: string]: SourceMapConsumer } = {};\n  private fileSources: { [path: string]: string } = {};\n\n  constructor(executor: Node) {\n    super(executor);\n  }\n\n  /**\n   * Dereference the source from a traceline.\n   */\n  protected _getSource(tracepath: string) {\n    if (tracepath === '<anonymous>') {\n      return 'anonymous';\n    }\n\n    let sourcepath = this._getSourceHelper(tracepath);\n    while (sourcepath !== tracepath) {\n      tracepath = sourcepath;\n      sourcepath = this._getSourceHelper(tracepath);\n    }\n\n    return tracepath;\n  }\n\n  private _getSourceHelper(tracepath: string) {\n    let match: RegExpMatchArray | null;\n    let source: string | undefined;\n    let line: number;\n    let col: number | undefined;\n    let map: SourceMapConsumer | undefined;\n    let originalPos: { source?: string; line: number; column?: number };\n    let result: string;\n\n    if (!(match = /^(.*?):(\\d+)(:\\d+)?$/.exec(tracepath))) {\n      // no line or column data\n      return tracepath;\n    }\n\n    tracepath = match[1];\n    line = Number(match[2]);\n    col = match[3] ? Number(match[3].substring(1)) : undefined;\n\n    // If the tracepath starts with the server URL, resolve it to something\n    // local\n    if (tracepath.indexOf(this.executor.config.serverUrl) === 0) {\n      tracepath = tracepath.slice(this.executor.config.serverUrl.length);\n      tracepath = tracepath.replace(\n        /^__intern\\//,\n        this.executor.config.internPath\n      );\n    }\n\n    // Make the tracepath absolute since that's how it will be stored in map\n    // stores\n    tracepath = resolve(tracepath);\n\n    const instrumentedStore = this.executor.instrumentedMapStore;\n\n    // first, check for an instrumentation source map\n    if (tracepath in instrumentedStore.data) {\n      map = new SourceMapConsumer(instrumentedStore.data[tracepath].data);\n      originalPos = this.getOriginalPosition(map, line, col);\n      line = originalPos.line;\n      col = originalPos.column;\n      if (originalPos.source) {\n        source = originalPos.source;\n      }\n    }\n\n    source = source || tracepath;\n\n    // next, check for original source map\n    const sourceMapStore = this.executor.sourceMapStore;\n    if (source in sourceMapStore.data) {\n      map = new SourceMapConsumer(sourceMapStore.data[source].data);\n    } else {\n      map = this.getSourceMap(source);\n    }\n\n    source = relative('.', source);\n\n    if (map) {\n      originalPos = this.getOriginalPosition(map, line, col);\n      line = originalPos.line;\n      col = originalPos.column;\n      if (originalPos.source) {\n        // If original source starts with ./ or ../, or is just a bare\n        // filename, assume it's relative to the current source\n        if (\n          originalPos.source.indexOf('/') === -1 ||\n          /\\.\\.?\\//.test(originalPos.source)\n        ) {\n          source = join(dirname(source), originalPos.source);\n        } else {\n          // If not, assume its relative to the project root\n          source = originalPos.source;\n        }\n      }\n    }\n\n    // Source should be relative, because that's what we want the user to\n    // see\n    source = relative('.', source);\n\n    result = source + ':' + line;\n    if (col !== null) {\n      result += ':' + col;\n    }\n    return result;\n  }\n\n  /**\n   * Get the original position of line:column based on map.\n   *\n   * Assumes mappings are is in order by generatedLine, then by\n   * generatedColumn; maps created with SourceMapConsumer.eachMapping should\n   * be in this order by default.\n   */\n  private getOriginalPosition(\n    map: SourceMapConsumer,\n    line: number,\n    column?: number\n  ): { line: number; column?: number; source?: string } {\n    const originalPosition = map.originalPositionFor({\n      line: line,\n      column: column!\n    });\n\n    // if the SourceMapConsumer was able to find a location, return it\n    if (originalPosition.line != null) {\n      return originalPosition;\n    }\n\n    const entries: MappingItem[] = [];\n\n    // find all map entries that apply to the given line in the generated\n    // output\n    map.eachMapping(\n      entry => {\n        if (entry.generatedLine === line) {\n          entries.push(entry);\n        }\n      },\n      null,\n      SourceMapConsumer.GENERATED_ORDER\n    );\n\n    if (entries.length === 0) {\n      // no valid mappings exist -- return the line and column arguments\n      return { line: line, column: column };\n    }\n\n    let position = entries[0];\n\n    // Chrome/Node.js column is at the start of the term that generated the\n    // exception IE column is at the beginning of the expression/line with\n    // the exceptional term\n    //\n    // Safari column number is just after the exceptional term\n    //   - need to go back one element in the mapping\n    //\n    // Firefox, PhantomJS have no column number\n    //   - for no col number, find the largest original line number for the\n    //     generated line\n\n    if (column != null) {\n      // find the most likely mapping for the given generated line and\n      // column\n      let entry: MappingItem;\n      for (let i = 1; i < entries.length; i++) {\n        entry = entries[i];\n        if (\n          column > position.generatedColumn &&\n          column >= entry.generatedColumn\n        ) {\n          position = entry;\n        }\n      }\n    }\n\n    return {\n      line: position.originalLine,\n      column: position.originalColumn,\n      source: position.source\n    };\n  }\n\n  /**\n   * Load and process the source map for a given file.\n   */\n  private getSourceMap(filepath: string) {\n    if (filepath in this.fileSourceMaps) {\n      return this.fileSourceMaps[filepath];\n    }\n\n    try {\n      let data: string;\n\n      if (filepath in this.fileSources) {\n        data = this.fileSources[filepath];\n      } else {\n        data = readFileSync(filepath).toString('utf-8');\n        this.fileSources[filepath] = data;\n      }\n\n      const rawMap = readSourceMap(filepath, data);\n      if (rawMap) {\n        this.fileSourceMaps[filepath] = new SourceMapConsumer(rawMap);\n        return this.fileSourceMaps[filepath];\n      }\n    } catch (error) {\n      // this is normal for files like node.js -- just return null\n    }\n  }\n}\n"]}