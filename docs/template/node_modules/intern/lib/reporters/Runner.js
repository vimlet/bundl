(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports", "tslib", "charm", "istanbul-lib-coverage", "./Reporter", "./TextCoverage", "../common/util"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require("tslib");
    var charm = require("charm");
    var istanbul_lib_coverage_1 = require("istanbul-lib-coverage");
    var Reporter_1 = require("./Reporter");
    var TextCoverage_1 = require("./TextCoverage");
    var util_1 = require("../common/util");
    var eventHandler = Reporter_1.createEventHandler();
    var Runner = (function (_super) {
        tslib_1.__extends(Runner, _super);
        function Runner(executor, options) {
            if (options === void 0) { options = {}; }
            var _this = _super.call(this, executor, options) || this;
            _this.hidePassed = options.hidePassed || false;
            _this.hideSkipped = options.hideSkipped || false;
            _this.hideTunnelDownloadProgress =
                options.hideTunnelDownloadProgress || false;
            _this.sessions = {};
            _this.hasRunErrors = false;
            _this.hasSuiteErrors = false;
            _this.serveOnly = executor.config.serveOnly;
            _this.charm = charm();
            _this.charm.pipe(_this.output);
            _this.charm.display('reset');
            _this._deprecationMessages = {};
            return _this;
        }
        Runner.prototype.coverage = function (message) {
            var sessionId = message.sessionId || '';
            if (!this.sessions[sessionId]) {
                this.sessions[sessionId] = {};
            }
            var session = this.sessions[sessionId];
            session.coverage = session.coverage || istanbul_lib_coverage_1.createCoverageMap();
            session.coverage.merge(message.coverage);
        };
        Runner.prototype.deprecated = function (message) {
            var key = message.original + "|" + message.replacement + "|" + message.message;
            if (this._deprecationMessages[key]) {
                return;
            }
            this._deprecationMessages[key] = true;
            this.charm
                .foreground('yellow')
                .write('⚠︎ ' + message.original + ' is deprecated. ');
            if (message.replacement) {
                this.charm.write('Use ' + message.replacement + ' instead.');
            }
            else {
                this.charm.write('Please open a ticket at https://github.com/theintern/intern/issues if you still ' +
                    'require access to this function.');
            }
            if (message.message) {
                this.charm.write(' ' + message.message);
            }
            this.charm.write('\n');
            this.charm.display('reset');
        };
        Runner.prototype.error = function (error) {
            this.charm.foreground('red');
            this.charm.write('(ノಠ益ಠ)ノ彡┻━┻\n');
            this.charm.write(this.formatError(error));
            this.charm.display('reset');
            this.charm.write('\n\n');
            this.hasRunErrors = true;
        };
        Runner.prototype.warning = function (warning) {
            this.charm.foreground('yellow');
            var message = typeof warning === 'string' ? warning : this.formatError(warning);
            this.charm.write("WARNING: " + message.replace(/^Error:\s+/, ''));
            this.charm.display('reset');
            this.charm.write('\n\n');
        };
        Runner.prototype.log = function (message) {
            var _this = this;
            message.split('\n').forEach(function (line) {
                _this.console.log("DEBUG: " + line);
            });
        };
        Runner.prototype.runEnd = function () {
            var _this = this;
            var map = this.executor.coverageMap;
            var numTests = 0;
            var numPassedTests = 0;
            var numFailedTests = 0;
            var numSkippedTests = 0;
            var sessionIds = Object.keys(this.sessions);
            var numEnvironments = sessionIds.length;
            sessionIds
                .filter(function (sessionId) { return _this.sessions[sessionId].suite; })
                .forEach(function (sessionId) {
                var suite = _this.sessions[sessionId].suite;
                numTests += suite.numTests;
                numPassedTests += suite.numPassedTests;
                numFailedTests += suite.numFailedTests;
                numSkippedTests += suite.numSkippedTests;
            });
            var charm = this.charm;
            if (map.files().length > 0) {
                charm.write('\n');
                charm.display('bright');
                charm.write('Total coverage\n');
                charm.display('reset');
                this.createCoverageReport(this.reportType, map);
            }
            var message = "TOTAL: tested " + numEnvironments + " platforms, " + numPassedTests + " passed, " + numFailedTests + " failed";
            if (numSkippedTests) {
                message += ", " + numSkippedTests + " skipped";
            }
            var numUnrunTests = numTests - (numPassedTests + numFailedTests + numSkippedTests);
            if (numUnrunTests) {
                message += ", " + numUnrunTests + " not run";
            }
            if (this.hasRunErrors) {
                message += '; fatal error occurred';
            }
            else if (this.hasSuiteErrors) {
                message += '; suite error occurred';
            }
            charm.display('bright');
            charm.foreground(numFailedTests > 0 || this.hasRunErrors || this.hasSuiteErrors
                ? 'red'
                : 'green');
            charm.write(message);
            charm.display('reset');
            charm.write('\n');
        };
        Runner.prototype.serverStart = function (server) {
            if (this.executor.config.serveOnly) {
                this.charm.write("To use the browser client, browse to\n\n  " + this.executor.config.serverUrl + "__intern/\n\n");
                this.charm.write('Press CTRL-C to stop serving\n\n');
            }
            else {
                var message = "Listening on localhost:" + server.port;
                if (server.socketPort) {
                    message += " (ws " + server.socketPort + ")";
                }
                this.charm.write(message + "\n");
            }
        };
        Runner.prototype.suiteEnd = function (suite) {
            var session = this.sessions[suite.sessionId || ''];
            if (!session) {
                if (!this.serveOnly) {
                    var charm_1 = this.charm;
                    charm_1.display('bright');
                    charm_1.foreground('yellow');
                    charm_1.write('BUG: suiteEnd was received for invalid session ' + suite.sessionId);
                    charm_1.display('reset');
                    charm_1.write('\n');
                }
                return;
            }
            if (suite.error) {
                var error = suite.error;
                var charm_2 = this.charm;
                charm_2.foreground('red');
                charm_2.write('Suite ' + suite.id + ' FAILED\n');
                charm_2.write(this.formatError(error));
                charm_2.display('reset');
                charm_2.write('\n');
                this.hasSuiteErrors = session.hasSuiteErrors = true;
            }
            else if (!suite.hasParent && this.executor.suites.length > 1) {
                if (session.coverage) {
                    this.charm.write('\n');
                    this.createCoverageReport(this.reportType, session.coverage);
                }
                else {
                    var charm_3 = this.charm;
                    charm_3.write('No unit test coverage for ' + suite.name);
                    charm_3.display('reset');
                    charm_3.write('\n');
                }
                var name_1 = suite.name;
                var hasError = suite.error || session.hasSuiteErrors;
                var numTests = suite.numTests;
                var numFailedTests = suite.numFailedTests;
                var numSkippedTests = suite.numSkippedTests;
                var numPassedTests = numTests - numFailedTests - numSkippedTests;
                var summary = name_1 + ": " + numPassedTests + " passed, " + numFailedTests + " failed";
                if (numSkippedTests) {
                    summary += ", " + numSkippedTests + " skipped";
                }
                if (hasError) {
                    summary += '; suite error occurred';
                }
                var charm_4 = this.charm;
                charm_4.display('bright');
                charm_4.foreground(numFailedTests || hasError > 0 ? 'red' : 'green');
                charm_4.write(summary);
                charm_4.display('reset');
                charm_4.write('\n');
            }
        };
        Runner.prototype.suiteStart = function (suite) {
            if (!suite.hasParent) {
                this.sessions[suite.sessionId || ''] = { suite: suite };
                if (suite.sessionId) {
                    this.charm.write('\n');
                    this.charm.write('‣ Created remote session ' +
                        suite.name +
                        ' (' +
                        suite.sessionId +
                        ')\n');
                }
            }
        };
        Runner.prototype.testEnd = function (test) {
            var charm = this.charm;
            if (test.error) {
                charm.foreground('red');
                charm.write('× ' + test.id);
                charm.write(' (' + test.timeElapsed / 1000 + 's)');
                charm.write('\n');
                charm.write(util_1.prefix(this.formatError(test.error), '    '));
                charm.display('reset');
                charm.write('\n\n');
            }
            else if (test.skipped) {
                if (!this.hideSkipped) {
                    charm.write('~ ' + test.id);
                    charm.display('reset');
                    charm.write(' (' + (test.skipped || 'skipped') + ')');
                    charm.display('reset');
                    charm.write('\n');
                }
            }
            else {
                if (!this.hidePassed) {
                    charm.foreground('green');
                    charm.write('✓ ' + test.id);
                    charm.display('reset');
                    charm.write(' (' + test.timeElapsed / 1000 + 's)');
                    charm.display('reset');
                    charm.write('\n');
                }
            }
        };
        Runner.prototype.tunnelDownloadProgress = function (message) {
            if (this.hideTunnelDownloadProgress) {
                return;
            }
            var progress = message.progress;
            this.charm.write('Tunnel download: ' +
                ((progress.received / progress.total) * 100).toFixed(3) +
                '%\r');
        };
        Runner.prototype.tunnelStart = function (_) {
            this.charm.write('Tunnel started\n');
        };
        Runner.prototype.tunnelStatus = function (message) {
            this.charm.write(message.status + '\x1b[K\r');
        };
        tslib_1.__decorate([
            eventHandler()
        ], Runner.prototype, "coverage", null);
        tslib_1.__decorate([
            eventHandler()
        ], Runner.prototype, "deprecated", null);
        tslib_1.__decorate([
            eventHandler()
        ], Runner.prototype, "error", null);
        tslib_1.__decorate([
            eventHandler()
        ], Runner.prototype, "warning", null);
        tslib_1.__decorate([
            eventHandler()
        ], Runner.prototype, "log", null);
        tslib_1.__decorate([
            eventHandler()
        ], Runner.prototype, "runEnd", null);
        tslib_1.__decorate([
            eventHandler()
        ], Runner.prototype, "serverStart", null);
        tslib_1.__decorate([
            eventHandler()
        ], Runner.prototype, "suiteEnd", null);
        tslib_1.__decorate([
            eventHandler()
        ], Runner.prototype, "suiteStart", null);
        tslib_1.__decorate([
            eventHandler()
        ], Runner.prototype, "testEnd", null);
        tslib_1.__decorate([
            eventHandler()
        ], Runner.prototype, "tunnelDownloadProgress", null);
        tslib_1.__decorate([
            eventHandler()
        ], Runner.prototype, "tunnelStart", null);
        tslib_1.__decorate([
            eventHandler()
        ], Runner.prototype, "tunnelStatus", null);
        return Runner;
    }(TextCoverage_1.default));
    exports.default = Runner;
});
//# sourceMappingURL=Runner.js.map