(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports", "tslib", "./Reporter", "../Suite"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require("tslib");
    var Reporter_1 = require("./Reporter");
    var Suite_1 = require("../Suite");
    var TeamCity = (function (_super) {
        tslib_1.__extends(TeamCity, _super);
        function TeamCity() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        TeamCity.prototype.runStart = function () {
            this._ignoredTestIds = {};
        };
        TeamCity.prototype.testStart = function (test) {
            this._sendMessage('testStarted', {
                name: test.name,
                flowId: test.sessionId
            });
        };
        TeamCity.prototype.testEnd = function (test) {
            if (test.error) {
                var message = {
                    name: test.name,
                    message: this.formatError(test.error),
                    flowId: test.sessionId
                };
                if (test.error.actual && test.error.expected) {
                    message.type = 'comparisonFailure';
                    message.expected = test.error.expected;
                    message.actual = test.error.actual;
                }
                this._sendMessage('testFailed', message);
            }
            else if (test.skipped) {
                this._sendMessage('testIgnored', {
                    name: test.name,
                    flowId: test.sessionId
                });
            }
            else {
                this._sendMessage('testFinished', {
                    name: test.name,
                    duration: test.timeElapsed,
                    flowId: test.sessionId
                });
            }
        };
        TeamCity.prototype.suiteStart = function (suite) {
            this._sendMessage('testSuiteStarted', {
                name: suite.name,
                startDate: new Date(),
                flowId: suite.sessionId
            });
        };
        TeamCity.prototype.suiteEnd = function (suite) {
            if (suite.error) {
                this._sendMessage('message', {
                    name: suite.name,
                    flowId: suite.sessionId,
                    text: 'SUITE ERROR',
                    errorDetails: this.formatError(suite.error),
                    status: 'ERROR'
                });
                this._notifyUnrunTests(suite);
            }
            else {
                this._sendMessage('testSuiteFinished', {
                    name: suite.name,
                    duration: suite.timeElapsed,
                    flowId: suite.sessionId
                });
            }
        };
        TeamCity.prototype._escapeString = function (str) {
            var replacer = /['\n\r\|\[\]\u0100-\uffff]/g;
            var map = {
                "'": "|'",
                '|': '||',
                '\n': '|n',
                '\r': '|r',
                '[': '|[',
                ']': '|]'
            };
            return str.replace(replacer, function (character) {
                if (character in map) {
                    return map[character];
                }
                if (/[^\u0000-\u00ff]/.test(character)) {
                    return '|0x' + character.charCodeAt(0).toString(16);
                }
                return '';
            });
        };
        TeamCity.prototype._notifyUnrunTests = function (suite) {
            var _this = this;
            var ignoredTestIds = this._ignoredTestIds;
            var ignoredTests = ignoredTestIds[suite.sessionId];
            if (!ignoredTests) {
                ignoredTests = ignoredTestIds[suite.sessionId] = {};
            }
            suite.tests.forEach(function (test) {
                if (Suite_1.isSuite(test)) {
                    _this._notifyUnrunTests(test);
                }
                else if (!ignoredTests[test.id]) {
                    _this._sendMessage('testIgnored', {
                        name: test.name,
                        flowId: test.sessionId
                    });
                    ignoredTests[test.id] = true;
                }
            });
        };
        TeamCity.prototype._sendMessage = function (type, args) {
            var _this = this;
            args.timestamp = new Date().toISOString().slice(0, -1);
            args = Object.keys(args)
                .map(function (key) { return key + "='" + _this._escapeString(String(args[key])) + "'"; })
                .join(' ');
            this.output.write("##teamcity[" + type + " " + args + "]\n");
        };
        tslib_1.__decorate([
            Reporter_1.eventHandler()
        ], TeamCity.prototype, "runStart", null);
        tslib_1.__decorate([
            Reporter_1.eventHandler()
        ], TeamCity.prototype, "testStart", null);
        tslib_1.__decorate([
            Reporter_1.eventHandler()
        ], TeamCity.prototype, "testEnd", null);
        tslib_1.__decorate([
            Reporter_1.eventHandler()
        ], TeamCity.prototype, "suiteStart", null);
        tslib_1.__decorate([
            Reporter_1.eventHandler()
        ], TeamCity.prototype, "suiteEnd", null);
        return TeamCity;
    }(Reporter_1.default));
    exports.default = TeamCity;
});
//# sourceMappingURL=TeamCity.js.map