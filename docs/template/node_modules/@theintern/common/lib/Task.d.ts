export interface CancellablePromise<T = any> extends Promise<T> {
    cancel(): void;
    catch<E = never>(onrejected?: ((reason: any) => E | PromiseLike<E>) | undefined | null): CancellablePromise<T | E>;
    finally(callback?: (() => void) | undefined | null): CancellablePromise<T>;
    then<V = T, E = never>(onfulfilled?: ((value: T) => V | PromiseLike<V>) | undefined | null, onrejected?: ((reason: any) => E | PromiseLike<E>) | undefined | null): CancellablePromise<V | E>;
}
export default class Task<T = any> implements CancellablePromise<T> {
    readonly [Symbol.toStringTag]: 'Promise';
    static race<T>(iterable: Iterable<T | PromiseLike<T>> | (T | PromiseLike<T>)[]): Task<T>;
    static reject<T>(reason?: Error): Task<T>;
    static resolve(): Task<void>;
    static resolve<T>(value: T | PromiseLike<T>): Task<T>;
    static all<T>(iterable: DictionaryOfPromises<T>): Task<{
        [key: string]: T;
    }>;
    static all<T>(iterable: (T | PromiseLike<T>)[]): Task<T[]>;
    static all<T>(iterable: T | PromiseLike<T>): Task<T[]>;
    static all<T>(iterable: ListOfPromises<T>): Task<T[]>;
    private static unwrapPromises;
    private readonly _promise;
    private canceler;
    private readonly children;
    private _finally;
    private _state;
    constructor(executor: (resolve: (value?: T | PromiseLike<T>) => void, reject: (reason?: any) => void) => void, canceler?: () => void);
    private _cancel;
    cancel(): void;
    catch<TResult = never>(onRejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined): Task<T | TResult>;
    finally(callback?: (() => void) | undefined | null): Task<T>;
    then<TResult1 = T, TResult2 = never>(onFulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onRejected?: ((reason: any) => TResult2 | PromiseLike<TResult2> | undefined) | undefined | null): Task<TResult1 | TResult2>;
}
export declare function isTask<T>(value: any): value is Task<T>;
export declare type DictionaryOfPromises<T = any> = {
    [_: string]: T | PromiseLike<T>;
};
export declare type ListOfPromises<T = any> = Iterable<T | PromiseLike<T>>;
export declare function isPromiseLike<T>(value: any): value is PromiseLike<T>;
