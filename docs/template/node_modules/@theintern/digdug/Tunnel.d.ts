/// <reference types="node" />
import { Evented, EventObject, Handle, CancellablePromise } from '@theintern/common';
import { ChildProcess } from 'child_process';
import { Url } from 'url';
import { JobState } from './interfaces';
export default class Tunnel extends Evented<TunnelEvents, string> implements TunnelProperties, Url {
    environmentUrl: string | undefined;
    accessKey: string | undefined;
    username: string | undefined;
    architecture: string;
    auth: string | undefined;
    directory: string;
    executable: string;
    hostname: string;
    pathname: string;
    platform: string;
    port: string;
    protocol: string;
    proxy: string | undefined;
    tunnelId: string | undefined;
    url: string;
    verbose: boolean;
    protected _startTask: CancellablePromise<any> | undefined;
    protected _stopTask: Promise<number | void> | undefined;
    protected _handle: Handle | undefined;
    protected _process: ChildProcess | undefined;
    protected _state: 'stopped' | 'starting' | 'running' | 'stopping';
    constructor(options?: TunnelOptions);
    readonly clientUrl: string;
    readonly extraCapabilities: object;
    readonly isDownloaded: boolean;
    readonly isRunning: boolean;
    readonly isStarting: boolean;
    readonly isStopping: boolean;
    download(forceDownload?: boolean): CancellablePromise<void>;
    getEnvironments(): CancellablePromise<NormalizedEnvironment[]>;
    sendJobState(_jobId: string, _data: JobState): CancellablePromise<void>;
    start(): CancellablePromise<void>;
    stop(): Promise<number | void>;
    protected _downloadFile(url: string | undefined, proxy: string | undefined, options?: DownloadOptions): CancellablePromise<void>;
    protected _makeArgs(..._values: string[]): string[];
    protected _makeChild(executor: ChildExecutor, ...values: string[]): CancellablePromise;
    protected _makeOptions(..._values: string[]): {
        env: NodeJS.ProcessEnv;
    };
    protected _normalizeEnvironment(environment: Object): NormalizedEnvironment;
    protected _postDownloadFile(data: Buffer, options?: DownloadOptions): Promise<void>;
    protected _start(executor: ChildExecutor): CancellablePromise<any>;
    protected _stop(): Promise<number | void>;
}
export interface TunnelEventObject<T> extends EventObject<string> {
    readonly target: T;
}
export interface TunnelEvents {
    stdout: IOEvent;
    stderr: IOEvent;
    status: StatusEvent;
    downloadprogress: DownloadProgressEvent;
    [index: string]: any;
}
export interface IOEvent extends TunnelEventObject<Tunnel> {
    readonly type: 'stdout' | 'stderr';
    readonly data: string;
}
export interface StatusEvent extends TunnelEventObject<Tunnel> {
    readonly type: 'status';
    readonly status: string;
}
export interface DownloadProgressEvent extends TunnelEventObject<Tunnel> {
    readonly type: 'downloadprogress';
    readonly url: string;
    readonly total: number;
    readonly received: number;
}
export interface ChildExecutor {
    (child: ChildProcess, resolve: () => void, reject: (reason?: any) => void): Handle | void;
}
export interface DownloadProperties {
    directory: string | undefined;
    proxy: string | undefined;
    url: string;
}
export declare type DownloadOptions = Partial<DownloadProperties>;
export interface NormalizedEnvironment {
    browserName: string;
    browserVersion?: string;
    descriptor: Object;
    platform: string;
    platformName?: string;
    platformVersion?: string;
    version: string;
    intern: {
        platform: string;
        browserName: string;
        version: string;
    };
}
export interface TunnelProperties extends DownloadProperties {
    architecture: string;
    auth: string | undefined;
    accessKey: string | undefined;
    executable: string | undefined;
    hostname: string;
    pathname: string;
    platform: string;
    port: string;
    protocol: string;
    tunnelId: string | undefined;
    username: string | undefined;
    verbose: boolean;
}
export declare type TunnelOptions = Partial<TunnelProperties>;
