"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Tunnel_1 = require("./Tunnel");
var util_1 = require("util");
var path_1 = require("path");
var common_1 = require("@theintern/common");
var util_2 = require("./lib/util");
var semver_1 = require("semver");
var command_exists_1 = require("command-exists");
var driverInfo = {
    SeleniumVersion: '3.141.59',
    ChromeVersion: '74.0.3729.6',
    FirefoxVersion: '0.24.0',
    IEVersion: '3.141.59',
    EdgeVersion: '17134',
    EdgeUrls: {
        '15063': 'https://download.microsoft.com/download/3/4/2/342316D7-EBE0-4F10-ABA2-AE8E0CDF36DD/MicrosoftWebDriver.exe',
        '16299': 'https://download.microsoft.com/download/D/4/1/D417998A-58EE-4EFE-A7CC-39EF9E020768/MicrosoftWebDriver.exe',
        '17134': 'https://download.microsoft.com/download/F/8/A/F8AF50AB-3C3A-4BC4-8773-DC27B32988DD/MicrosoftWebDriver.exe',
        '75.0.137.0': {
            x86: 'https://az813057.vo.msecnd.net/webdriver/msedgedriver_x86/msedgedriver.exe',
            x64: 'https://az813057.vo.msecnd.net/webdriver/msedgedriver_x64/msedgedriver.exe'
        }
    }
};
/**
 * A Selenium tunnel. This tunnel downloads the
 * [[http://www.seleniumhq.org/download/|Selenium-standalone server]] and any
 * necessary WebDriver executables, and handles starting and stopping Selenium.
 *
 * The primary configuration option is [[SeleniumTunnel.drivers|drivers]], which
 * determines which browsers the Selenium tunnel will support.
 *
 * Note that Java must be installed and in the system path to use this tunnel.
 *
 * The standard browser names (for the `browserName` selenium capability) are:
 *
 * * `MicrosoftEdge`
 * * `chrome`
 * * `firefox`
 * * `internet explorer`
 * * `safari`
 */
var SeleniumTunnel = /** @class */ (function (_super) {
    __extends(SeleniumTunnel, _super);
    function SeleniumTunnel(options) {
        var _this = _super.call(this, Object.assign({
            seleniumArgs: [],
            drivers: ['chrome'],
            baseUrl: 'https://selenium-release.storage.googleapis.com',
            version: driverInfo.SeleniumVersion,
            seleniumTimeout: 5000
        }, options || {})) || this;
        // Emit a meaningful error if Java isn't available
        if (!command_exists_1.sync('java')) {
            throw new Error('Java must be installed to use SeleniumTunnel');
        }
        return _this;
    }
    Object.defineProperty(SeleniumTunnel.prototype, "artifact", {
        get: function () {
            return "selenium-server-standalone-" + this.version + ".jar";
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SeleniumTunnel.prototype, "directory", {
        get: function () {
            return path_1.join(__dirname, 'selenium-standalone');
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SeleniumTunnel.prototype, "executable", {
        get: function () {
            return 'java';
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SeleniumTunnel.prototype, "isDownloaded", {
        get: function () {
            var directory = this.directory;
            return (util_2.fileExists(path_1.join(directory, this.artifact)) &&
                this._getDriverConfigs().every(function (config) {
                    return util_2.fileExists(path_1.join(directory, config.executable));
                }));
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SeleniumTunnel.prototype, "url", {
        get: function () {
            var majorMinorVersion = this.version.slice(0, this.version.lastIndexOf('.'));
            return util_1.format('%s/%s/%s', this.baseUrl, majorMinorVersion, this.artifact);
        },
        enumerable: true,
        configurable: true
    });
    SeleniumTunnel.prototype.download = function (forceDownload) {
        var _this = this;
        if (forceDownload === void 0) { forceDownload = false; }
        if (!forceDownload && this.isDownloaded) {
            return common_1.Task.resolve();
        }
        var tasks;
        return new common_1.Task(function (resolve) {
            var configs = [
                {
                    url: _this.url,
                    executable: _this.artifact,
                    dontExtract: true
                }
            ].concat(_this._getDriverConfigs());
            tasks = configs.map(function (config) {
                var executable = config.executable;
                var dontExtract = Boolean(config.dontExtract);
                var directory = config.directory;
                if (util_2.fileExists(path_1.join(_this.directory, executable))) {
                    return common_1.Task.resolve();
                }
                // TODO: progress events
                return _this._downloadFile(config.url, _this.proxy, {
                    executable: executable,
                    dontExtract: dontExtract,
                    directory: directory
                });
            });
            resolve(common_1.Task.all(tasks).then(function () { }));
        }, function () {
            tasks &&
                tasks.forEach(function (task) {
                    task.cancel();
                });
        });
    };
    SeleniumTunnel.prototype.sendJobState = function () {
        // This is a noop for Selenium
        return common_1.Task.resolve();
    };
    SeleniumTunnel.prototype._getDriverConfigs = function () {
        function getDriverConfig(name, options) {
            var Constructor = driverNameMap[name];
            if (!Constructor) {
                throw new Error('Invalid driver name "' + name + '"');
            }
            return new Constructor(options);
        }
        return this.drivers.map(function (data) {
            if (typeof data === 'string') {
                return getDriverConfig(data);
            }
            if (typeof data === 'object' && data.name) {
                return getDriverConfig(data.name, data);
            }
            // data is a driver definition
            return data;
        });
    };
    SeleniumTunnel.prototype._makeArgs = function () {
        var directory = this.directory;
        var driverConfigs = this._getDriverConfigs();
        var args = [];
        driverConfigs.reduce(function (args, config) {
            var file = path_1.join(directory, config.executable);
            args.push('-D' + config.seleniumProperty + '=' + file);
            return args;
        }, args);
        if (this.seleniumArgs) {
            args.push.apply(args, this.seleniumArgs);
        }
        args.push('-jar', path_1.join(this.directory, this.artifact), '-port', this.port);
        if (this.verbose) {
            args.push('-debug');
            if (semver_1.satisfies(this.version, '>=3.1.0 <3.5.0')) {
                args.push('true');
            }
            console.log('Starting with arguments: ', args.join(' '));
        }
        return args;
    };
    SeleniumTunnel.prototype._postDownloadFile = function (data, options) {
        var executable = options.executable;
        if (options.dontExtract) {
            return util_2.writeFile(data, path_1.join(this.directory, executable));
        }
        return _super.prototype._postDownloadFile.call(this, data, options);
    };
    SeleniumTunnel.prototype._start = function (executor) {
        var _this = this;
        var handle;
        var task = this._makeChild(function (child, resolve, reject) {
            handle = util_2.on(child.stderr, 'data', function (data) {
                // Selenium recommends that we poll the hub looking for a status
                // response
                // https://github.com/seleniumhq/selenium-google-code-issue-archive/issues/7957
                // We're going against the recommendation here for a few reasons
                // 1. There's no default pid or log to look for errors to
                //    provide a specific failure
                // 2. Polling on a failed server start could leave us with an
                //    unpleasant wait
                // 3. Just polling a selenium server doesn't guarantee it's the
                //    server we started
                // 4. This works pretty well
                data = String(data);
                if (data.indexOf('Selenium Server is up and running') > -1) {
                    resolve();
                }
                else if (/Address already in use/.test(data) ||
                    /Port \d+ is busy/.test(data)) {
                    reject(new Error('Address is already in use'));
                    // Kill the child since we're reporting that startup failed
                    util_2.kill(child.pid);
                }
            });
            if (_this.verbose) {
                util_2.on(child.stderr, 'data', function (data) {
                    process.stderr.write(data);
                });
            }
            executor(child, resolve, reject);
        });
        task.then(function () { return handle.destroy(); }, function () { return handle.destroy(); });
        return task;
    };
    return SeleniumTunnel;
}(Tunnel_1.default));
exports.default = SeleniumTunnel;
var Config = /** @class */ (function () {
    function Config(config) {
        Object.assign(this, config);
    }
    return Config;
}());
var ChromeConfig = /** @class */ (function (_super) {
    __extends(ChromeConfig, _super);
    function ChromeConfig(options) {
        return _super.call(this, Object.assign({
            arch: process.arch,
            baseUrl: 'https://chromedriver.storage.googleapis.com',
            platform: process.platform,
            version: driverInfo.ChromeVersion
        }, options)) || this;
    }
    Object.defineProperty(ChromeConfig.prototype, "artifact", {
        get: function () {
            var platform = this.platform;
            if (platform === 'linux') {
                platform = 'linux' + (this.arch === 'x86' ? '32' : '64');
            }
            else if (platform === 'darwin') {
                var parts_1 = String(this.version)
                    .split('.')
                    .map(Number);
                var isGreater = [2, 22].some(function (part, i) {
                    return parts_1[i] > part;
                });
                platform = isGreater ? 'mac64' : 'mac32';
            }
            return util_1.format('chromedriver_%s.zip', platform);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ChromeConfig.prototype, "directory", {
        get: function () {
            return this.version;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ChromeConfig.prototype, "url", {
        get: function () {
            return util_1.format('%s/%s/%s', this.baseUrl, this.version, this.artifact);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ChromeConfig.prototype, "executable", {
        get: function () {
            return path_1.join(this.directory, this.platform === 'win32' ? 'chromedriver.exe' : 'chromedriver');
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ChromeConfig.prototype, "seleniumProperty", {
        get: function () {
            return 'webdriver.chrome.driver';
        },
        enumerable: true,
        configurable: true
    });
    return ChromeConfig;
}(Config));
var FirefoxConfig = /** @class */ (function (_super) {
    __extends(FirefoxConfig, _super);
    function FirefoxConfig(options) {
        return _super.call(this, Object.assign({
            arch: process.arch,
            baseUrl: 'https://github.com/mozilla/geckodriver/releases/download',
            platform: process.platform,
            version: driverInfo.FirefoxVersion
        }, options)) || this;
    }
    Object.defineProperty(FirefoxConfig.prototype, "artifact", {
        get: function () {
            var platform = this.platform;
            if (platform === 'linux') {
                platform = 'linux' + (this.arch === 'x64' ? '64' : '32');
            }
            else if (platform === 'win32') {
                platform = 'win' + (this.arch === 'x64' ? '64' : '32');
            }
            else if (platform === 'darwin') {
                platform = 'macos';
            }
            var extension = /^win/.test(platform) ? '.zip' : '.tar.gz';
            return util_1.format('geckodriver-v%s-%s%s', this.version, platform, extension);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FirefoxConfig.prototype, "url", {
        get: function () {
            return util_1.format('%s/v%s/%s', this.baseUrl, this.version, this.artifact);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FirefoxConfig.prototype, "directory", {
        get: function () {
            return this.version;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FirefoxConfig.prototype, "executable", {
        get: function () {
            return path_1.join(this.directory, this.platform === 'win32' ? 'geckodriver.exe' : 'geckodriver');
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FirefoxConfig.prototype, "seleniumProperty", {
        get: function () {
            return 'webdriver.gecko.driver';
        },
        enumerable: true,
        configurable: true
    });
    return FirefoxConfig;
}(Config));
var IEConfig = /** @class */ (function (_super) {
    __extends(IEConfig, _super);
    function IEConfig(options) {
        return _super.call(this, Object.assign({
            arch: process.arch,
            baseUrl: 'https://selenium-release.storage.googleapis.com',
            version: driverInfo.IEVersion
        }, options)) || this;
    }
    Object.defineProperty(IEConfig.prototype, "artifact", {
        get: function () {
            var architecture = this.arch === 'x64' ? 'x64' : 'Win32';
            return util_1.format('IEDriverServer_%s_%s.zip', architecture, this.version);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IEConfig.prototype, "url", {
        get: function () {
            var majorMinorVersion = this.version.slice(0, this.version.lastIndexOf('.'));
            return util_1.format('%s/%s/%s', this.baseUrl, majorMinorVersion, this.artifact);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IEConfig.prototype, "directory", {
        get: function () {
            return this.version;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IEConfig.prototype, "executable", {
        get: function () {
            return path_1.join(this.directory, 'IEDriverServer.exe');
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IEConfig.prototype, "seleniumProperty", {
        get: function () {
            return 'webdriver.ie.driver';
        },
        enumerable: true,
        configurable: true
    });
    return IEConfig;
}(Config));
var EdgeConfig = /** @class */ (function (_super) {
    __extends(EdgeConfig, _super);
    function EdgeConfig(options) {
        return _super.call(this, Object.assign({
            arch: process.arch,
            baseUrl: 'https://download.microsoft.com/download',
            version: driverInfo.EdgeVersion
        }, options)) || this;
    }
    Object.defineProperty(EdgeConfig.prototype, "dontExtract", {
        get: function () {
            return true;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(EdgeConfig.prototype, "url", {
        get: function () {
            var uuid = this.uuid;
            if (uuid) {
                var a = uuid[0];
                var b = uuid[1];
                var c = uuid[2];
                return util_1.format('%s/%s/%s/%s/%s/%s', this.baseUrl, a, b, c, uuid, this.artifact);
            }
            var urlOrObj = driverInfo.EdgeUrls[this.version];
            if (typeof urlOrObj === 'string') {
                return urlOrObj;
            }
            return urlOrObj[this.arch];
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(EdgeConfig.prototype, "artifact", {
        get: function () {
            return 'MicrosoftWebDriver.exe';
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(EdgeConfig.prototype, "directory", {
        get: function () {
            return this.version;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(EdgeConfig.prototype, "executable", {
        get: function () {
            return path_1.join(this.version, 'MicrosoftWebDriver.exe');
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(EdgeConfig.prototype, "seleniumProperty", {
        get: function () {
            return 'webdriver.edge.driver';
        },
        enumerable: true,
        configurable: true
    });
    return EdgeConfig;
}(Config));
var driverNameMap = {
    chrome: ChromeConfig,
    firefox: FirefoxConfig,
    ie: IEConfig,
    'internet explorer': IEConfig,
    edge: EdgeConfig,
    MicrosoftEdge: EdgeConfig
};
//# sourceMappingURL=SeleniumTunnel.js.map