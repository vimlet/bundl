"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var common_1 = require("@theintern/common");
var child_process_1 = require("child_process");
var path_1 = require("path");
var url_1 = require("url");
var util_1 = require("./lib/util");
var decompress = require("decompress");
/**
 * A Tunnel is a mechanism for connecting to a WebDriver service provider that
 * securely exposes local services for testing within the service providerâ€™s
 * network.
 */
var Tunnel = /** @class */ (function (_super) {
    __extends(Tunnel, _super);
    function Tunnel(options) {
        var _this = _super.call(this) || this;
        Object.assign(_this, {
            architecture: process.arch,
            hostname: 'localhost',
            pathname: '/wd/hub/',
            platform: process.platform,
            port: 4444,
            protocol: 'http',
            verbose: false,
            state: 'stopped'
        }, options || {});
        return _this;
    }
    Object.defineProperty(Tunnel.prototype, "clientUrl", {
        /**
         * The URL that a WebDriver client should used to interact with this
         * service.
         */
        get: function () {
            return url_1.format(this);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Tunnel.prototype, "extraCapabilities", {
        /**
         * A map of additional capabilities that need to be sent to the provider
         * when a new session is being created.
         */
        get: function () {
            return {};
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Tunnel.prototype, "isDownloaded", {
        /**
         * Whether or not the tunnel software has already been downloaded.
         */
        get: function () {
            return util_1.fileExists(this.executable);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Tunnel.prototype, "isRunning", {
        /**
         * Whether or not the tunnel is currently running.
         */
        get: function () {
            return this._state === 'running';
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Tunnel.prototype, "isStarting", {
        /**
         * Whether or not the tunnel is currently starting up.
         */
        get: function () {
            return this._state === 'starting';
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Tunnel.prototype, "isStopping", {
        /**
         * Whether or not the tunnel is currently stopping.
         */
        get: function () {
            return this._state === 'stopping';
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Downloads and extracts the tunnel software if it is not already
     * downloaded.
     *
     * This method can be extended by implementations to perform any necessary
     * post-processing, such as setting appropriate file permissions on the
     * downloaded executable.
     *
     * @param forceDownload Force downloading the software even if it already
     * has been downloaded.
     * @returns A promise that resolves once the download and extraction process
     * has completed.
     */
    Tunnel.prototype.download = function (forceDownload) {
        if (forceDownload === void 0) { forceDownload = false; }
        if (!forceDownload && this.isDownloaded) {
            return common_1.Task.resolve();
        }
        return this._downloadFile(this.url, this.proxy);
    };
    /**
     * Get a list of environments available on the service.
     *
     * This method should be overridden and use a specific implementation that
     * returns normalized environments from the service. E.g.
     *
     * ```js
     * {
     *     browserName: 'firefox',
     *     version: '12',
     *     platform: 'windows',
     *     descriptor: { <original returned environment> }
     * }
     * ```
     *
     * @returns An object containing the response and helper functions
     */
    Tunnel.prototype.getEnvironments = function () {
        var _this = this;
        if (!this.environmentUrl) {
            return common_1.Task.resolve([]);
        }
        return common_1.request(this.environmentUrl, {
            password: this.accessKey,
            username: this.username,
            proxy: this.proxy
        }).then(function (response) {
            if (response.status >= 200 && response.status < 400) {
                return response.json().then(function (data) {
                    return data.reduce(function (environments, environment) {
                        return environments.concat(_this._normalizeEnvironment(environment));
                    }, []);
                });
            }
            else {
                if (response.status === 401) {
                    throw new Error('Missing or invalid username and access key');
                }
                throw new Error("Server replied with a status of " + response.status);
            }
        });
    };
    /**
     * Sends information about a job to the tunnel provider.
     *
     * @param jobId The job to send data about. This is usually a session ID.
     * @param data Data to send to the tunnel provider about the job.
     * @returns A promise that resolves once the job state request is complete.
     */
    Tunnel.prototype.sendJobState = function (_jobId, _data) {
        return common_1.Task.reject(new Error('Job state is not supported by this tunnel.'));
    };
    /**
     * Starts the tunnel, automatically downloading dependencies if necessary.
     *
     * @returns A promise that resolves once the tunnel has been established.
     */
    Tunnel.prototype.start = function () {
        var _this = this;
        switch (this._state) {
            case 'stopping':
                throw new Error('Previous tunnel is still terminating');
            case 'running':
            case 'starting':
                return this._startTask;
        }
        this._state = 'starting';
        this._startTask = this.download().then(function () {
            return _this._start(function (child) {
                _this._process = child;
                _this._handle = common_1.createCompositeHandle(_this._handle || { destroy: function () { } }, util_1.on(child.stdout, 'data', proxyIOEvent(_this, 'stdout')), util_1.on(child.stderr, 'data', proxyIOEvent(_this, 'stderr')), util_1.on(child, 'exit', function () {
                    _this._state = 'stopped';
                }));
            });
        });
        this._startTask
            .then(function () {
            _this._startTask = undefined;
            _this._state = 'running';
            _this.emit({
                type: 'status',
                target: _this,
                status: 'Ready'
            });
        })
            .catch(function (error) {
            _this._startTask = undefined;
            _this._state = 'stopped';
            _this.emit({
                type: 'status',
                target: _this,
                status: error.name === 'CancelError'
                    ? 'Start cancelled'
                    : 'Failed to start tunnel'
            });
        });
        return this._startTask;
    };
    /**
     * Stops the tunnel.
     *
     * @returns A promise that resolves to the exit code for the tunnel once it
     * has been terminated.
     */
    Tunnel.prototype.stop = function () {
        var _this = this;
        switch (this._state) {
            case 'starting':
                this._startTask.cancel();
                return this._startTask.finally(function () { return null; });
            case 'stopping':
                return this._stopTask;
        }
        this._state = 'stopping';
        this.emit({
            type: 'status',
            target: this,
            status: 'Stopping'
        });
        this._stopTask = this._stop()
            .then(function (returnValue) {
            if (_this._handle) {
                _this._handle.destroy();
            }
            _this._process = _this._handle = undefined;
            _this._state = 'stopped';
            _this.emit({
                type: 'status',
                target: _this,
                status: 'Stopped'
            });
            return returnValue;
        })
            .catch(function (error) {
            _this._state = 'running';
            throw error;
        });
        return this._stopTask;
    };
    Tunnel.prototype._downloadFile = function (url, proxy, options) {
        var _this = this;
        var req;
        if (!url) {
            return common_1.Task.reject(new Error('URL is empty'));
        }
        return new common_1.Task(function (resolve, reject) {
            req = common_1.request(url, {
                proxy: proxy,
                onDownloadProgress: function (event) {
                    _this.emit({
                        type: 'downloadprogress',
                        target: _this,
                        url: url,
                        total: event.total,
                        received: event.received
                    });
                }
            });
            req
                .then(function (response) {
                if (response.status >= 400) {
                    throw new Error("Download server returned status code " + response.status + " for " + url);
                }
                else {
                    response.arrayBuffer().then(function (data) {
                        resolve(_this._postDownloadFile(Buffer.from(data), options));
                    });
                }
            })
                .catch(function (error) {
                reject(error);
            });
        }, function () {
            req && req.cancel();
        });
    };
    /**
     * Creates the list of command-line arguments to be passed to the spawned
     * tunnel. Implementations should override this method to provide the
     * appropriate command-line arguments.
     *
     * Arguments passed to [[Tunnel._makeChild]] will be passed as-is to this
     * method.
     *
     * @returns A list of command-line arguments.
     */
    Tunnel.prototype._makeArgs = function () {
        var _values = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            _values[_i] = arguments[_i];
        }
        return [];
    };
    /**
     * Creates a newly spawned child process for the tunnel software.
     * Implementations should call this method to create the tunnel process.
     *
     * Arguments passed to this method will be passed as-is to
     * [[Tunnel._makeArgs]] and [[Tunnel._makeOptions]].
     *
     * @returns An object containing a newly spawned Process and a Deferred that
     * will be resolved once the tunnel has started successfully.
     */
    Tunnel.prototype._makeChild = function (executor) {
        var values = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            values[_i - 1] = arguments[_i];
        }
        var command = this.executable;
        var args = this._makeArgs.apply(this, values);
        var options = this._makeOptions.apply(this, values);
        var child = child_process_1.spawn(command, args, options);
        child.stdout.setEncoding('utf8');
        child.stderr.setEncoding('utf8');
        var handle;
        var canceled = false;
        var task = new common_1.Task(function (resolve, reject) {
            var errorMessage = '';
            var exitCode;
            var stderrClosed = false;
            var exitted = false;
            function handleChildExit() {
                reject(new Error("Tunnel failed to start: " + (errorMessage ||
                    "Exit code: " + exitCode)));
            }
            handle = common_1.createCompositeHandle(util_1.on(child, 'error', reject), util_1.on(child.stderr, 'data', function (data) {
                errorMessage += data;
            }), util_1.on(child, 'exit', function () {
                exitted = true;
                if (stderrClosed) {
                    handleChildExit();
                }
            }), 
            // stderr might still have data in buffer at the time the
            // exit event is sent, so we have to store data from stderr
            // and the exit code and reject only once stderr closes
            util_1.on(child.stderr, 'close', function () {
                stderrClosed = true;
                if (exitted) {
                    handleChildExit();
                }
            }));
            var result = executor(child, resolve, reject);
            if (result) {
                handle = common_1.createCompositeHandle(handle, result);
            }
        }, function () {
            canceled = true;
            // Make a best effort to kill the process, but don't throw
            // exceptions
            try {
                util_1.kill(child.pid);
            }
            catch (error) { }
        });
        return task.finally(function () {
            handle.destroy();
            if (canceled) {
                // We only want this to run when cancelation has occurred
                return new Promise(function (resolve) {
                    child.once('exit', function () {
                        resolve();
                    });
                });
            }
        });
    };
    /**
     * Creates the set of options to use when spawning the tunnel process.
     * Implementations should override this method to provide the appropriate
     * options for the tunnel software.
     *
     * Arguments passed to [[Tunnel._makeChild]] will be passed as-is to this
     * method.
     *
     * @returns A set of options matching those provided to Node.js
     * `child_process.spawn`.
     */
    Tunnel.prototype._makeOptions = function () {
        var _values = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            _values[_i] = arguments[_i];
        }
        return { env: process.env };
    };
    /**
     * Normalizes a specific Tunnel environment descriptor to a general form. To
     * be overriden by a child implementation.
     *
     * @param environment an environment descriptor specific to the Tunnel
     * @returns a normalized environment
     */
    Tunnel.prototype._normalizeEnvironment = function (environment) {
        return environment;
    };
    /**
     * Called with the response after a file download has completed
     */
    Tunnel.prototype._postDownloadFile = function (data, options) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            var directory = _this.directory;
            if (options && options.directory) {
                directory = path_1.join(directory, options.directory);
            }
            decompress(data, directory)
                .then(function () { return resolve(); })
                .catch(reject);
        });
    };
    /**
     * This method provides the implementation that actually starts the tunnel
     * and any other logic for emitting events on the Tunnel based on data
     * passed by the tunnel software.
     *
     * The default implementation that assumes the tunnel is ready for use once
     * the child process has written to `stdout` or `stderr`. This method should
     * be reimplemented by other tunnel launchers to implement correct launch
     * detection logic.
     *
     * @returns An object containing a reference to the child process, and a
     * Deferred that is resolved once the tunnel is ready for use. Normally this
     * will be the object returned from a call to [[Tunnel._makeChild]].
     */
    Tunnel.prototype._start = function (executor) {
        return this._makeChild(function (child, resolve, reject) {
            var handle = common_1.createCompositeHandle(util_1.on(child.stdout, 'data', resolve), util_1.on(child.stderr, 'data', resolve), util_1.on(child, 'error', function (error) {
                reject(error);
            }));
            try {
                executor(child, resolve, reject);
            }
            catch (error) {
                reject(error);
            }
            return handle;
        });
    };
    /**
     * This method provides the implementation that actually stops the tunnel.
     *
     * The default implementation that assumes the tunnel has been closed once
     * the child process has exited. This method should be reimplemented by
     * other tunnel launchers to implement correct shutdown logic, if necessary.
     *
     * @returns A promise that resolves once the tunnel has shut down.
     */
    Tunnel.prototype._stop = function () {
        var _this = this;
        return new Promise(function (resolve, reject) {
            var childProcess = _this._process;
            if (!childProcess) {
                resolve();
                return;
            }
            childProcess.once('exit', function (code) {
                resolve(code);
            });
            try {
                util_1.kill(childProcess.pid);
            }
            catch (error) {
                reject(error);
            }
        });
    };
    return Tunnel;
}(common_1.Evented));
exports.default = Tunnel;
function proxyIOEvent(target, type) {
    return function (data) {
        target.emit({
            type: type,
            target: target,
            data: String(data)
        });
    };
}
delete Tunnel.prototype.on;
//# sourceMappingURL=Tunnel.js.map