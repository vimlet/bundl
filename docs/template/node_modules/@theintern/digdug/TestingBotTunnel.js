"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Tunnel_1 = require("./Tunnel");
var fs_1 = require("fs");
var querystring_1 = require("querystring");
var os_1 = require("os");
var path_1 = require("path");
var common_1 = require("@theintern/common");
var url_1 = require("url");
var util_1 = require("./lib/util");
/**
 * A TestingBot tunnel.
 *
 * The username and accessKey properties will be initialized using
 * TESTINGBOT_API_KEY and TESTINGBOT_API_SECRET.
 */
var TestingBotTunnel = /** @class */ (function (_super) {
    __extends(TestingBotTunnel, _super);
    function TestingBotTunnel(options) {
        return _super.call(this, Object.assign({
            username: process.env.TESTINGBOT_KEY,
            accessKey: process.env.TESTINGBOT_SECRET,
            directory: path_1.join(__dirname, 'testingbot'),
            environmentUrl: 'https://api.testingbot.com/v1/browsers',
            executable: 'java',
            fastFailDomains: [],
            logFile: null,
            port: 4445,
            url: 'https://testingbot.com/downloads/testingbot-tunnel.zip',
            useCompression: false,
            useJettyProxy: true,
            useSquidProxy: true,
            useSsl: false
        }, options || {})) || this;
    }
    Object.defineProperty(TestingBotTunnel.prototype, "auth", {
        get: function () {
            return (this.username || '') + ":" + (this.accessKey || '');
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TestingBotTunnel.prototype, "isDownloaded", {
        get: function () {
            return util_1.fileExists(path_1.join(this.directory, 'testingbot-tunnel/testingbot-tunnel.jar'));
        },
        enumerable: true,
        configurable: true
    });
    TestingBotTunnel.prototype._makeArgs = function (readyFile) {
        if (!this.username || !this.accessKey) {
            throw new Error('TestingBotTunnel requires a username and access key');
        }
        var args = [
            '-jar',
            path_1.join(this.directory, 'testingbot-tunnel', 'testingbot-tunnel.jar'),
            this.username,
            this.accessKey,
            '-P',
            this.port,
            '-f',
            readyFile
        ];
        this.fastFailDomains.length &&
            args.push('-F', this.fastFailDomains.join(','));
        this.logFile && args.push('-l', this.logFile);
        this.useJettyProxy || args.push('-x');
        this.useSquidProxy || args.push('-q');
        this.useCompression && args.push('-b');
        this.useSsl && args.push('-s');
        this.verbose && args.push('-d');
        if (this.proxy) {
            var proxy = url_1.parse(this.proxy);
            proxy.hostname && args.unshift('-Dhttp.proxyHost=', proxy.hostname);
            proxy.port && args.unshift('-Dhttp.proxyPort=', proxy.port);
        }
        return args;
    };
    TestingBotTunnel.prototype.sendJobState = function (jobId, data) {
        var params = {};
        if (data.success != null) {
            params['test[success]'] = String(data.success ? 1 : 0);
        }
        if (data.status) {
            params['test[status_message]'] = data.status;
        }
        if (data.name) {
            params['test[name]'] = data.name;
        }
        if (data.extra) {
            params['test[extra]'] = JSON.stringify(data.extra);
        }
        if (data.tags && data.tags.length) {
            params['groups'] = data.tags.join(',');
        }
        var url = "https://api.testingbot.com/v1/tests/" + jobId;
        var payload = querystring_1.stringify(params);
        return common_1.request(url, {
            method: 'put',
            data: payload,
            headers: {
                'Content-Length': String(Buffer.byteLength(payload, 'utf8')),
                'Content-Type': 'application/x-www-form-urlencoded'
            },
            password: this.accessKey,
            username: this.username,
            proxy: this.proxy
        }).then(function (response) {
            return response.text().then(function (text) {
                if (text) {
                    var data_1 = JSON.parse(text);
                    if (data_1.error) {
                        throw new Error(data_1.error);
                    }
                    else if (!data_1.success) {
                        throw new Error('Job data failed to save.');
                    }
                    else if (response.status !== 200) {
                        throw new Error("Server reported " + response.status + " with: " + text);
                    }
                }
                else {
                    throw new Error("Server reported " + response.status + " with no other data.");
                }
            });
        });
    };
    TestingBotTunnel.prototype._start = function (executor) {
        var _this = this;
        var readyFile = path_1.join(os_1.tmpdir(), 'testingbot-' + Date.now());
        return this._makeChild(function (child, resolve, reject) {
            function _reject(message) {
                var pidFile = 'testingbot-tunnel.pid';
                if (fs_1.existsSync(pidFile)) {
                    // Remove the pidfile to ensure the running tunnel app shuts
                    // down
                    fs_1.unlinkSync(pidFile);
                }
                reject(message);
            }
            // Polling API is used because we are only watching for one file, so
            // efficiency is not a big deal, and the `fs.watch` API has extra
            // restrictions which are best avoided
            fs_1.watchFile(readyFile, { persistent: false, interval: 1007 }, function (current, previous) {
                if (Number(current.mtime) === Number(previous.mtime)) {
                    // readyFile hasn't been modified, so ignore the event
                    return;
                }
                fs_1.unwatchFile(readyFile);
                resolve();
            });
            var lastMessage;
            _this._handle = util_1.on(child.stderr, 'data', function (data) {
                data = String(data);
                data.split('\n').forEach(function (message) {
                    if (message.indexOf('INFO: ') === 0) {
                        message = message.slice('INFO: '.length);
                        // the tunnel produces a lot of repeating messages
                        // during setup when the status is pending; deduplicate
                        // them for sanity
                        if (message !== lastMessage &&
                            message.indexOf('>> [') === -1 &&
                            message.indexOf('<< [') === -1) {
                            _this.emit({
                                type: 'status',
                                target: _this,
                                status: message
                            });
                            lastMessage = message;
                        }
                    }
                    else if (message.indexOf('SEVERE: ') === 0) {
                        _reject(message);
                    }
                    else if (message.indexOf('An error ocurred:') === 0) {
                        _reject(message);
                    }
                });
            });
            executor(child, resolve, reject);
        }, readyFile);
    };
    /**
     * Attempt to normalize a TestingBot described environment with the standard
     * Selenium capabilities
     *
     * TestingBot returns a list of environments that looks like:
     *
     * {
     *     "selenium_name": "Chrome36",
     *     "name": "googlechrome",
     *     "platform": "CAPITAN",
     *     "version":"36"
     * }
     *
     * @param environment a TestingBot environment descriptor
     * @returns a normalized descriptor
     */
    TestingBotTunnel.prototype._normalizeEnvironment = function (environment) {
        var browserMap = {
            googlechrome: 'chrome',
            iexplore: 'internet explorer'
        };
        var platform = environment.platform;
        var browserName = browserMap[environment.name] || environment.name;
        var version = environment.version;
        return {
            platform: platform,
            browserName: browserName,
            version: version,
            descriptor: environment,
            intern: {
                platform: platform,
                browserName: browserName,
                version: version
            }
        };
    };
    return TestingBotTunnel;
}(Tunnel_1.default));
exports.default = TestingBotTunnel;
//# sourceMappingURL=TestingBotTunnel.js.map