"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var Element_1 = require("./Element");
var findDisplayed_1 = require("./lib/findDisplayed");
var common_1 = require("@theintern/common");
var statusCodes_1 = require("./lib/statusCodes");
var Locator_1 = require("./lib/Locator");
var util_1 = require("./lib/util");
var waitForDeleted_1 = require("./lib/waitForDeleted");
/**
 * A Session represents a connection to a remote environment that can be driven
 * programmatically.
 */
var Session = /** @class */ (function (_super) {
    __extends(Session, _super);
    /**
     * A Session represents a connection to a remote environment that can be
     * driven programmatically.
     *
     * @param sessionId The ID of the session, as provided by the remote.
     * @param server The server that the session belongs to.
     * @param capabilities A map of bugs and features that the remote
     * environment exposes.
     */
    function Session(sessionId, server, capabilities) {
        var _this = _super.call(this) || this;
        _this._closedWindows = null;
        // TODO: Timeouts are held so that we can fiddle with the implicit wait
        // timeout to add efficient `waitFor` and `waitForDeleted` convenience
        // methods. Technically only the implicit timeout is necessary.
        _this._timeouts = {};
        _this._movedToElement = false;
        _this._lastMousePosition = null;
        _this._lastAltitude = null;
        _this._sessionId = sessionId;
        _this._server = server;
        _this._capabilities = capabilities;
        _this._closedWindows = {};
        _this._timeouts = {
            script: common_1.Task.resolve(0),
            implicit: common_1.Task.resolve(0),
            'page load': common_1.Task.resolve(Infinity)
        };
        return _this;
    }
    Object.defineProperty(Session.prototype, "capabilities", {
        /**
         * Information about the available features and bugs in the remote
         * environment.
         */
        get: function () {
            return this._capabilities;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Session.prototype, "sessionId", {
        /**
         * The current session ID.
         */
        get: function () {
            return this._sessionId;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Session.prototype, "server", {
        /**
         * The Server that the session runs on.
         */
        get: function () {
            return this._server;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Delegates the HTTP request for a method to the underlying
     * [[Server.Server]] object.
     */
    Session.prototype._delegateToServer = function (method, path, requestData, pathParts) {
        var _this = this;
        path = 'session/' + this._sessionId + (path ? '/' + path : '');
        if (method === 'post' &&
            !requestData &&
            this.capabilities.brokenEmptyPost) {
            requestData = {};
        }
        var cancelled = false;
        return new common_1.Task(function (resolve) {
            // The promise is cleared from `_nextRequest` once it has been
            // resolved in order to avoid infinitely long chains of promises
            // retaining values that are not used any more
            var thisRequest;
            var clearNextRequest = function () {
                if (_this._nextRequest === thisRequest) {
                    _this._nextRequest = undefined;
                }
            };
            var runRequest = function () {
                // `runRequest` is normally called once the previous request is
                // finished. If this request is cancelled before the previous
                // request is finished, then it should simply never run. (This
                // Task will have been rejected already by the cancellation.)
                if (cancelled) {
                    clearNextRequest();
                    return;
                }
                var response = _this._server[method](path, requestData, pathParts).then(function (response) { return response.value; });
                // safePromise is simply a promise based on the response that
                // is guaranteed to resolve -- it is only used for promise
                // chain management
                var safePromise = response.catch(function (_error) { });
                safePromise.then(clearNextRequest);
                // The value of the response always needs to be taken directly
                // from the server call rather than from the chained
                // `_nextRequest` promise, since if an undefined value is
                // returned by the server call and that value is returned
                // through `finally(runRequest)`, the *previous* Taskâ€™s
                // resolved value will be used as the resolved value, which is
                // wrong
                resolve(response);
                return safePromise;
            };
            // At least ChromeDriver 2.19 will just hard close connections if
            // parallel requests are made to the server, so any request sent to
            // the server for a given session must be serialised. Other servers
            // like Selendroid have been known to have issues with parallel
            // requests as well, so serialisation is applied universally, even
            // though it has negative performance implications
            if (_this._nextRequest) {
                thisRequest = _this._nextRequest = _this._nextRequest.finally(runRequest);
            }
            else {
                thisRequest = _this._nextRequest = runRequest();
            }
        }, function () { return (cancelled = true); });
    };
    Session.prototype.serverGet = function (path, requestData, pathParts) {
        return this._delegateToServer('get', path, requestData, pathParts);
    };
    Session.prototype.serverPost = function (path, requestData, pathParts) {
        return this._delegateToServer('post', path, requestData, pathParts);
    };
    Session.prototype.serverDelete = function (path, requestData, pathParts) {
        return this._delegateToServer('delete', path, requestData, pathParts);
    };
    /**
     * Gets the current value of a timeout for the session.
     *
     * @param type The type of timeout to retrieve. One of 'script',
     * 'implicit', or 'page load'.
     * @returns The timeout, in milliseconds.
     */
    Session.prototype.getTimeout = function (type) {
        if (this.capabilities.supportsGetTimeouts) {
            return this.serverGet('timeouts').then(function (timeouts) { return (type === 'page load' ? timeouts.pageLoad : timeouts[type]); });
        }
        else {
            return this._timeouts[type];
        }
    };
    /**
     * Sets the value of a timeout for the session.
     *
     * @param type The type of timeout to set. One of 'script', 'implicit', or
     * 'page load'.
     *
     * @param ms The length of time to use for the timeout, in milliseconds. A
     * value of 0 will cause operations to time out immediately.
     */
    Session.prototype.setTimeout = function (type, ms) {
        var _this = this;
        var _a;
        // Infinity cannot be serialised by JSON
        if (ms === Infinity) {
            // It seems that at least ChromeDriver 2.10 has a limit here that
            // is near the 32-bit signed integer limit, and IEDriverServer
            // 2.42.2 has an even lower limit; 2.33 hours should be infinite
            // enough for testing
            ms = Math.pow(2, 23) - 1;
        }
        // If the target doesn't support a timeout of 0, use 1.
        if (this.capabilities.brokenZeroTimeout && ms === 0) {
            ms = 1;
        }
        // Set both JSONWireProtocol and WebDriver properties in the data object
        var data = this.capabilities.usesWebDriverTimeouts
            ? (_a = {},
                _a[type === 'page load' ? 'pageLoad' : type] = ms,
                _a) : {
            type: type,
            ms: ms
        };
        var promise = this.serverPost('timeouts', data).catch(function (error) {
            // Appium as of April 2014 complains that `timeouts` is
            // unsupported, so try the more specific endpoints if they exist
            if (error.name === 'UnknownCommand') {
                if (type === 'script') {
                    return _this.serverPost('timeouts/async_script', {
                        ms: ms
                    });
                }
                else if (type === 'implicit') {
                    return _this.serverPost('timeouts/implicit_wait', {
                        ms: ms
                    });
                }
            }
            else if (!_this.capabilities.usesWebDriverTimeouts &&
                // At least Chrome 60+
                (/Missing 'type' parameter/.test(error.message) ||
                    // At least Safari 10+
                    /Unknown timeout type/.test(error.message) ||
                    // IE11
                    /Invalid timeout type specified/.test(error.message))) {
                _this.capabilities.usesWebDriverTimeouts = true;
                return _this.setTimeout(type, ms);
            }
            throw error;
        });
        this._timeouts[type] = promise.then(function () { return ms; }).catch(function () { return 0; });
        return promise;
    };
    /**
     * Gets the identifier for the window that is currently focused.
     *
     * @returns A window handle identifier that can be used with other window
     * handling functions.
     */
    Session.prototype.getCurrentWindowHandle = function () {
        var _this = this;
        var endpoint = this.capabilities.usesWebDriverWindowHandleCommands
            ? 'window'
            : 'window_handle';
        return this.serverGet(endpoint)
            .then(function (handle) {
            if (_this.capabilities.brokenDeleteWindow &&
                _this._closedWindows[handle]) {
                var error = new Error();
                error.status = '23';
                error.name = statusCodes_1.default[error.status][0];
                error.message = statusCodes_1.default[error.status][1];
                throw error;
            }
            return handle;
        })
            .catch(function (error) {
            if (
            // At least Edge 44.17763 returns an UnknownError when it doesn't
            // support /window_handle, whereas most drivers return an
            // UnknownCommand error.
            /^Unknown/.test(error.name) &&
                !_this.capabilities.usesWebDriverWindowHandleCommands) {
                _this.capabilities.usesWebDriverWindowHandleCommands = true;
                return _this.getCurrentWindowHandle();
            }
            throw error;
        });
    };
    /**
     * Gets a list of identifiers for all currently open windows.
     */
    Session.prototype.getAllWindowHandles = function () {
        var _this = this;
        var endpoint = this.capabilities.usesWebDriverWindowHandleCommands
            ? 'window/handles'
            : 'window_handles';
        return this.serverGet(endpoint)
            .then(function (handles) {
            if (_this.capabilities.brokenDeleteWindow) {
                return handles.filter(function (handle) {
                    return !_this._closedWindows[handle];
                });
            }
            return handles;
        })
            .catch(function (error) {
            if (error.name === 'UnknownCommand' &&
                !_this.capabilities.usesWebDriverWindowHandleCommands) {
                _this.capabilities.usesWebDriverWindowHandleCommands = true;
                return _this.getAllWindowHandles();
            }
            throw error;
        });
    };
    /**
     * Gets the URL that is loaded in the focused window/frame.
     */
    Session.prototype.getCurrentUrl = function () {
        return this.serverGet('url');
    };
    /**
     * Navigates the focused window/frame to a new URL.
     */
    Session.prototype.get = function (url) {
        this._movedToElement = false;
        if (this.capabilities.brokenMouseEvents) {
            this._lastMousePosition = { x: 0, y: 0 };
        }
        return this.serverPost('url', { url: url });
    };
    /**
     * Navigates the focused window/frame forward one page using the browserâ€™s
     * navigation history.
     */
    Session.prototype.goForward = function () {
        // TODO: SPEC: Seems like this and `back` should return the newly
        // navigated URL.
        return this.serverPost('forward');
    };
    /**
     * Navigates the focused window/frame back one page using the browserâ€™s
     * navigation history.
     */
    Session.prototype.goBack = function () {
        // TODO: SPEC: Seems like this and `back` should return the newly
        // navigated URL.
        return this.serverPost('back');
    };
    /**
     * Reloads the current browser window/frame.
     */
    Session.prototype.refresh = function () {
        if (this.capabilities.brokenRefresh) {
            return this.execute('location.reload();');
        }
        return this.serverPost('refresh');
    };
    /**
     * Executes JavaScript code within the focused window/frame. The code
     * should return a value synchronously.
     *
     * See [[Session.Session.executeAsync]] to execute code that returns values
     * asynchronously.
     *
     * @param script The code to execute. This function will always be
     * converted to a string, sent to the remote environment, and reassembled
     * as a new anonymous function on the remote end. This means that you
     * cannot access any variables through closure. If your code needs to get
     * data from variables on the local end, they should be passed using
     * `args`.
     *
     * @param args An array of arguments that will be passed to the executed
     * code. Only values that can be serialised to JSON, plus
     * [[Element.Element]] objects, can be specified as arguments.
     *
     * @returns The value returned by the remote code. Only values that can be
     * serialised to JSON, plus DOM elements, can be returned.
     */
    Session.prototype.execute = function (script, args) {
        var _this = this;
        // At least FirefoxDriver 2.40.0 will throw a confusing
        // NullPointerException if args is not an array; provide a friendlier
        // error message to users that accidentally pass a non-array
        if (typeof args !== 'undefined' && !Array.isArray(args)) {
            throw new Error('Arguments passed to execute must be an array');
        }
        var endpoint = this.capabilities.usesWebDriverExecuteSync
            ? 'execute/sync'
            : 'execute';
        var result = this.serverPost(endpoint, {
            script: util_1.toExecuteString(script),
            args: args || []
        })
            .then(function (value) { return convertToElements(_this, value); }, fixExecuteError)
            .catch(function (error) {
            if (error.detail.error === 'unknown command' &&
                !_this.capabilities.usesWebDriverExecuteSync) {
                _this.capabilities.usesWebDriverExecuteSync = true;
                return _this.execute(script, args);
            }
            throw error;
        });
        if (this.capabilities.brokenExecuteUndefinedReturn) {
            result = result.then(function (value) { return (value == null ? null : value); });
        }
        return result;
    };
    /**
     * Executes JavaScript code within the focused window/frame. The code must
     * invoke the provided callback in order to signal that it has completed
     * execution.
     *
     * See [[Session.Session.execute]] to execute code that returns values
     * synchronously.
     *
     * See [[Session.Session.setExecuteAsyncTimeout]] to set the time until an
     * asynchronous script is considered timed out.
     *
     * @param script The code to execute. This function will always be
     * converted to a string, sent to the remote environment, and reassembled
     * as a new anonymous function on the remote end. This means that you
     * cannot access any variables through closure. If your code needs to get
     * data from variables on the local end, they should be passed using
     * `args`.
     *
     * @param args An array of arguments that will be passed to the executed
     * code. Only values that can be serialised to JSON, plus
     * [[Element.Element]] objects, can be specified as arguments. In addition
     * to these arguments, a callback function will always be passed as the
     * final argument to the function specified in `script`. This callback
     * function must be invoked in order to signal that execution has
     * completed. The return value of the execution, if any, should be passed
     * to this callback function.
     *
     * @returns The value returned by the remote code. Only values that can be
     * serialised to JSON, plus DOM elements, can be returned.
     */
    Session.prototype.executeAsync = function (script, args) {
        var _this = this;
        // At least FirefoxDriver 2.40.0 will throw a confusing
        // NullPointerException if args is not an array; provide a friendlier
        // error message to users that accidentally pass a non-array
        if (typeof args !== 'undefined' && !Array.isArray(args)) {
            throw new Error('Arguments passed to executeAsync must be an array');
        }
        var endpoint = this.capabilities.usesWebDriverExecuteAsync
            ? 'execute/async'
            : 'execute_async';
        return this.serverPost(endpoint, {
            script: util_1.toExecuteString(script),
            args: args || []
        })
            .then(common_1.partial(convertToElements, this), fixExecuteError)
            .catch(function (error) {
            if (error.detail.error === 'unknown command' &&
                !_this.capabilities.usesWebDriverExecuteAsync) {
                _this.capabilities.usesWebDriverExecuteAsync = true;
                return _this.executeAsync(script, args);
            }
            // At least Safari 11, Jan 2019 will throw Timeout errors rather than
            // ScriptTimeout errors for script timeouts
            if (error.name === 'Timeout') {
                error.name = 'ScriptTimeout';
            }
            throw error;
        });
    };
    /**
     * Gets a screenshot of the focused window and returns it in PNG format.
     *
     * @returns A buffer containing a PNG image.
     */
    Session.prototype.takeScreenshot = function () {
        return this.serverGet('screenshot').then(function (data) {
            return Buffer.from(data, 'base64');
        });
    };
    /**
     * Gets a list of input method editor engines available to the remote
     * environment. As of April 2014, no known remote environments support IME
     * functions.
     */
    Session.prototype.getAvailableImeEngines = function () {
        return this.serverGet('ime/available_engines');
    };
    /**
     * Gets the currently active input method editor for the remote environment.
     * As of April 2014, no known remote environments support IME functions.
     */
    Session.prototype.getActiveImeEngine = function () {
        return this.serverGet('ime/active_engine');
    };
    /**
     * Returns whether or not an input method editor is currently active in the
     * remote environment. As of April 2014, no known remote environments
     * support IME functions.
     */
    Session.prototype.isImeActivated = function () {
        return this.serverGet('ime/activated');
    };
    /**
     * Deactivates any active input method editor in the remote environment.
     * As of April 2014, no known remote environments support IME functions.
     */
    Session.prototype.deactivateIme = function () {
        return this.serverPost('ime/deactivate');
    };
    /**
     * Activates an input method editor in the remote environment.
     * As of April 2014, no known remote environments support IME functions.
     *
     * @param engine The type of IME to activate.
     */
    Session.prototype.activateIme = function (engine) {
        return this.serverPost('ime/activate', { engine: engine });
    };
    /**
     * Switches the currently focused frame to a new frame.
     *
     * @param id The frame to switch to. In most environments, a number or
     * string value corresponds to a key in the `window.frames` object of the
     * currently active frame. If `null`, the topmost (default) frame will be
     * used. If an Element is provided, it must correspond to a `<frame>` or
     * `<iframe>` element.
     */
    Session.prototype.switchToFrame = function (id) {
        var _this = this;
        if (this.capabilities.usesWebDriverFrameId && typeof id === 'string') {
            return this.findById(id).then(function (element) {
                return _this.serverPost('frame', { id: element });
            });
        }
        return this.serverPost('frame', { id: id }).catch(function (error) {
            if (_this.capabilities.usesWebDriverFrameId == null &&
                (error.name === 'NoSuchFrame' ||
                    // At least geckodriver 0.24.0 throws an Unknown Command error
                    // with a message about an invalid tag name rather than a NoSuchFrame error
                    // (see https://github.com/mozilla/geckodriver/issues/1456)
                    /any variant of untagged/.test(error.detail.message))) {
                _this.capabilities.usesWebDriverFrameId = true;
                return _this.switchToFrame(id);
            }
            throw error;
        });
    };
    /**
     * Switches the currently focused window to a new window.
     *
     * @param handle The handle of the window to switch to. In mobile
     * environments and environments based on the W3C WebDriver standard, this
     * should be a handle as returned by
     * [[Session.Session.getAllWindowHandles]].
     *
     * In environments using the JsonWireProtocol, this value corresponds to
     * the `window.name` property of a window.
     */
    Session.prototype.switchToWindow = function (handle) {
        // const handleProperty = this.capabilities.=== 'selendroid' &&
        var data = { name: handle };
        if (this.capabilities.usesHandleParameter) {
            data = { handle: handle };
        }
        return this.serverPost('window', data);
    };
    /**
     * Switches the currently focused frame to the parent of the currently
     * focused frame.
     */
    Session.prototype.switchToParentFrame = function () {
        var _this = this;
        return this.serverPost('frame/parent').catch(function (error) {
            // At least FirefoxDriver 2.40.0 does not implement this command,
            // but we can fake it by retrieving the parent frame element using
            // JavaScript and switching to it directly by reference At least
            // Selendroid 0.9.0 also does not support this command, but
            // unfortunately throws an incorrect error so it looks like a fatal
            // error; see https://github.com/selendroid/selendroid/issues/364
            if (error.name === 'UnknownCommand' ||
                (_this.capabilities.browserName === 'selendroid' &&
                    error.message.indexOf('Error occured while communicating with selendroid server') > -1)) {
                if (_this.capabilities.scriptedParentFrameCrashesBrowser) {
                    throw error;
                }
                return _this.execute('return window.parent.frameElement;').then(function (parent) {
                    // TODO: Using `null` if no parent frame was returned keeps
                    // the request from being invalid, but may be incorrect and
                    // may cause incorrect frame retargeting on certain
                    // platforms; At least Selendroid 0.9.0 fails both commands
                    return _this.switchToFrame(parent || null);
                });
            }
            throw error;
        });
    };
    /**
     * Closes the currently focused window. In most environments, after the
     * window has been closed, it is necessary to explicitly switch to whatever
     * window is now focused.
     */
    Session.prototype.closeCurrentWindow = function () {
        var _this = this;
        var self = this;
        function manualClose() {
            return self.getCurrentWindowHandle().then(function (handle) {
                return self.execute('window.close();').then(function () {
                    self._closedWindows[handle] = true;
                });
            });
        }
        if (this.capabilities.brokenDeleteWindow) {
            return manualClose();
        }
        return this.serverDelete('window').catch(function (error) {
            // ios-driver 0.6.6-SNAPSHOT April 2014 does not implement close
            // window command
            if (error.name === 'UnknownCommand' &&
                !_this.capabilities.brokenDeleteWindow) {
                _this.capabilities.brokenDeleteWindow = true;
                return manualClose();
            }
            throw error;
        });
    };
    Session.prototype.setWindowSize = function () {
        var _this = this;
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var windowHandle = args[0], width = args[1], height = args[2];
        if (typeof height === 'undefined') {
            height = width;
            width = windowHandle;
            windowHandle = null;
        }
        var data = { width: width, height: height };
        if (this.capabilities.usesWebDriverWindowCommands) {
            var setWindowSize_1 = function () {
                return _this.getWindowPosition().then(function (position) {
                    return _this.setWindowRect({
                        // At least Firefox + geckodriver 0.17.0 requires all 4 rect
                        // parameters have values
                        x: position.x,
                        y: position.y,
                        width: data.width,
                        height: data.height
                    });
                });
            };
            if (windowHandle == null) {
                return setWindowSize_1();
            }
            else {
                // User provided a window handle; get the current handle,
                // switch to the new one, get the size, then switch back to the
                // original handle.
                var error_1;
                return this.getCurrentWindowHandle().then(function (originalHandle) {
                    return _this.switchToWindow(windowHandle)
                        .then(function () { return setWindowSize_1(); })
                        .catch(function (_error) {
                        error_1 = _error;
                    })
                        .then(function () { return _this.switchToWindow(originalHandle); })
                        .then(function () {
                        if (error_1) {
                            throw error_1;
                        }
                    });
                });
            }
        }
        else {
            if (windowHandle == null) {
                windowHandle = 'current';
            }
            return this.serverPost('window/$0/size', { width: width, height: height }, [
                windowHandle
            ]);
        }
    };
    /**
     * Gets the dimensions of a window.
     *
     * @param windowHandle The name of the window to query. See
     * [[Session.Session.switchToWindow]] to learn about valid window names.
     * Omit this argument to query the currently focused window.
     *
     * @returns An object describing the width and height of the window, in CSS
     * pixels.
     */
    Session.prototype.getWindowSize = function (windowHandle) {
        var _this = this;
        if (this.capabilities.usesWebDriverWindowCommands) {
            var getWindowSize_1 = function () {
                return _this.getWindowRect().then(function (rect) { return ({
                    width: rect.width,
                    height: rect.height
                }); });
            };
            if (windowHandle == null) {
                return getWindowSize_1();
            }
            else {
                // User provided a window handle; get the current handle,
                // switch to the new one, get the size, then switch back to the
                // original handle.
                var error_2;
                var size_1;
                return this.getCurrentWindowHandle().then(function (originalHandle) {
                    return _this.switchToWindow(windowHandle)
                        .then(function () { return getWindowSize_1(); })
                        .then(function (_size) {
                        size_1 = _size;
                    }, function (_error) {
                        error_2 = _error;
                    })
                        .then(function () { return _this.switchToWindow(originalHandle); })
                        .then(function () {
                        if (error_2) {
                            throw error_2;
                        }
                        return size_1;
                    });
                });
            }
        }
        else {
            if (windowHandle == null) {
                windowHandle = 'current';
            }
            return this.serverGet('window/$0/size', null, [windowHandle]);
        }
    };
    /**
     * Return the current window's rectangle (size and position).
     */
    Session.prototype.getWindowRect = function () {
        return this.serverGet('window/rect');
    };
    /**
     * Set the current window's rectangle (size and position).
     *
     * @param rect The windows rectangle. This may contain all 4 properties, or
     * just x & y, or just width & height.
     */
    Session.prototype.setWindowRect = function (rect) {
        return this.serverPost('window/rect', rect);
    };
    Session.prototype.setWindowPosition = function () {
        var _this = this;
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var windowHandle = args[0], x = args[1], y = args[2];
        if (typeof y === 'undefined') {
            y = x;
            x = windowHandle;
            windowHandle = null;
        }
        if (this.capabilities.usesWebDriverWindowCommands) {
            // At least Firefox + geckodriver 0.17.0 requires all 4 rect
            // parameters have values
            return this.getWindowSize().then(function (size) {
                var data = { x: x, y: y, width: size.width, height: size.height };
                if (windowHandle == null) {
                    return _this.setWindowRect(data);
                }
                else {
                    // User provided a window handle; get the current handle,
                    // switch to the new one, get the size, then switch back to the
                    // original handle.
                    var error_3;
                    return _this.getCurrentWindowHandle().then(function (originalHandle) {
                        if (originalHandle === windowHandle) {
                            _this.setWindowRect(data);
                        }
                        else {
                            return _this.switchToWindow(windowHandle)
                                .then(function () { return _this.setWindowRect(data); })
                                .catch(function (_error) {
                                error_3 = _error;
                            })
                                .then(function () { return _this.switchToWindow(originalHandle); })
                                .then(function () {
                                if (error_3) {
                                    throw error_3;
                                }
                            });
                        }
                    });
                }
            });
        }
        else {
            if (windowHandle == null) {
                windowHandle = 'current';
            }
            return this.serverPost('window/$0/position', { x: x, y: y }, [
                windowHandle
            ]);
        }
    };
    /**
     * Gets the position of a window.
     *
     * Note that this method is not part of the W3C WebDriver standard.
     *
     * @param windowHandle The name of the window to query. See
     * [[Session.Session.switchToWindow]] to learn about valid window names.
     * Omit this argument to query the currently focused window.
     *
     * @returns An object describing the position of the window, in CSS pixels,
     * relative to the top-left corner of the primary monitor. If a secondary
     * monitor exists above or to the left of the primary monitor, these values
     * will be negative.
     */
    Session.prototype.getWindowPosition = function (windowHandle) {
        var _this = this;
        if (this.capabilities.usesWebDriverWindowCommands) {
            var getWindowPosition_1 = function () {
                return _this.getWindowRect().then(function (_a) {
                    var x = _a.x, y = _a.y;
                    return { x: x, y: y };
                });
            };
            if (windowHandle == null) {
                return getWindowPosition_1();
            }
            else {
                // User provided a window handle; get the current handle,
                // switch to the new one, get the position, then switch back to
                // the original handle.
                var error_4;
                var position_1;
                return this.getCurrentWindowHandle().then(function (originalHandle) {
                    return _this.switchToWindow(windowHandle)
                        .then(function () { return getWindowPosition_1(); })
                        .then(function (_position) {
                        position_1 = _position;
                    }, function (_error) {
                        error_4 = _error;
                    })
                        .then(function () { return _this.switchToWindow(originalHandle); })
                        .then(function () {
                        if (error_4) {
                            throw error_4;
                        }
                        return position_1;
                    });
                });
            }
        }
        else {
            if (typeof windowHandle === 'undefined') {
                windowHandle = 'current';
            }
            return this.serverGet('window/$0/position', null, [windowHandle]).then(function (position) {
                // At least Firefox + geckodriver 0.19.0 will return a full
                // rectangle for the position command.
                return {
                    x: position.x,
                    y: position.y
                };
            });
        }
    };
    /**
     * Maximises a window according to the platformâ€™s window system behaviour.
     *
     * @param windowHandle The name of the window to resize. See
     * [[Session.Session.switchToWindow]] to learn about valid window names.
     * Omit this argument to resize the currently focused window.
     */
    Session.prototype.maximizeWindow = function (windowHandle) {
        var _this = this;
        if (this.capabilities.usesWebDriverWindowCommands) {
            var maximizeWindow_1 = function () { return _this.serverPost('window/maximize'); };
            if (windowHandle == null) {
                return maximizeWindow_1();
            }
            else {
                // User provided a window handle; get the current handle,
                // switch to the new one, get the position, then switch back to
                // the original handle.
                var error_5;
                return this.getCurrentWindowHandle().then(function (originalHandle) {
                    return _this.switchToWindow(windowHandle)
                        .then(function () { return maximizeWindow_1(); })
                        .catch(function (_error) {
                        error_5 = _error;
                    })
                        .then(function () { return _this.switchToWindow(originalHandle); })
                        .then(function () {
                        if (error_5) {
                            throw error_5;
                        }
                    });
                });
            }
        }
        else {
            if (typeof windowHandle === 'undefined') {
                windowHandle = 'current';
            }
            return this.serverPost('window/$0/maximize', null, [windowHandle]);
        }
    };
    /**
     * Gets all cookies set on the current page.
     */
    Session.prototype.getCookies = function () {
        return this.serverGet('cookie').then(function (cookies) {
            // At least SafariDriver 2.41.0 returns cookies with extra class
            // and hCode properties that should not exist
            return (cookies || []).map(function (badCookie) {
                var cookie = {};
                for (var key in badCookie) {
                    if (key === 'name' ||
                        key === 'value' ||
                        key === 'path' ||
                        key === 'domain' ||
                        key === 'secure' ||
                        key === 'httpOnly' ||
                        key === 'expiry') {
                        cookie[key] = badCookie[key];
                    }
                }
                if (typeof cookie.expiry === 'number') {
                    cookie.expiry = new Date(cookie.expiry * 1000);
                }
                return cookie;
            });
        });
    };
    /**
     * Sets a cookie on the current page.
     */
    Session.prototype.setCookie = function (cookie) {
        if (typeof cookie.expiry === 'string') {
            cookie.expiry = new Date(cookie.expiry);
        }
        if (cookie.expiry instanceof Date) {
            cookie.expiry = cookie.expiry.valueOf() / 1000;
        }
        var self = this;
        return this.serverPost('cookie', {
            cookie: cookie
        }).catch(function (error) {
            // At least ios-driver 0.6.0-SNAPSHOT April 2014 does not know how
            // to set cookies
            if (error.name === 'UnknownCommand') {
                // Per RFC6265 section 4.1.1, cookie names must match `token`
                // (any US-ASCII character except for control characters and
                // separators as defined in RFC2616 section 2.2)
                if (/[^A-Za-z0-9!#$%&'*+.^_`|~-]/.test(cookie.name)) {
                    error = new Error();
                    error.status = '25';
                    error.name = statusCodes_1.default[error.status][0];
                    error.message = 'Invalid cookie name';
                    throw error;
                }
                if (/[^\u0021\u0023-\u002b\u002d-\u003a\u003c-\u005b\u005d-\u007e]/.test(cookie.value)) {
                    error = new Error();
                    error.status = '25';
                    error.name = statusCodes_1.default[error.status][0];
                    error.message = 'Invalid cookie value';
                    throw error;
                }
                var cookieToSet = [cookie.name + '=' + cookie.value];
                pushCookieProperties(cookieToSet, cookie);
                return self.execute(
                /* istanbul ignore next */ function (cookie) {
                    document.cookie = cookie;
                }, [cookieToSet.join(';')]);
            }
            throw error;
        });
    };
    /**
     * Clears all cookies for the current page.
     */
    Session.prototype.clearCookies = function () {
        var _this = this;
        if (this.capabilities.brokenDeleteCookie) {
            return this.getCookies().then(function (cookies) {
                return cookies.reduce(function (promise, cookie) {
                    var expiredCookie = [
                        cookie.name + "=",
                        'expires=Thu, 01 Jan 1970 00:00:00 GMT'
                    ];
                    pushCookieProperties(expiredCookie, cookie);
                    return promise.then(function () {
                        return _this.execute(
                        /* istanbul ignore next */ function (expiredCookie) {
                            // Assume the cookie was created by Selenium,
                            // so its path is '/'; at least MS Edge
                            // requires a path to delete a cookie
                            document.cookie = expiredCookie + "; domain=" + encodeURIComponent(document.domain) + "; path=/";
                        }, [expiredCookie.join(';')]);
                    });
                }, common_1.Task.resolve());
            });
        }
        return this.serverDelete('cookie');
    };
    /**
     * Deletes a cookie on the current page.
     *
     * @param name The name of the cookie to delete.
     */
    Session.prototype.deleteCookie = function (name) {
        var _this = this;
        if (this.capabilities.brokenDeleteCookie) {
            return this.getCookies().then(function (cookies) {
                var cookie;
                if (cookies.some(function (value) {
                    if (value.name === name) {
                        cookie = value;
                        return true;
                    }
                    return false;
                })) {
                    var expiredCookie = [
                        cookie.name + "=",
                        'expires=Thu, 01 Jan 1970 00:00:00 GMT'
                    ];
                    pushCookieProperties(expiredCookie, cookie);
                    return _this.execute(
                    /* istanbul ignore next */ function (expiredCookie) {
                        // Assume the cookie was created by Selenium, so
                        // its path is '/'; at least MS Edge requires a
                        // path to delete a cookie
                        document.cookie = expiredCookie + "; domain=" + encodeURIComponent(document.domain) + "; path=/";
                    }, [expiredCookie.join(';')]);
                }
            });
        }
        return this.serverDelete('cookie/$0', null, [name]);
    };
    /**
     * Gets the HTML loaded in the focused window/frame. This markup is
     * serialised by the remote environment so may not exactly match the HTML
     * provided by the Web server.
     */
    Session.prototype.getPageSource = function () {
        if (this.capabilities.brokenPageSource) {
            return this.execute(
            /* istanbul ignore next */ function () {
                return document.documentElement.outerHTML;
            });
        }
        else {
            return this.serverGet('source');
        }
    };
    /**
     * Gets the title of the top-level browsing context of the current window
     * or tab.
     */
    Session.prototype.getPageTitle = function () {
        return this.serverGet('title');
    };
    /**
     * Gets the first element from the focused window/frame that matches the
     * given query.
     *
     * See [[Session.Session.setFindTimeout]] to set the amount of time it the
     * remote environment should spend waiting for an element that does not
     * exist at the time of the `find` call before timing out.
     *
     * @param using The element retrieval strategy to use. One of 'class name',
     * 'css selector', 'id', 'name', 'link text', 'partial link text', 'tag
     * name', 'xpath'.
     *
     * @param value The strategy-specific value to search for. For example, if
     * `using` is 'id', `value` should be the ID of the element to retrieve.
     */
    Session.prototype.find = function (using, value) {
        var _this = this;
        if (this.capabilities.usesWebDriverLocators) {
            var locator = Locator_1.toW3cLocator(using, value);
            using = locator.using;
            value = locator.value;
        }
        if (using.indexOf('link text') !== -1 &&
            (this.capabilities.brokenWhitespaceNormalization ||
                this.capabilities.brokenLinkTextLocator)) {
            return this.execute(util_1.manualFindByLinkText, [using, value]).then(function (element) {
                if (!element) {
                    var error = new Error();
                    error.name = 'NoSuchElement';
                    throw error;
                }
                return new Element_1.default(element, _this);
            });
        }
        return this.serverPost('element', {
            using: using,
            value: value
        }).then(function (element) {
            return new Element_1.default(element, _this);
        }, function (error) {
            if (!_this.capabilities.usesWebDriverLocators &&
                /search strategy: 'id'/.test(error.message)) {
                _this.capabilities.usesWebDriverLocators = true;
                return _this.find(using, value);
            }
            throw error;
        });
    };
    /**
     * Gets an array of elements from the focused window/frame that match the
     * given query.
     *
     * @param using The element retrieval strategy to use. See
     * [[Session.Session.find]] for options.
     *
     * @param value The strategy-specific value to search for. See
     * [[Session.Session.find]] for details.
     */
    Session.prototype.findAll = function (using, value) {
        var _this = this;
        if (this.capabilities.usesWebDriverLocators) {
            var locator = Locator_1.toW3cLocator(using, value);
            using = locator.using;
            value = locator.value;
        }
        if (using.indexOf('link text') !== -1 &&
            (this.capabilities.brokenWhitespaceNormalization ||
                this.capabilities.brokenLinkTextLocator)) {
            return this.execute(util_1.manualFindByLinkText, [
                using,
                value,
                true
            ]).then(function (elements) {
                return elements.map(function (element) {
                    return new Element_1.default(element, _this);
                });
            });
        }
        return this.serverPost('elements', {
            using: using,
            value: value
        }).then(function (elements) {
            return elements.map(function (element) {
                return new Element_1.default(element, _this);
            });
        }, function (error) {
            if (!_this.capabilities.usesWebDriverLocators &&
                /search strategy: 'id'/.test(error.message)) {
                _this.capabilities.usesWebDriverLocators = true;
                return _this.findAll(using, value);
            }
            throw error;
        });
    };
    /**
     * Gets the currently focused element from the focused window/frame.
     */
    Session.prototype.getActiveElement = function () {
        var _this = this;
        var getDocumentActiveElement = function () {
            return _this.execute('return document.activeElement;');
        };
        if (this.capabilities.brokenActiveElement) {
            return getDocumentActiveElement();
        }
        else {
            var task = void 0;
            if (this.capabilities.usesWebDriverActiveElement) {
                task = this.serverGet('element/active');
            }
            else {
                task = this.serverPost('element/active');
            }
            return task.then(function (element) {
                if (element) {
                    return new Element_1.default(element, _this);
                }
                else {
                    // The driver will return `null` if the active element is
                    // the body element; for consistency with how the DOM
                    // `document.activeElement` property works, weâ€™ll diverge
                    // and always return an element
                    return getDocumentActiveElement();
                }
            }, function (error) {
                if (error.name === 'UnknownMethod' &&
                    !_this.capabilities.usesWebDriverActiveElement) {
                    _this.capabilities.usesWebDriverActiveElement = true;
                    return _this.getActiveElement();
                }
                throw error;
            });
        }
    };
    /**
     * Types into the focused window/frame/element.
     *
     * @param keys The text to type in the remote environment. It is possible
     * to type keys that do not have normal character representations (modifier
     * keys, function keys, etc.) as well as keys that have two different
     * representations on a typical US-ASCII keyboard (numpad keys); use the
     * values from [[keys]] to type these special characters. Any modifier keys
     * that are activated by this call will persist until they are deactivated.
     * To deactivate a modifier key, type the same modifier key a second time,
     * or send `\uE000` ('NULL') to deactivate all currently active modifier
     * keys.
     */
    Session.prototype.pressKeys = function (keys) {
        if (!Array.isArray(keys)) {
            keys = [keys];
        }
        if (this.capabilities.brokenSendKeys || this.capabilities.noKeysCommand) {
            return this.execute(simulateKeys, [keys]);
        }
        return this.serverPost('keys', {
            value: keys
        });
    };
    /**
     * Gets the current screen orientation.
     *
     * @returns Either 'portrait' or 'landscape'.
     */
    Session.prototype.getOrientation = function () {
        return this.serverGet('orientation').then(function (orientation) {
            return orientation.toLowerCase();
        });
    };
    /**
     * Sets the screen orientation.
     *
     * @param orientation Either 'portrait' or 'landscape'.
     */
    Session.prototype.setOrientation = function (orientation) {
        orientation = orientation.toUpperCase();
        return this.serverPost('orientation', {
            orientation: orientation
        });
    };
    /**
     * Gets the text displayed in the currently active alert pop-up.
     */
    Session.prototype.getAlertText = function () {
        return this.serverGet('alert_text');
    };
    /**
     * Types into the currently active prompt pop-up.
     *
     * @param text The text to type into the pop-upâ€™s input box.
     */
    Session.prototype.typeInPrompt = function (text) {
        if (Array.isArray(text)) {
            text = text.join('');
        }
        return this.serverPost('alert_text', {
            text: text
        });
    };
    /**
     * Accepts an alert, prompt, or confirmation pop-up. Equivalent to clicking
     * the 'OK' button.
     */
    Session.prototype.acceptAlert = function () {
        return this.serverPost('accept_alert');
    };
    /**
     * Dismisses an alert, prompt, or confirmation pop-up. Equivalent to
     * clicking the 'OK' button of an alert pop-up or the 'Cancel' button of a
     * prompt or confirmation pop-up.
     */
    Session.prototype.dismissAlert = function () {
        return this.serverPost('dismiss_alert');
    };
    Session.prototype.moveMouseTo = function () {
        var _this = this;
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var element = args[0], xOffset = args[1], yOffset = args[2];
        if (typeof yOffset === 'undefined' && typeof xOffset !== 'undefined') {
            yOffset = xOffset;
            xOffset = element;
            element = null;
        }
        if (this.capabilities.brokenMouseEvents) {
            return this.execute(simulateMouse, [
                {
                    action: 'mousemove',
                    position: this._lastMousePosition,
                    element: element,
                    xOffset: xOffset,
                    yOffset: yOffset
                }
            ]).then(function (newPosition) {
                _this._lastMousePosition = newPosition;
            });
        }
        if (element) {
            element = element.elementId;
        }
        else if (!this._movedToElement) {
            // If the mouse has not been moved to any element on this page yet,
            // drivers will either throw errors (FirefoxDriver 2.40.0) or
            // silently fail (ChromeDriver 2.9) when trying to move the mouse
            // cursor relative to the "previous" position; in this case, we
            // just assume that the mouse position defaults to the top-left
            // corner of the document
            if (this.capabilities.brokenHtmlMouseMove) {
                return this.execute('return document.body;').then(function (element) {
                    return element
                        .getPosition()
                        .then(function (position) {
                        return _this.moveMouseTo(element, xOffset - position.x, yOffset - position.y);
                    });
                });
            }
            else {
                return this.execute('return document.documentElement;').then(function (element) {
                    return _this.moveMouseTo(element, xOffset, yOffset);
                });
            }
        }
        var data = {};
        if (element) {
            data.element = element;
        }
        if (xOffset != null) {
            data.xoffset = xOffset;
        }
        if (yOffset != null) {
            data.yoffset = yOffset;
        }
        return this.serverPost('moveto', data).then(function () {
            _this._movedToElement = true;
        });
    };
    /**
     * Clicks a mouse button at the point where the mouse cursor is currently
     * positioned. This method may fail to execute with an error if the mouse
     * has not been moved anywhere since the page was loaded.
     *
     * @param button The button to click. 0 corresponds to the primary mouse
     * button, 1 to the middle mouse button, 2 to the secondary mouse button.
     * Numbers above 2 correspond to any additional buttons a mouse might
     * provide.
     */
    Session.prototype.clickMouseButton = function (button) {
        var _this = this;
        if (this.capabilities.brokenMouseEvents) {
            return this.execute(simulateMouse, [
                {
                    action: 'click',
                    button: button,
                    position: this._lastMousePosition
                }
            ]);
        }
        return this.serverPost('click', {
            button: button
        }).then(function () {
            // ios-driver 0.6.6-SNAPSHOT April 2014 does not wait until the
            // default action for a click event occurs before returning
            if (_this.capabilities.touchEnabled) {
                return util_1.sleep(300);
            }
        });
    };
    /**
     * Depresses a mouse button without releasing it.
     *
     * @param button The button to press. See [[Session.Session.click]] for
     * available options.
     */
    Session.prototype.pressMouseButton = function (button) {
        if (this.capabilities.brokenMouseEvents) {
            return this.execute(simulateMouse, [
                {
                    action: 'mousedown',
                    button: button,
                    position: this._lastMousePosition
                }
            ]);
        }
        return this.serverPost('buttondown', {
            button: button
        });
    };
    /**
     * Releases a previously depressed mouse button.
     *
     * @param button The button to press. See [[Session.Session.click]] for
     * available options.
     */
    Session.prototype.releaseMouseButton = function (button) {
        if (this.capabilities.brokenMouseEvents) {
            return this.execute(simulateMouse, [
                {
                    action: 'mouseup',
                    button: button,
                    position: this._lastMousePosition
                }
            ]);
        }
        return this.serverPost('buttonup', {
            button: button
        });
    };
    /**
     * Double-clicks the primary mouse button.
     */
    Session.prototype.doubleClick = function () {
        var _this = this;
        if (this.capabilities.brokenMouseEvents) {
            return this.execute(simulateMouse, [
                {
                    action: 'dblclick',
                    button: 0,
                    position: this._lastMousePosition
                }
            ]);
        }
        if (this.capabilities.brokenDoubleClick) {
            return this.pressMouseButton()
                .then(function () {
                return _this.releaseMouseButton();
            })
                .then(function () { return _this.serverPost('doubleclick'); });
        }
        return this.serverPost('doubleclick').catch(function () {
            if (_this.capabilities.brokenDoubleClick == null) {
                _this.capabilities.brokenDoubleClick = true;
                return _this.doubleClick();
            }
        });
    };
    /**
     * Taps an element on a touch screen device. If the element is outside of
     * the viewport, the remote driver will attempt to scroll it into view
     * automatically.
     *
     * @param element The element to tap.
     */
    Session.prototype.tap = function (element) {
        return this.serverPost('touch/click', {
            element: element.elementId
        });
    };
    /**
     * Depresses a new finger at the given point on a touch screen device
     * without releasing it.
     *
     * @param x The screen x-coordinate to press, maybe in device pixels.
     * @param y The screen y-coordinate to press, maybe in device pixels.
     */
    Session.prototype.pressFinger = function (x, y) {
        // TODO: If someone specifies the same coordinates as as an existing
        // finger, will it switch the active finger back to that finger instead
        // of adding a new one?
        return this.serverPost('touch/down', { x: x, y: y });
    };
    /**
     * Releases whatever finger exists at the given point on a touch screen
     * device.
     *
     * @param x The screen x-coordinate where a finger is pressed, maybe in
     * device pixels.
     * @param y The screen y-coordinate where a finger is pressed, maybe in
     * device pixels.
     */
    Session.prototype.releaseFinger = function (x, y) {
        return this.serverPost('touch/up', { x: x, y: y });
    };
    /**
     * Moves the last depressed finger to a new point on the touch screen.
     *
     * @param x The screen x-coordinate to move to, maybe in device pixels.
     * @param y The screen y-coordinate to move to, maybe in device pixels.
     */
    Session.prototype.moveFinger = function (x, y) {
        return this.serverPost('touch/move', { x: x, y: y });
    };
    Session.prototype.touchScroll = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var element = args[0], xOffset = args[1], yOffset = args[2];
        if (typeof yOffset === 'undefined' && typeof xOffset !== 'undefined') {
            yOffset = xOffset;
            xOffset = element;
            element = undefined;
        }
        if (this.capabilities.brokenTouchScroll) {
            return this.execute(
            /* istanbul ignore next */ function (element, x, y) {
                var rect = { left: window.scrollX, top: window.scrollY };
                if (element) {
                    var bbox = element.getBoundingClientRect();
                    rect.left += bbox.left;
                    rect.top += bbox.top;
                }
                window.scrollTo(rect.left + x, rect.top + y);
            }, [element, xOffset, yOffset]);
        }
        if (element) {
            element = element.elementId;
        }
        // TODO: If using this, please correct for device pixel ratio to ensure
        // consistency
        return this.serverPost('touch/scroll', {
            element: element,
            xoffset: xOffset,
            yoffset: yOffset
        });
    };
    /**
     * Performs a double-tap gesture on an element.
     *
     * @param element The element to double-tap.
     */
    Session.prototype.doubleTap = function (element) {
        var elementId = element && element.elementId;
        return this.serverPost('touch/doubleclick', {
            element: elementId
        });
    };
    /**
     * Performs a long-tap gesture on an element.
     *
     * @param element The element to long-tap.
     */
    Session.prototype.longTap = function (element) {
        var elementId = element && element.elementId;
        return this.serverPost('touch/longclick', { element: elementId });
    };
    Session.prototype.flickFinger = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var element = args[0], xOffset = args[1], yOffset = args[2], speed = args[3];
        if (typeof speed === 'undefined' &&
            typeof yOffset === 'undefined' &&
            typeof xOffset !== 'undefined') {
            return this.serverPost('touch/flick', {
                xspeed: element,
                yspeed: xOffset
            });
        }
        // if (element) {
        // 	element = element.elementId;
        // }
        return this.serverPost('touch/flick', {
            element: element.elementId,
            xoffset: xOffset,
            yoffset: yOffset,
            speed: speed
        });
    };
    /**
     * Gets the current geographical location of the remote environment.
     *
     * @returns Latitude and longitude are specified using standard WGS84
     * decimal latitude/longitude. Altitude is specified as meters above the
     * WGS84 ellipsoid. Not all environments support altitude.
     */
    Session.prototype.getGeolocation = function () {
        var _this = this;
        return this.serverGet('location').then(function (location) {
            // ChromeDriver 2.9 ignores altitude being set and then returns 0;
            // to match the Geolocation API specification, we will just pretend
            // that altitude is not supported by the browser at all by changing
            // the value to `null` if it is zero but the last set value was not
            // zero
            if (location.altitude === 0 && _this._lastAltitude !== location.altitude) {
                location.altitude = undefined;
            }
            return location;
        });
    };
    /**
     * Sets the geographical location of the remote environment.
     *
     * @param location Latitude and longitude are specified using standard
     * WGS84 decimal latitude/longitude. Altitude is specified as meters above
     * the WGS84 ellipsoid. Not all environments support altitude.
     */
    Session.prototype.setGeolocation = function (location) {
        // TODO: Is it weird that this accepts an object argument? `setCookie`
        // does too, but nothing else does.
        if (location.altitude !== undefined) {
            this._lastAltitude = location.altitude;
        }
        return this.serverPost('location', { location: location });
    };
    /**
     * Gets all logs from the remote environment of the given type. The logs in
     * the remote environment are cleared once they have been retrieved.
     *
     * @param type The type of log entries to retrieve. Available log types
     * differ between remote environments. Use
     * [[Session.Session.getAvailableLogTypes]] to learn what log types are
     * currently available. Not all environments support all possible log
     * types.
     *
     * @returns An array of log entry objects. Timestamps in log entries are
     * Unix timestamps, in seconds.
     */
    Session.prototype.getLogsFor = function (type) {
        return this.serverPost('log', {
            type: type
        }).then(function (logs) {
            // At least Selendroid 0.9.0 returns logs as an array of strings
            // instead of an array of log objects, which is a spec violation;
            // see https://github.com/selendroid/selendroid/issues/366
            if (!logs) {
                return logs;
            }
            if (isStringArray(logs)) {
                return logs.map(function (log) {
                    var logData = /\[([^\]]+)\]\s*\[([^\]]+)\]\s*(.*)/.exec(log);
                    var entry;
                    if (logData) {
                        entry = {
                            timestamp: Date.parse(logData[1]) / 1000,
                            level: logData[2],
                            message: logData[3]
                        };
                    }
                    else {
                        entry = {
                            timestamp: NaN,
                            level: 'INFO',
                            message: log
                        };
                    }
                    return entry;
                });
            }
            else {
                return logs;
            }
        });
    };
    /**
     * Gets the types of logs that are currently available for retrieval from
     * the remote environment.
     */
    Session.prototype.getAvailableLogTypes = function () {
        if (this.capabilities.fixedLogTypes) {
            return common_1.Task.resolve(this.capabilities.fixedLogTypes);
        }
        return this.serverGet('log/types');
    };
    /**
     * Gets the current state of the HTML5 application cache for the current
     * page.
     *
     * @returns The cache status. One of 0 (uncached), 1 (cached/idle), 2
     * (checking), 3 (downloading), 4 (update ready), 5 (obsolete).
     */
    Session.prototype.getApplicationCacheStatus = function () {
        return this.serverGet('application_cache/status');
    };
    /**
     * Terminates the session. No more commands will be accepted by the remote
     * after this point.
     */
    Session.prototype.quit = function () {
        return this._server.deleteSession(this._sessionId);
    };
    /**
     * Gets the list of keys set in local storage for the focused window/frame.
     */
    Session.prototype.getLocalStorageKeys = function () {
        return this.serverGet('local_storage');
    };
    /**
     * Sets a value in local storage for the focused window/frame.
     *
     * @param key The key to set.
     * @param value The value to set.
     */
    Session.prototype.setLocalStorageItem = function (key, value) {
        return this.serverPost('local_storage', { key: key, value: value });
    };
    /**
     * Clears all data in local storage for the focused window/frame.
     */
    Session.prototype.clearLocalStorage = function () {
        return this.serverDelete('local_storage');
    };
    /**
     * Gets a value from local storage for the focused window/frame.
     *
     * @param key The key of the data to get.
     */
    Session.prototype.getLocalStorageItem = function (key) {
        return this.serverGet('local_storage/key/$0', null, [key]);
    };
    /**
     * Deletes a value from local storage for the focused window/frame.
     *
     * @param key The key of the data to delete.
     */
    Session.prototype.deleteLocalStorageItem = function (key) {
        return this.serverDelete('local_storage/key/$0', null, [key]);
    };
    /**
     * Gets the number of keys set in local storage for the focused
     * window/frame.
     */
    Session.prototype.getLocalStorageLength = function () {
        return this.serverGet('local_storage/size');
    };
    /**
     * Gets the list of keys set in session storage for the focused
     * window/frame.
     */
    Session.prototype.getSessionStorageKeys = function () {
        return this.serverGet('session_storage');
    };
    /**
     * Sets a value in session storage for the focused window/frame.
     *
     * @param key The key to set.
     * @param value The value to set.
     */
    Session.prototype.setSessionStorageItem = function (key, value) {
        return this.serverPost('session_storage', { key: key, value: value });
    };
    /**
     * Clears all data in session storage for the focused window/frame.
     */
    Session.prototype.clearSessionStorage = function () {
        return this.serverDelete('session_storage');
    };
    /**
     * Gets a value from session storage for the focused window/frame.
     *
     * @param key The key of the data to get.
     */
    Session.prototype.getSessionStorageItem = function (key) {
        return this.serverGet('session_storage/key/$0', null, [key]);
    };
    /**
     * Deletes a value from session storage for the focused window/frame.
     *
     * @param key The key of the data to delete.
     */
    Session.prototype.deleteSessionStorageItem = function (key) {
        return this.serverDelete('session_storage/key/$0', null, [key]);
    };
    /**
     * Gets the number of keys set in session storage for the focused
     * window/frame.
     */
    Session.prototype.getSessionStorageLength = function () {
        return this.serverGet('session_storage/size');
    };
    /**
     * Gets the first [[Element.Element.isDisplayed|displayed]] element in the
     * currently active window/frame matching the given query. This is
     * inherently slower than [[Session.Session.find]], so should only be used
     * in cases where the visibility of an element cannot be ensured in
     * advance.
     *
     * @since 1.6
     *
     * @param using The element retrieval strategy to use. See
     * [[Session.Session.find]] for options.
     *
     * @param value The strategy-specific value to search for. See
     * [[Session.Session.find]] for details.
     */
    Session.prototype.findDisplayed = function (using, value) {
        return findDisplayed_1.default(this, this, using, value);
    };
    /**
     * Waits for all elements in the currently active window/frame to be
     * destroyed.
     *
     * @param using The element retrieval strategy to use. See
     * [[Session.Session.find]] for options.
     *
     * @param value The strategy-specific value to search for. See
     * [[Session.Session.find]] for details.
     */
    Session.prototype.waitForDeleted = function (using, value) {
        return waitForDeleted_1.default(this, this, using, value);
    };
    /**
     * Gets the timeout for [[Session.Session.executeAsync]] calls.
     */
    Session.prototype.getExecuteAsyncTimeout = function () {
        return this.getTimeout('script');
    };
    /**
     * Sets the timeout for [[Session.Session.executeAsync]] calls.
     *
     * @param ms The length of the timeout, in milliseconds.
     */
    Session.prototype.setExecuteAsyncTimeout = function (ms) {
        return this.setTimeout('script', ms);
    };
    /**
     * Gets the timeout for [[Session.Session.find]] calls.
     */
    Session.prototype.getFindTimeout = function () {
        return this.getTimeout('implicit');
    };
    /**
     * Sets the timeout for [[Session.Session.find]] calls.
     *
     * @param ms The length of the timeout, in milliseconds.
     */
    Session.prototype.setFindTimeout = function (ms) {
        return this.setTimeout('implicit', ms);
    };
    /**
     * Gets the timeout for [[Session.Session.get]] calls.
     */
    Session.prototype.getPageLoadTimeout = function () {
        return this.getTimeout('page load');
    };
    /**
     * Sets the timeout for [[Session.Session.get]] calls.
     *
     * @param ms The length of the timeout, in milliseconds.
     */
    Session.prototype.setPageLoadTimeout = function (ms) {
        return this.setTimeout('page load', ms);
    };
    __decorate([
        forCommand({ createsContext: true })
    ], Session.prototype, "getActiveElement", null);
    __decorate([
        forCommand({ usesElement: true })
    ], Session.prototype, "moveMouseTo", null);
    __decorate([
        forCommand({ usesElement: true })
    ], Session.prototype, "tap", null);
    __decorate([
        forCommand({ usesElement: true })
    ], Session.prototype, "touchScroll", null);
    __decorate([
        forCommand({ usesElement: true })
    ], Session.prototype, "doubleTap", null);
    __decorate([
        forCommand({ usesElement: true })
    ], Session.prototype, "longTap", null);
    __decorate([
        forCommand({ usesElement: true })
    ], Session.prototype, "flickFinger", null);
    return Session;
}(Locator_1.default));
exports.default = Session;
/**
 * Decorator for the [[util.forCommand]] method
 */
function forCommand(properties) {
    return function (target, property, descriptor) {
        var fn = target[property];
        descriptor.value = util_1.forCommand(fn, properties);
    };
}
/**
 * Finds and converts serialised DOM element objects into fully-featured typed
 * Elements.
 *
 * @param session The session from which the Element was retrieved.
 * @param value An object or array that may be, or may contain, serialised DOM
 * element objects.
 * @returns The input value, with all serialised DOM element objects converted
 * to typed Elements.
 */
function convertToElements(session, value) {
    // TODO: Unit test elements attached to objects
    function convert(value) {
        if (Array.isArray(value)) {
            value = value.map(convert);
        }
        else if (typeof value === 'object' && value !== null) {
            if (value.ELEMENT || value['element-6066-11e4-a52e-4f735466cecf']) {
                value = new Element_1.default(value, session);
            }
            else {
                for (var k in value) {
                    value[k] = convert(value[k]);
                }
            }
        }
        return value;
    }
    return convert(value);
}
/**
 * As of Selenium 2.40.0 (March 2014), all drivers incorrectly transmit an
 * UnknownError instead of a JavaScriptError when user code fails to execute
 * correctly. This method corrects this status code, under the assumption that
 * drivers will follow the spec in future.
 */
function fixExecuteError(error) {
    if (error.name === 'UnknownError') {
        error.status = '17';
        error.name = statusCodes_1.default[error.status][0];
    }
    throw error;
}
/**
 * HTTP cookies are transmitted as semicolon-delimited strings, with a
 * `key=value` pair giving the cookieâ€™s name and value, then additional
 * information about the cookie (expiry, path, domain, etc.) as additional k-v
 * pairs. This method takes an Array describing the parts of a cookie
 * (`target`), and a hash map containing the additional information (`source`),
 * and pushes the properties from the source object onto the target array as
 * properly escaped key-value strings.
 */
function pushCookieProperties(target, source) {
    Object.keys(source).forEach(function (key) {
        var value = source[key];
        if (key === 'name' ||
            key === 'value' ||
            (key === 'domain' && value === 'http')) {
            return;
        }
        if (typeof value === 'boolean') {
            value && target.push(key);
        }
        else if (key === 'expiry') {
            // JsonWireProtocol uses the key 'expiry' but JavaScript cookies
            // use the key 'expires'
            if (typeof value === 'number') {
                value = new Date(value * 1000);
            }
            if (value instanceof Date) {
                value = value.toUTCString();
            }
            target.push('expires=' + encodeURIComponent(value));
        }
        else {
            target.push(key + '=' + encodeURIComponent(value));
        }
    });
}
/* istanbul ignore next */
/**
 * Simulates a keyboard event as it would occur on Safari 7.
 *
 * @param keys Keys to type.
 */
function simulateKeys(keys) {
    var _a;
    var target = document.activeElement;
    function dispatch(kwArgs) {
        var event;
        if (typeof KeyboardEvent === 'function') {
            event = new KeyboardEvent(kwArgs.type, {
                bubbles: true,
                cancelable: kwArgs.cancelable || false,
                view: window,
                key: kwArgs.key || '',
                location: 3
            });
        }
        else {
            event = document.createEvent('KeyboardEvent');
            event.initKeyboardEvent(kwArgs.type, true, kwArgs.cancelable || false, window, kwArgs.key || '', 3, '', 0, '');
        }
        return target.dispatchEvent(event);
    }
    function dispatchInput() {
        var event;
        if (typeof Event === 'function') {
            event = new Event('input', { bubbles: true, cancelable: false });
        }
        else {
            event = document.createEvent('Event');
            event.initEvent('input', true, false);
        }
        return target.dispatchEvent(event);
    }
    keys = (_a = []).concat.apply(_a, keys.map(function (keys) { return keys.split(''); }));
    for (var i = 0, j = keys.length; i < j; ++i) {
        var key = keys[i];
        var performDefault = true;
        performDefault = dispatch({
            type: 'keydown',
            cancelable: true,
            key: key
        });
        performDefault =
            performDefault &&
                dispatch({ type: 'keypress', cancelable: true, key: key });
        if (performDefault) {
            if ('value' in target) {
                target.value =
                    target.value.slice(0, target.selectionStart) +
                        key +
                        target.value.slice(target.selectionEnd);
                dispatchInput();
            }
            else if (target.isContentEditable) {
                var node = document.createTextNode(key);
                var selection = window.getSelection();
                var range = selection.getRangeAt(0);
                range.deleteContents();
                range.insertNode(node);
                range.setStartAfter(node);
                range.setEndAfter(node);
                selection.removeAllRanges();
                selection.addRange(range);
            }
        }
        dispatch({ type: 'keyup', cancelable: true, key: key });
    }
}
/* istanbul ignore next */
/**
 * Simulates a mouse event as it would occur on Safari 7.
 *
 * @param kwArgs Parameters for the mouse event.
 */
function simulateMouse(kwArgs) {
    var position = kwArgs.position;
    function dispatch(kwArgs) {
        var event;
        if (typeof MouseEvent === 'function') {
            event = new MouseEvent(kwArgs.type, {
                bubbles: 'bubbles' in kwArgs ? kwArgs.bubbles : true,
                cancelable: kwArgs.cancelable || false,
                view: window,
                detail: kwArgs.detail || 0,
                screenX: window.screenX + position.x,
                screenY: window.screenY + position.y,
                clientX: position.x,
                clientY: position.y,
                ctrlKey: kwArgs.ctrlKey || false,
                shiftKey: kwArgs.shiftKey || false,
                altKey: kwArgs.altKey || false,
                metaKey: kwArgs.metaKey || false,
                button: kwArgs.button || 0,
                relatedTarget: kwArgs.relatedTarget
            });
        }
        else {
            event = document.createEvent('MouseEvents');
            event.initMouseEvent(kwArgs.type, kwArgs.bubbles || true, kwArgs.cancelable || false, window, kwArgs.detail || 0, window.screenX + position.x, window.screenY + position.y, position.x, position.y, kwArgs.ctrlKey || false, kwArgs.altKey || false, kwArgs.shiftKey || false, kwArgs.metaKey || false, kwArgs.button || 0, kwArgs.relatedTarget || null);
        }
        return kwArgs.target.dispatchEvent(event);
    }
    function click(target, button, detail) {
        if (!down(target, button)) {
            return false;
        }
        if (!up(target, button)) {
            return false;
        }
        return dispatch({
            button: button,
            cancelable: true,
            detail: detail,
            target: target,
            type: 'click'
        });
    }
    function down(target, button) {
        return dispatch({
            button: button,
            cancelable: true,
            target: target,
            type: 'mousedown'
        });
    }
    function up(target, button) {
        return dispatch({
            button: button,
            cancelable: true,
            target: target,
            type: 'mouseup'
        });
    }
    function move(currentElement, newElement, xOffset, yOffset) {
        if (newElement) {
            var bbox = newElement.getBoundingClientRect();
            if (xOffset == null) {
                xOffset = (bbox.right - bbox.left) * 0.5;
            }
            if (yOffset == null) {
                yOffset = (bbox.bottom - bbox.top) * 0.5;
            }
            position = { x: bbox.left + xOffset, y: bbox.top + yOffset };
        }
        else {
            position.x += xOffset || 0;
            position.y += yOffset || 0;
            newElement = (document.elementFromPoint(position.x, position.y));
        }
        if (currentElement !== newElement) {
            dispatch({
                type: 'mouseout',
                target: currentElement,
                relatedTarget: newElement
            });
            dispatch({
                type: 'mouseleave',
                target: currentElement,
                relatedTarget: newElement,
                bubbles: false
            });
            dispatch({
                type: 'mouseenter',
                target: newElement,
                relatedTarget: currentElement,
                bubbles: false
            });
            dispatch({
                type: 'mouseover',
                target: newElement,
                relatedTarget: currentElement
            });
        }
        dispatch({ type: 'mousemove', target: newElement, bubbles: true });
        return position;
    }
    var target = document.elementFromPoint(position.x, position.y);
    if (kwArgs.action === 'mousemove') {
        return move(target, kwArgs.element, kwArgs.xOffset, kwArgs.yOffset);
    }
    else if (kwArgs.action === 'mousedown') {
        return down(target, kwArgs.button);
    }
    else if (kwArgs.action === 'mouseup') {
        return up(target, kwArgs.button);
    }
    else if (kwArgs.action === 'click') {
        return click(target, kwArgs.button, 0);
    }
    else if (kwArgs.action === 'dblclick') {
        if (!click(target, kwArgs.button, 0)) {
            return false;
        }
        if (!click(target, kwArgs.button, 1)) {
            return false;
        }
        return dispatch({
            type: 'dblclick',
            target: target,
            button: kwArgs.button,
            detail: 2,
            cancelable: true
        });
    }
}
function isStringArray(value) {
    return Array.isArray(value) && typeof value[0] === 'string';
}
//# sourceMappingURL=Session.js.map