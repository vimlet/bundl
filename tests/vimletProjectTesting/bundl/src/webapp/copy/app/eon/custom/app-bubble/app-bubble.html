<script>
  eon.element("app-bubble", {
    style: "app-bubble.css",

    properties: {
      // @html-attribute scrollSelector (public) [Scrollable parent node selector]
      scrollSelector: {
        value: ""
      },
      // @html-attribute scrollParent (public) [Scrollable parent node]
      scrollParent: {
        value: "",
        observe: true
      },
      // @html-attribute previousScroll (public) [Icon font class]
      icon: {
        value: ""
      },
      // @html-attribute previousScroll (public) [Custom icon style class]
      iconClass: {
        value: ""
      },
      // @html-attribute previousScroll (public) [The current scroll Y value of the scroll parent]
      scrollY: {
        value: ""
      }
    },
    privateProperties: {
      // @html-attribute scrollableRegex (private) [* Should be assigned using javascript]
      scrollableRegex: {
        value: /(auto|scroll)/
      }
    },
    functions: {
      // @function hide (public)
      hide: function () {
        this.classList.add("bubble-hide");
      },
      // @function show (public)
      show: function () {
        this.classList.remove("bubble-hide");
      }
    },
    privateFunctions: {
      // @function _init (private)
      init: function () {
        this._scrollableRegex = /(auto|scroll)/;

        this.scrollParent = this.scrollParent || this._getScrollParent();
        this._setupScrollListener();
        this._setupIcon();
      },
      // @function _getScrollParent (private)
      getScrollParent: function () {
        // If no scrollEl is provided get first bubbleEl scroll parent
        var scrollParent = this.scrollSelector ? $1(this.scrollSelector) : this._getEnclosingScroll();

        return  scrollParent.tagName.toLowerCase() == "eon-scroll" ? scrollParent.children[0] : scrollParent;
      },
      // @function _getEnclosingSroll (private)
      getEnclosingScroll: function (parentNode) {
        this._nextParent = !parentNode ? this.parentNode : parentNode.parentNode;

        // Return body if no parent node provided, check if node is scrollable, if not try its parent
        return !this._nextParent || this._nextParent === document.body ? document.body
          : this._isScrollable(this._nextParent) ? this._nextParent
            : this._getEnclosingScroll(this._nextParent);
      },
      // @function _isScrollable (private)
      isScrollable: function (node) {
        return node.scrollHeight > node.clientHeight || this._scrollableRegex.test(
          this._getStyleProp(node, "overflow") +
          this._getStyleProp(node, "overflow-y") +
          this._getStyleProp(node, "overflow-x")
        );
      },
      // @function _getStyleProp (private)
      getStyleProp: function (node, prop) {
        return window.getComputedStyle(node, null).getPropertyValue(prop);
      },
      // @function _setupScrollListener (private)
      setupScrollListener: function () {
        var el = this;
        var scrollComponent;

        // Hide bubble while scrolling down and show while scrolling top
        this._scrollFn = function(position){
          var scrollTop = position.scrollTop || this.scrollTop || this.pageYOffset;

          if(el._isAtBottom(scrollTop)) {
            el.show();
          } else {
            if (!el.scrollY || el.scrollY < scrollTop) {
              el.hide();
            } else {
              el.show();
            }
          }
          el.scrollY = scrollTop;
        };

        scrollComponent = this.scrollParent.classList.contains("eon-scroll-content") ? this.scrollParent.parentNode : this.scrollParent;
        
        // Scroll down listener
        if(scrollComponent.onScrolled) {
          // If its an eon scroll node, retrieve de eon-scroll component node
          scrollComponent.onScrolled(this._scrollFn);
        } else {
          // ** Use window instead of body when documentElement has overflow hidden value (Fixes html & body scroll incongruous behavior)
          
          // Native scroll
          if(scrollComponent.tagName.toLowerCase() == "body") {
            this.scrollParent = scrollComponent.tagName.toLowerCase() == "body" && window.getComputedStyle(document.documentElement).overflow != "hidden" 
            ? window : scrollComponent;
            // window.addEventListener("scroll", this._scrollFn.bind(this.scrollParent));
            window.onscroll = this._scrollFn.bind(this.scrollParent);
          } else {
            this.scrollParent.addEventListener("scroll", this._scrollFn.bind(this.scrollParent));
          }

        }
      },
      // @function _isAtBottom (private)
      isAtBottom: function (scrollTop) {
        var isAtBottom = false;
        // ** If html document height is 100% it is not posiblle to find out if scroll is at bottom
        // ** This is because window has no scrollHeight information and document element only give us that value in this case
        if(this.scrollParent == window || this.scrollParent == document.body) {
          // Logic for window/body
          isAtBottom = Math.max(window.pageYOffset, document.documentElement.scrollTop, document.body.scrollTop) + window.innerHeight === document.body.scrollHeight;
        } else {
          // Logic for any other element
          var scrollHeight = this.scrollParent.scrollHeight;
          var nodeHeight = this.scrollParent.offsetHeight;
          scrollTop = scrollTop || this.scrollParent.scrollTop;
          isAtBottom = (nodeHeight + scrollTop) >= scrollHeight
        }
        return isAtBottom;
      },
      // @function _setupIcon (private)
      setupIcon: function () {
        this._refs.icon = this.$1("i");
        // Create icon if not exists
        if (!this._refs.icon && el.icon) {
          // Improvement - Inject icon html
          this._refs.icon = document.createElement("i");
          this._refs.icon.classList.add("ticon", el.icon);
          this.appendChild(this._refs.icon);
        }

        // Add custom icon class
        if(this.iconClass) {
          this._refs.icon.classList.add(this.iconClass);
        }
      }
    },
    onTransformed: function () {
      this._init();
    },
    onPropertyChanged: function (key, oldVal, newVal) {
      switch (key) {
        case "scrollParent":
          this.scrollParent = this.scrollParent || this._getScrollParent();
          break;
      }
    }
  });
</script>